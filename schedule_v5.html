<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>週間手術スケジュール</title>
  <style>
    :root{--slot-h:28px;--gap:0}
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Hiragino Kaku Gothic ProN','Meiryo',sans-serif}
    .topbar{display:flex;flex-wrap:wrap;justify-content:space-between;gap:8px;padding:8px 12px;border-bottom:1px solid #ddd;position:sticky;top:0;background:#fff;z-index:5}
    .group{display:flex;gap:8px;align-items:center}
    button{padding:6px 10px;border:1px solid #bbb;background:#fff;border-radius:6px;cursor:pointer}
    button.primary{background:#2563eb;color:#fff;border-color:#1e40af}
    .icon-btn{background:transparent!important;border:none!important;padding:0!important;margin-left:6px;font-size:14px;cursor:pointer}
    .icon-btn:hover{opacity:.8}
    #schedule{padding:12px;display:grid;grid-template-columns:1fr 1fr;column-gap:16px;row-gap:0}
    .column{display:flex;flex-direction:column;row-gap:16px}
    .day{border:2px solid #000;background:#fff;position:relative}
    .day-header{display:flex;align-items:center;justify-content:space-between;gap:12px;min-height:32px;padding:4px 8px;background:#f7f7f7;border-bottom:1px solid #ddd;font-weight:700}
    .day-header-date{white-space:nowrap}
    .day-note-inline{flex:1 1 auto;display:flex;justify-content:flex-end;min-width:0}
    .day-note-input{width:100%;min-width:0;height:auto;line-height:1.4;padding:6px 8px;border:1px solid #d1d5db;border-radius:6px;font-size:13px;outline:none;white-space:pre-wrap;word-break:break-word;overflow:auto;resize:none;min-height:2.8em;max-height:2.8em}
    .day-note-input:focus{border-color:#2563eb;box-shadow:0 0 0 1px rgba(37,99,235,.2)}
    .section-title{margin:0;padding:2px 6px;font-size:12px;font-weight:600;border-top:1px solid #999;border-bottom:1px solid #999;background:#f8f8f8;display:flex;align-items:center}
    .slots{display:grid;grid-auto-rows:var(--slot-h);row-gap:var(--gap);padding:0;position:relative}
    .slot{border-top:1px solid #d0d5dd;padding:3px 5px;background:#fff;display:grid;grid-template-columns:40px 1fr;gap:6px;align-items:start;cursor:grab;position:relative}
    .slot.empty{opacity:.8;background:#fbfbfb}
    .time{font-weight:700;text-align:left;padding:0 4px 0 2px;user-select:none;cursor:pointer}
    .content{display:flex;align-items:center;justify-content:space-between;gap:6px;font-size:13px}
    .content-left{flex:1 1 auto;min-width:0;padding-right:52px}
    .surgeon-tag{position:absolute;top:4px;right:6px;white-space:nowrap;font-weight:600;padding:2px 6px;border:1px solid #1e3a8a;border-radius:10px;font-size:12px}
    .slot.empty .surgeon-tag{display:none}

    /* レイアウト切替用 */
    body.fiveCols #schedule{grid-template-columns:repeat(5,minmax(var(--col-min-5,300px),1fr));gap:16px;align-items:start;overflow-x:auto;-webkit-overflow-scrolling:touch}
    body.fiveCols #leftCol, body.fiveCols #rightCol{display:contents}
    body.fourCols #schedule{grid-template-columns:repeat(4,minmax(var(--col-min-4,360px),1fr));gap:16px;align-items:start;overflow-x:auto;-webkit-overflow-scrolling:touch}
    body.fourCols #leftCol, body.fourCols #rightCol{display:contents}
    body.fourCols .dayStack{display:flex;flex-direction:column;gap:16px;min-width:0;width:100%}
    body.fiveCols .dayStack{display:flex;flex-direction:column;gap:16px;min-width:0;width:100%}

    /* 週末 臨時手術（まとめセクション） */
    .weekend{ border:2px dashed #cbd5e1; background:#fafafa; position:relative; }
    .weekend .day-header{ background:#f3f4f6; border-bottom:1px dashed #cbd5e1; }
    .weekend .section-title{ background:#f8fafc; justify-content:flex-start; }

    /* 休止日（終日 or セクション）見た目 */
    .day.is-off { background:#f5f5f5; opacity:.9; }
    .day.is-off .slot:not(.temp-slot),
    .slots.section-off .slot:not(.temp-slot) {
      pointer-events: none;
      background: #eee !important;
      opacity: .8;
    }
    .day.is-off .slots,
    .slots.section-off { filter: grayscale(1) contrast(.9); }

    /* 臨時（temp）は常に赤＆操作可 */
    .temp-slot{ background: rgba(255, 100, 100, .15) !important; }
    .day.is-off .temp-slot,
    .slots.section-off .temp-slot {
      filter: none; pointer-events: auto; opacity: 1;
    }

    /* 個別に“臨時化（緊急）”した枠を最優先 */
    .emergency-slot { background: rgba(255, 100, 100, .15) !important; opacity: 1 !important; filter: none !important; pointer-events: auto !important; }
    .day.is-off  .emergency-slot,
    .slots.section-off .emergency-slot { background: rgba(255,100,100,.15) !important; opacity:1 !important; filter:none !important; pointer-events:auto !important; }

    /* off の最終定義は #bbb に統一 */
    .slot.off{ background:#bbb !important; opacity:1; pointer-events:auto; }

    /* ホバーの薄い青（off は点灯させない） */
    .slot:hover:not(.off) { background: rgba(37, 99, 235, 0.08) !important; }

    /* 祝日見た目 */
    .day.is-holiday .day-header{ background: #fff5f5; }
    .day.is-holiday .day-header-date::after{
      content: " 祝"; display:inline-block; margin-left:.5em; padding:0 .4em; font-size:.85em; color:#b91c1c; border:1px solid #fca5a5; border-radius:6px; background:#ffe4e6;
    }
    /* 祝日でも右クリックを通す保険 */
    .day.is-off .slot, .day.is-holiday .slot { pointer-events:auto; }
    .day.is-off .slots, .day.is-holiday .slots { pointer-events:auto; }

    /* 祝日の枠背景は #bbb（臨時は除外） */
    .day.is-holiday .slot:not(.temp-slot):not(.emergency-slot) { background:#bbb !important; opacity:1 !important; }

    /* 平日のセクション見出しにある＋/−ボタンは非表示、週末のみ表示 */
    .day .section-title .icon-btn, .day .section-title .circle-btn { display:none !important; }
    .weekend .section-title .icon-btn, .weekend .section-title .circle-btn { display:inline-flex !important; }
/* 祝日でも右クリックを通す（最優先で許可） */
.day.is-holiday .slot,
.day.is-holiday .slot.off,
.day.is-holiday .slots {
  pointer-events: auto !important;
}

/* 結合ブロック head 見た目（右肩にバッジ） */
.slot.mergeHead { background: #fefce8; }
.slot.mergeHead .badge {
  display:inline-block;margin-left:.5em;padding:0 .4em;border:1px solid #f59e0b;
  border-radius:6px;font-size:11px;color:#b45309;background:#fffbeb;
}
.hiddenRow { display:none !important; }
.slot.paired { outline: 2px dashed rgba(37,99,235,.4); outline-offset:-2px; }

/* クリックで選択された枠の見た目 */
.slot.focused{
  outline: 2px solid #2563eb;
  outline-offset: -2px;
  background: rgba(37,99,235,0.06);
}

/* スロット境界から下への“にじみ”を止める */
.slot { overflow: hidden; }

.content { overflow: hidden; }
.content-left{
  line-height: 1.2;
  overflow: hidden;
  display: block;
  max-height: calc(var(--slot-h) - 6px);
}

/* ① 通常枠は2行まで＆はみ出し非表示 */
.slot .content-left{
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 2;
  overflow: hidden;
  max-height: calc(2 * 1.2em);
  line-height: 1.2;
  font-size: 10px;
  word-break: break-word;
  white-space: normal;
}

/* ② 結合枠（head）は行数制限を解除して自由に表示 */
.slot.mergeHead .content-left{
  -webkit-line-clamp: unset;
  max-height: none;
  overflow: visible;
  display: block;
  font-size: 13px;
  line-height: 1.3;
}

/* 念のため：結合枠の箱側でクリップしない */
.slot.mergeHead{
  overflow: visible;
}

/* ✅ データの入ったスロットを薄い緑で表示 */
.slot:not(.empty) {
  background-color: #e6ffe6 !important;
}

/* ✅ 結合枠(head)も同じく薄い緑で */
.slot.mergeHead {
  background-color: #e6ffe6 !important;
}

/* 時刻の下に小バッジを置けるように縦レイアウトに */
.time{
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: 2px;
}

/* 「4枠」バッジ（時刻の下に小さく） */
.merge-badge {
  font-size: 11px;
  line-height: 1;
  padding: 1px 6px;
  border: 1px solid #94a3b8;
  border-radius: 9999px;
  background: #eef2ff;
  color: #1e293b;
  user-select: none;
  pointer-events: none;
}

/* 全麻バッジ */
.ga-badge{
  display: inline-block;
  writing-mode: horizontal-tb;
  white-space: nowrap;
  font-size: 11px;
  line-height: 1;
  padding: 1px 6px;
  border-radius: 9999px;
  border: 1px solid #f59e0b;
  background: #fef3c7;
  color: #92400e;
  pointer-events: none;
  user-select: none;
  margin-top: auto;
}

.ga-slot { background: #fff9c4 !important; }

/* --- GA(全麻) は薄い黄色に上書きする --- */
.slot.ga-slot:not(.empty) { background: #fff9c4 !important; }
.mergeHead.ga-slot        { background: #fff9c4 !important; }

/* === 日フォーカス表示（方式A） ===================== */
body.focusDay { --slot-h: 44px; }
body.focusDay #schedule { grid-template-columns: 1fr; }

body.focusDay .day { display:none; }
body.focusDay .day[data-focus="true"] { display:block; }

body.focusDay .time { font-size: 16px; }
body.focusDay .content-left { font-size: 15px; line-height: 1.3; }

/* フォーカス時の戻るフローティングボタン */
#focusBackBtn {
  position: fixed;
  top: 56px;
  right: 16px;
  z-index: 1000;
  padding: 6px 10px;
  border: 1px solid #bbb;
  background: #fff;
  border-radius: 6px;
  cursor: pointer;
  box-shadow: 0 2px 10px rgba(0,0,0,.08);
}

/* ── Day Focus 中は週移動やレイアウト切替を非表示 ── */
body.dayFocus #prevWeek,
body.dayFocus #nextWeek,
body.dayFocus #todayBtn,
body.dayFocus #weekPicker,
body.dayFocus #mode2col,
body.dayFocus #mode4col,
body.dayFocus #mode5col { display: none !important; }

body.dayFocus .topbar [aria-label="レイアウト切替"] { display: none !important; }
#focusBackBtn { display: none; }
body.dayFocus #focusBackBtn { display: inline-flex; }
#focusBackBtn { position: static; }

/* ===== 統一版：印刷レイアウト ===== */
@media print {
  @page { size: A4 portrait; margin: 10mm; }

  .topbar,
  .no-print,
  .print-toolbar { display: none !important; }

  #schedule {
    grid-template-columns: 1fr !important;
    column-gap: 0 !important;
    width: 100% !important;
    margin: 0 !important;
    padding: 0 !important;
  }
  #schedule .column { display: contents !important; }

  :root { --print-slot-h: 8mm; }
  .slots { grid-auto-rows: var(--print-slot-h) !important; }

  .day, .slots, .slot { break-inside: avoid; page-break-inside: avoid; }

  .hide-on-print { display: none !important; }
}
@media print { .ctx-menu { display: none !important; } }

  </style>
</head>
<body>
  <header class="topbar">
    <div class="group">
      <button id="prevWeek">« 前週</button>
      <input type="date" id="weekPicker" />
      <button id="nextWeek">次週 »</button>
      <button id="todayBtn">今週</button>
　　　<button id="settingsBtn">設定</button>
    </div>
    <div class="group">
      <button id="editBtn" class="primary">編集</button>
      <button id="undoBtn">元に戻す</button>
      <button id="redoBtn">やり直し</button>
      <button id="printBtn">印刷</button>
    </div>
    <div class="group" aria-label="レイアウト切替">
      <span>レイアウト:</span>
      <button id="mode2col">2列</button>
      <button id="mode4col">4列</button>
      <button id="mode5col">5列</button>
    </div>
  </header>
  <main id="schedule">
    <div class="column" id="leftCol"></div>
    <div class="column" id="rightCol"></div>
  </main>

<!-- ▼ 編集ダイアログ（旧版と互換の最小項目） -->
<dialog id="editor">
  <form id="editorForm" method="dialog" style="min-width:520px;max-width:720px">
    <h3 id="editorTitle" style="margin:0 0 8px;font-size:16px">枠の編集</h3>
    <div style="display:grid;grid-template-columns:120px 1fr;gap:8px;align-items:center">
      <label>氏名</label><input name="name" />
      <label>患者ID</label><input name="pid" />
      <label>年齢</label><input name="age" />
      <label>眼</label>
      <select name="eye">
        <option value=""></option><option>R</option><option>L</option><option>B</option>
      </select>
      <label>入/外/当日入院</label>
      <select name="io"><option></option><option>入</option><option>外</option><option>当</option></select>
      <label>IOL種類</label><input name="iolType" list="iolTypes" />
      <label>IOL度数</label><input name="iolPower" list="iolPowers" />
      <label>術式1</label><input name="proc1" />
      <label>術式2</label><input name="proc2" />
      <label>術式3</label><input name="proc3" />
      <label>術者</label><input name="surgeon" />
      <label>備考</label><textarea name="note" rows="3" style="resize:vertical"></textarea>
      <label>結合（枠数）</label>
      <div>
        <input type="checkbox" id="mergeSlots" name="mergeSlots">
        <label for="mergeSlots">この枠から</label>
        <input name="mergeSpan" type="number" min="1" value="1" style="width:5em"> 枠
      </div>
      <label for="ga">
       全麻
       <input type="checkbox" id="ga" name="ga" style="margin-right:6px;">
     </label>
     <div></div>
    </div>
    <menu style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
      <button value="clear" style="color:#b91c1c">クリア</button>
      <button value="cancel">キャンセル</button>
      <button value="save" class="primary">保存</button>
    </menu>
  </form>
</dialog>

<!-- datalist（IOL候補） -->
<datalist id="iolTypes"></datalist>
<datalist id="iolPowers"></datalist>

  <template id="slotTemplate">
    <div class="slot" draggable="false">
      <div class="time"></div>
      <div class="content">
        <span class="content-left"></span>
        <span class="surgeon-tag" title="術者"></span>
      </div>
    </div>
  </template>

<!-- ▼▼ 選択肢の供給元：datalist（エディタの入力欄の list="" から参照） -->
<datalist id="iolTypes"></datalist>
<datalist id="procList"></datalist>
<datalist id="procList2"></datalist>
<datalist id="procList3"></datalist>
<datalist id="surgeonsList"></datalist>

<!-- ▼▼ 設定ダイアログ -->
<dialog id="settings" style="width:min(720px, 92vw); padding:16px;">
  <form id="settingsForm" method="dialog" style="display:flex; flex-direction:column; gap:12px;">
    <h3 style="margin:0 0 8px;">候補リストの編集</h3>

    <label style="display:flex; gap:8px;">
      <span style="width:120px; padding-top:6px;">IOL種類</span>
      <textarea id="optIolTypes" rows="4" style="flex:1;"></textarea>
    </label>

    <label style="display:flex; gap:8px;">
      <span style="width:120px; padding-top:6px;">術式１</span>
      <textarea id="optProc1" rows="4" style="flex:1;"></textarea>
    </label>

    <label style="display:flex; gap:8px;">
      <span style="width:120px; padding-top:6px;">術式２</span>
      <textarea id="optProc2" rows="4" style="flex:1;"></textarea>
    </label>

    <label style="display:flex; gap:8px;">
      <span style="width:120px; padding-top:6px;">術式３</span>
      <textarea id="optProc3" rows="4" style="flex:1;"></textarea>
    </label>

    <label style="display:flex; gap:8px;">
      <span style="width:120px; padding-top:6px;">術者</span>
      <textarea id="optSurgeons" rows="4" style="flex:1;"></textarea>
    </label>

    <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:8px;">
      <button value="cancel">閉じる</button>
      <button class="primary" id="settingsSaveBtn" value="save">保存</button>
    </div>
  </form>
</dialog>

  <script>
  "use strict";

  // ===== 基本設定 =====
  const CONFIG = {
    Mon: [{ title: "午前（手術室1）", start: "09:30", slots: 8 }],
    Tue: [
      { title: "午前（手術室1）", start: "09:30", slots: 8 },
      { title: "午後（手術室1）", start: "13:00", slots: 12 },
      { title: "午後（手術室8）", start: "13:00", slots: 10 }
    ],
    Wed: [{ title: "午前（手術室9）", start: "09:30", slots: 8 }],
    Thu: [{ title: "午前（手術室1）", start: "09:30", slots: 8 }],
    Fri: [
      { title: "午前（手術室1）", start: "09:30", slots: 8 },
      { title: "午後（手術室1）", start: "13:00", slots: 12 },
      { title: "午後（手術室8）", start: "13:00", slots: 10 }
    ],
    Weekend: [{ title: "週末臨時手術（Sat/Sun）", start: "09:30", slots: 0 }]
  };

  // 要素参照
  const leftCol  = document.getElementById('leftCol');
  const rightCol = document.getElementById('rightCol');
  const weekPicker = document.getElementById('weekPicker');
  const prevWeekBtn = document.getElementById('prevWeek');
  const nextWeekBtn = document.getElementById('nextWeek');
  const todayBtn    = document.getElementById('todayBtn');
  const printBtn    = document.getElementById('printBtn');
  const slotTpl     = document.getElementById('slotTemplate');
  const mode2 = document.getElementById('mode2col');
  const mode4 = document.getElementById('mode4col');
  const mode5 = document.getElementById('mode5col');
  const editBtn     = document.getElementById('editBtn'); 

// --- クリック選択（編集ボタンと連動）—安全版（重複定義を回避） ---
(function(){
  // 既に初期化済みなら何もしない
  if (window.__selectionInitDone__) return;
  window.__selectionInitDone__ = true;

  // グローバルに1セットだけ持つ（再定義しない）
  if (typeof window.activeSlotEl === 'undefined') window.activeSlotEl = null;
  if (typeof window.lastSelectedKey === 'undefined') window.lastSelectedKey = null;

  if (typeof window.setActiveSlot === 'undefined') {
    window.setActiveSlot = function setActiveSlot(el){
      try {
        if (window.activeSlotEl && window.activeSlotEl !== el){
          window.activeSlotEl.classList.remove('focused');
        }
        window.activeSlotEl = el || null;
        if (window.activeSlotEl){
          window.activeSlotEl.classList.add('focused');
          window.lastSelectedKey = window.activeSlotEl.dataset.key || null;
        }
      } catch(_) {}
    };
  }
})(); 
// ==== 設定（候補リスト） ====
// ストレージキー
const SETTINGS_KEY = 'schedule_lists_settings';

// 既定値
function defaultLists(){
  const powers = [];
  for (let v = 15.0; v <= 30.001; v += 0.5) powers.push(v.toFixed(1)); // 使うなら
  return {
    iolTypes: ["AcrySof IQ","TECNIS","HOYA Vivinex","PanOptix","EDOF"],
    proc1: ["PEA+IOL","PPC+IOL","IOL再固定","眼瞼内反手術"],
    proc2: ["眼内レンズ縫着","前房洗浄","瞳孔形成"],
    proc3: ["複合処置A","複合処置B"],
    surgeons: ["木村","岡部","後藤田","宮部","飯田","森山"]
  };
}

// 読込／保存
function loadSettings(){
  try{
    const s = localStorage.getItem(SETTINGS_KEY);
    const v = s ? JSON.parse(s) : {};
    // 欠けている配列は既定で補完
    return Object.assign(defaultLists(), v||{});
  }catch(_){
    return defaultLists();
  }
}
function saveSettings(obj){
  localStorage.setItem(SETTINGS_KEY, JSON.stringify(obj||{}));
}

// datalist に反映
function setOptions(dl, arr){
  if (!dl) return;
  dl.innerHTML = '';
  (arr||[]).forEach(v=>{
    const opt = document.createElement('option');
    opt.value = String(v);
    dl.appendChild(opt);
  });
}
function applyDatalists(lists){
  setOptions(document.getElementById('iolTypes'),     lists.iolTypes);
  setOptions(document.getElementById('procList'),     lists.proc1);
  setOptions(document.getElementById('procList2'),    lists.proc2);
  setOptions(document.getElementById('procList3'),    lists.proc3);
  setOptions(document.getElementById('surgeonsList'), lists.surgeons);
}

// グローバル設定オブジェクト
let appLists = loadSettings();

  // ===== 日付ユーティリティ =====
  let currentMonday = startOfWeek(new Date());
  function startOfWeek(d){ const x=new Date(d.getFullYear(), d.getMonth(), d.getDate()); const g=x.getDay(); const diff=(g===0?-6:1-g); x.setDate(x.getDate()+diff); x.setHours(0,0,0,0); return x; }
  function addDays(d,n){ const x=new Date(d); x.setDate(x.getDate()+n); return x; }
  function dateISO(d){ const y=d.getFullYear(); const m=String(d.getMonth()+1).padStart(2,'0'); const day=String(d.getDate()).padStart(2,'0'); return `${y}-${m}-${day}`; }
  function weekKey(date){ return dateISO(startOfWeek(date)); }
  function formatDateJP(d){ const y=d.getFullYear(), m=d.getMonth()+1, day=d.getDate(); const w="日月火水木金土"[d.getDay()]; return `${y}/${m}/${day}（${w}）`; }
  function hhmmToMinutes(hhmm){ const [H, M] = String(hhmm).split(':').map(Number); return (isFinite(H) && isFinite(M)) ? H*60 + M : 0; }
  function addMinutes(hhmm, minutes){ let s = String(hhmm).trim().replace(/[！-～]/g, c => String.fromCharCode(c.charCodeAt(0) - 0xFEE0)).replace(/：/g, ':'); const m = /^(\d{1,2}):(\d{2})$/.exec(s); if (!m) return null; const h = Number(m[1]), mm = Number(m[2]); const dt = new Date(2000,0,1,h,mm); if (isNaN(dt.getTime())) return null; dt.setMinutes(dt.getMinutes() + Number(minutes || 0)); return dt.toTimeString().slice(0,5); }
  function normalizeTimeInput(raw){ if(!raw) return null; let s = String(raw).trim(); let m = /^(\d{1,2}):(\d{2})$/.exec(s); if(m){ const h=Number(m[1]), mm=Number(m[2]); if(h>=0&&h<=23&&mm>=0&&mm<=59) return `${String(h).padStart(2,'0')}:${String(mm).padStart(2,'0')}`; return null; } s = s.replace(/\s+/g,'').replace(/[^\d]/g,''); if(s.length===3 || s.length===4){ const hh=s.slice(0,s.length-2), mm=s.slice(-2); const h=Number(hh), m2=Number(mm); if(h>=0&&h<=23&&m2>=0&&m2<=59) return `${String(h).padStart(2,'0')}:${String(m2).padStart(2,'0')}`; } return null; }

// === 日フォーカス・ヘルパー ==========================
function enterDayFocus(dayEl){
document.body.classList.add('dayFocus');
  if (!dayEl) return;
  document.body.classList.add('focusDay');
  dayEl.setAttribute('data-focus','true');

// トップバー右端に「戻る」ボタンを用意（重複作成しない）
if (!document.getElementById('focusBackBtn')){
  const btn = document.createElement('button');
  btn.id = 'focusBackBtn';
  btn.textContent = '戻る';
  btn.addEventListener('click', exitDayFocus);

  // 右端のグループ（印刷/Undo/Redoのグループ）に入れる
const rightGroup = document.querySelector('.topbar .group:nth-of-type(2)') || document.querySelector('.topbar');
  rightGroup.appendChild(btn);
}


  // その日の先頭に寄せる
  try { dayEl.scrollIntoView({ block:'start', behavior:'smooth' }); } catch(_){}
}

function exitDayFocus(){
  document.body.classList.remove('dayFocus');
  document.body.classList.remove('focusDay');
  document.querySelectorAll('.day[data-focus="true"]').forEach(d => d.removeAttribute('data-focus'));
  document.getElementById('focusBackBtn')?.remove();
}

// Escで解除（1回だけバインド）
if (!window.__focusEscBound){
  document.addEventListener('keydown', (e)=>{
    if (e.key === 'Escape' && document.body.classList.contains('focusDay')){
      e.preventDefault();
      exitDayFocus();
    }
  }, true);
  window.__focusEscBound = true;
}

// timeEl から "HH:MM" だけを安全に取り出す
function extractHHMMFromTimeEl(timeEl){
  const txt = (timeEl?.textContent || '').trim();
  const m = txt.match(/\b\d{1,2}:\d{2}\b/);
  return m ? m[0] : '';
}


  // ===== 時刻オーバーライド（週単位） =====
  function loadTimeOverrides(week){ try{ return JSON.parse(localStorage.getItem('timeovr_'+weekKey(week))) || {}; }catch(e){ return {}; } }
  function saveTimeOverrides(week, obj){ localStorage.setItem('timeovr_'+weekKey(week), JSON.stringify(obj||{})); }
  function setTimeOverride(week, dayKey, section, idx, hhmm){ const store = loadTimeOverrides(week); const key = `${dayKey}|${section}`; if(!store[key]) store[key] = {}; store[key][idx] = hhmm; saveTimeOverrides(week, store); }
  function clearTimeOverrideFrom(week, dayKey, section, idx){ const store = loadTimeOverrides(week); const key = `${dayKey}|${section}`; if(store[key]){ for(const k of Object.keys(store[key])){ if(Number(k) >= idx) delete store[key][k]; } if(Object.keys(store[key]).length===0) delete store[key]; saveTimeOverrides(week, store); } }
  function clearTimeOverrideAll(week, dayKey, section){ const store = loadTimeOverrides(week); const key = `${dayKey}|${section}`; if(store[key]){ delete store[key]; saveTimeOverrides(week, store); } }
  function getSlotTimeHHMMEx(baseHHMM, week, dayKey, section, idx){ let store = {}; try { store = JSON.parse(localStorage.getItem('timeovr_' + weekKey(week))) || {}; } catch(_) {} const table = store[`${dayKey}|${section}`] || {}; let anchorIdx = -1, anchorHHMM = baseHHMM; for (const k of Object.keys(table)){ const n = Number(k); if (Number.isFinite(n) && n <= idx && n > anchorIdx){ anchorIdx = n; anchorHHMM = table[k]; } } const steps = idx - (anchorIdx >= 0 ? anchorIdx : 0); return addMinutes(anchorHHMM, steps * 20); }

  // ===== 休止情報 =====
  function loadDayOff(week){ try { return JSON.parse(localStorage.getItem('dayoff_'+weekKey(week))) || {}; } catch(_) { return {}; } }
  function saveDayOffRaw(week, obj){ localStorage.setItem('dayoff_'+weekKey(week), JSON.stringify(obj||{})); }
  function setDayOff(week, dayKey, patch, opts){ const map = loadDayOff(week); const cur = map[dayKey] || {}; map[dayKey] = Object.assign({}, cur, patch||{}); try{ if(opts?.snapshot){ undoStack.push(snapshotState()); redoStack.length=0; } }catch(_){} saveDayOffRaw(week, map); }
  function clearDayOffForDay(week, dayKey, opts){ const map = loadDayOff(week); if (map && map[dayKey] !== undefined) { try{ if(opts?.snapshot){ undoStack.push(snapshotState()); redoStack.length=0; } }catch(_){} delete map[dayKey]; saveDayOffRaw(week, map); } }

  // ===== 個別枠の「臨時化（緊急）」 =====
  function loadEmerg(week){ try{ return JSON.parse(localStorage.getItem('emerg_' + weekKey(week))) || {}; } catch(_){ return {}; } }
  function saveEmergRaw(week, obj){ localStorage.setItem('emerg_' + weekKey(week), JSON.stringify(obj || {})); }
  function setEmergency(week, slotKey, enabled, opts){ const map = loadEmerg(week); if (enabled) map[slotKey] = true; else delete map[slotKey]; try{ if(opts?.snapshot){ undoStack.push(snapshotState()); redoStack.length=0; } }catch(_){} saveEmergRaw(week, map); }

  // ===== 枠数オーバーライド（臨時枠） =====
  function loadSlotOverrides(week){ try{ return JSON.parse(localStorage.getItem('slotovr_'+weekKey(week))) || {}; }catch(e){ return {}; } }
  function saveSlotOverrides(week, obj){ localStorage.setItem('slotovr_'+weekKey(week), JSON.stringify(obj||{})); }
  function getSectionKey(dayKey, section){ return `${dayKey}|${section}`; }
  function ensureSlotOvrShape(ovr, dayKey, section){ const key = getSectionKey(dayKey, section); if (!ovr[key]) ovr[key] = {}; const s = ovr[key]; if (typeof s.extraHead !== 'number') s.extraHead = 0; if (typeof s.extraTail !== 'number') s.extraTail = 0; if (!Array.isArray(s.inserts)) s.inserts = []; s.inserts = Array.from(new Set(s.inserts.filter(n=>Number.isInteger(n) && n>=0))).sort((a,b)=>a-b); return s; }
  function getSectionOvr(week, dayKey, section){ const o = loadSlotOverrides(week) || {}; return ensureSlotOvrShape(o, dayKey, section); }
  function setSectionOvr(week, dayKey, section, patch){ const all = loadSlotOverrides(week) || {}; const s = ensureSlotOvrShape(all, dayKey, section); Object.assign(s, patch); saveSlotOverrides(week, all); }
  function getExtraTailSlots(week, dayKey, section){ return getSectionOvr(week, dayKey, section).extraTail|0; }
  function setExtraTailSlots(week, dayKey, section, n){ const v = Math.max(0, Number(n)||0); setSectionOvr(week, dayKey, section, { extraTail: v }); }
  function addExtraTailSlot(week, dayKey, section, n=1){ const s = getSectionOvr(week, dayKey, section); setSectionOvr(week, dayKey, section, { extraTail: s.extraTail + (Number(n)||0) }); }
  function removeExtraTailSlot(week, dayKey, section){ const cur = getExtraTailSlots(week, dayKey, section); if(cur > 0){ setExtraTailSlots(week, dayKey, section, cur - 1); } }
  function getSectionLayout(week, dayKey, section, baseCount){ const s = getSectionOvr(week, dayKey, section); const extraHead = s.extraHead|0; const extraTail = s.extraTail|0; const inserts = Array.from(new Set(s.inserts)).sort((a,b)=>a-b); const total = extraHead + baseCount + inserts.length + extraTail; function isTemp(idx){ if (idx < extraHead) return true; if (idx >= extraHead + baseCount + inserts.length) return true; const posInBody = idx - extraHead; return inserts.includes(posInBody); } function toBaseIndex(idx){ if (isTemp(idx)) return -1; const posInBody = idx - extraHead; const leftInserts = inserts.filter(n => n < posInBody).length; return posInBody - leftInserts; } return { total, isTemp, toBaseIndex, extraHead, extraTail, inserts }; }
  function insertTempBefore(week, dayKey, section, displayIndex){ const all = loadSlotOverrides(week) || {}; const s = ensureSlotOvrShape(all, dayKey, section); if (displayIndex <= 0){ s.extraHead += 1; saveSlotOverrides(week, all); return; } const layout = getSectionLayout(week, dayKey, section, CONFIG[dayKey][section].slots); const posInBody = Math.max(0, displayIndex - layout.extraHead); if (!s.inserts.includes(posInBody)){ s.inserts.push(posInBody); s.inserts = Array.from(new Set(s.inserts)).sort((a,b)=>a-b); } saveSlotOverrides(week, all); }
  function insertTempAfter(week, dayKey, section, displayIndex){ insertTempBefore(week, dayKey, section, displayIndex + 1); }
  function removeTempAt(week, dayKey, section, displayIndex){ const all = loadSlotOverrides(week) || {}; const s = ensureSlotOvrShape(all, dayKey, section); const baseCount = CONFIG[dayKey][section].slots; const layout = getSectionLayout(week, dayKey, section, baseCount); if (!layout.isTemp(displayIndex)) return; if (displayIndex >= layout.total - 1 && s.extraTail > 0){ s.extraTail -= 1; saveSlotOverrides(week, all); return; } if (displayIndex < s.extraHead && s.extraHead > 0){ s.extraHead -= 1; saveSlotOverrides(week, all); return; } const posInBody = displayIndex - s.extraHead; const i = s.inserts.indexOf(posInBody); if (i >= 0){ s.inserts.splice(i, 1); saveSlotOverrides(week, all); } }

  // ===== Undo / Redo =====
  let undoStack = [];
  let redoStack = [];
  function snapshotState(){ return { timeovr: loadTimeOverrides(currentMonday), slotovr: loadSlotOverrides(currentMonday), notes: loadNotes(currentMonday), dayoff: loadDayOff(currentMonday), emerg: loadEmerg(currentMonday) }; }
  function restoreState(snap){ if(!snap) return; localStorage.setItem('timeovr_' + weekKey(currentMonday), JSON.stringify(snap.timeovr || {})); localStorage.setItem('slotovr_' + weekKey(currentMonday), JSON.stringify(snap.slotovr || {})); localStorage.setItem('notes_'  + weekKey(currentMonday), JSON.stringify(snap.notes  || {})); localStorage.setItem('dayoff_' + weekKey(currentMonday), JSON.stringify(snap.dayoff || {})); localStorage.setItem('emerg_'  + weekKey(currentMonday), JSON.stringify(snap.emerg  || {})); }
  const __saveTimeOverrides = saveTimeOverrides; saveTimeOverrides = function(week, obj){ try{ undoStack.push(snapshotState()); redoStack.length = 0; }catch(e){} __saveTimeOverrides(week, obj); };
  const __saveSlotOverrides = saveSlotOverrides; saveSlotOverrides = function(week, obj){ try{ undoStack.push(snapshotState()); redoStack.length = 0; }catch(e){} __saveSlotOverrides(week, obj); };
  function undo(){ if(undoStack.length === 0){ alert('戻せる操作がありません'); return; } const prev = undoStack.pop(); const cur  = snapshotState(); redoStack.push(cur); restoreState(prev); render(); }
  function redo(){ if(redoStack.length === 0){ alert('やり直し可能な操作がありません'); return; } const next = redoStack.pop(); const cur  = snapshotState(); undoStack.push(cur); restoreState(next); render(); }
  document.getElementById('undoBtn')?.addEventListener('click', undo);
  document.getElementById('redoBtn')?.addEventListener('click', redo);
  function isTypingContext(e){ const el = e.target; const tag = (el?.tagName || '').toLowerCase(); return el?.isContentEditable || tag === 'input' || tag === 'textarea' || tag === 'select'; }
  document.addEventListener('keydown', (e)=>{ if(isTypingContext(e)) return; const k = e.key.toLowerCase(); if((e.ctrlKey || e.metaKey) && !e.shiftKey && k === 'z'){ e.preventDefault(); undo(); }else if((e.ctrlKey || e.metaKey) && (k === 'y' || (e.shiftKey && k === 'z'))){ e.preventDefault(); redo(); } }, true);

// ✅ アクティブ枠の管理（未定義なら初期化）
if (typeof window.activeSlotEl === 'undefined') window.activeSlotEl = null;

function setActiveSlot(el){
  if (window.activeSlotEl && window.activeSlotEl !== el){
    window.activeSlotEl.classList.remove('focused');
  }
  window.activeSlotEl = el;
  if (el){
    el.classList.add('focused');
    // ★ 選択を記録しておく（レイアウト変更後に復活させる用）
    window.lastSelectedKey = el.dataset.key;
  }
}

// ===== 編集ロック判定（祝日/休止→編集不可。臨時/緊急は除外） =====
function isSlotLockedForEdit(slotEl){
  if (!slotEl) return true;                       // 要素が無ければ安全側で不可
  if (slotEl.classList.contains('emergency-slot')) return false; // 緊急は常に可
  if (slotEl.classList.contains('temp-slot'))      return false; // 臨時（週末など）も可

  // セクション/時刻による休止 → .off が付く
  if (slotEl.classList.contains('off')) return true;

  // 祝日（.day に is-holiday が付く）は編集不可
  const day = slotEl.closest('.day');
  if (day && day.classList.contains('is-holiday')) return true;

  return false;
}

  // ===== レイアウト切替 =====
  const MODE_KEY = 'layoutMode';
  let layoutMode = localStorage.getItem(MODE_KEY) || '2';
function applyLayout(mode){
  // dayFocus 中はレイアウト変更を無効化
  if (document.body.classList.contains('dayFocus')) return;

  layoutMode = mode;
  document.body.classList.remove('fiveCols','fourCols');
  if(mode==='5') document.body.classList.add('fiveCols');
  if(mode==='4') document.body.classList.add('fourCols');
  localStorage.setItem(MODE_KEY, layoutMode);
  render();
}

  mode2?.addEventListener('click', ()=> applyLayout('2'));
  mode4?.addEventListener('click', ()=> applyLayout('4'));
  mode5?.addEventListener('click', ()=> applyLayout('5'));

  // ===== 祝日（オフライン自動計算＋上書き） =====
  function ymd(d){ return d.toISOString().slice(0,10); }
  function isoToDate(iso){ const [Y,M,D]=iso.split('-').map(Number); return new Date(Y, M-1, D); }
  function vernalEquinoxDay(Y){ return Math.floor(20.8431 + 0.242194*(Y-1980) - Math.floor((Y-1980)/4)); }
  function autumnalEquinoxDay(Y){ return Math.floor(23.2488 + 0.242194*(Y-1980) - Math.floor((Y-1980)/4)); }
  function nthWeekdayOfMonth(Y, M, weekday, n){ const d = new Date(Y, M-1, 1); const first = d.getDay(); const delta = (weekday - first + 7) % 7; return 1 + delta + 7*(n-1); }
  function genHolidaysAuto(year){ const H = new Set(); const push = (m, d)=> H.add(`${year}-${String(m).padStart(2,'0')}-${String(d).padStart(2,'0')}`); push(1,1); push(2,11); if(year >= 2020) push(2,23); push(4,29); push(5,3); push(5,4); push(5,5); push(8,11); push(11,3); push(11,23); const MON=1,SUN=0; push(1, nthWeekdayOfMonth(year, 1, MON, 2)); push(7, nthWeekdayOfMonth(year, 7, MON, 3)); push(9, nthWeekdayOfMonth(year, 9, MON, 3)); push(10, nthWeekdayOfMonth(year,10, MON, 2)); push(3, vernalEquinoxDay(year)); push(9, autumnalEquinoxDay(year)); const isHoliday = (iso)=> H.has(iso); const addSubstitute = (isoStart)=>{ let d = isoToDate(isoStart); do { d.setDate(d.getDate()+1); } while (d.getDay() === SUN || isHoliday(ymd(d))); H.add(ymd(d)); }; for(const iso of Array.from(H)){ const dt = isoToDate(iso); if (dt.getDay() === SUN) addSubstitute(iso); } const span = (m)=> new Date(year, m, 0).getDate(); for(let m=1;m<=12;m++){ for(let d=2; d<span(m-1); d++){ const cur = `${year}-${String(m).padStart(2,'0')}-${String(d).padStart(2,'0')}`; const prev = ymd(new Date(year, m-1, d-1)); const next = ymd(new Date(year, m-1, d+1)); const wd = isoToDate(cur).getDay(); if (!H.has(cur) && H.has(prev) && H.has(next) && wd !== SUN){ H.add(cur); } } } return H; }
  function loadHolidayAuto(year){ try{ const s = localStorage.getItem('holidays_auto_'+year); return s? new Set(JSON.parse(s)) : new Set(); }catch(_){ return new Set(); }
  }
  function saveHolidayAuto(year, set){ localStorage.setItem('holidays_auto_'+year, JSON.stringify(Array.from(set||[]))); }
  function ensureHolidayAuto(year){ let s = loadHolidayAuto(year); if(!s || s.size===0){ s = genHolidaysAuto(year); saveHolidayAuto(year, s); } return s; }
  function loadHolidayPatch(year){ try{ return JSON.parse(localStorage.getItem('holidays_patch_'+year))||{}; }catch(_){ return {}; } }
  function saveHolidayPatch(year,obj){ localStorage.setItem('holidays_patch_'+year, JSON.stringify(obj||{})); }
  function loadHolidayManual(){ try{ return JSON.parse(localStorage.getItem('holidays_manual'))||{}; }catch(_){ return {}; } }
  function saveHolidayManual(obj){ localStorage.setItem('holidays_manual', JSON.stringify(obj||{})); }
  function isHolidayISO(iso){ const Y = Number(iso.slice(0,4)); const manual = loadHolidayManual(); if (manual[iso] === true)  return true; if (manual[iso] === false) return false; const patch = loadHolidayPatch(Y); if (patch[iso]) return true; const auto = ensureHolidayAuto(Y); return auto.has(iso); }
  function toggleHolidayManual(iso, toFlag){ const m = loadHolidayManual(); m[iso] = toFlag; saveHolidayManual(m); }

  // ===== ノート =====
  function loadNotes(week){ try{ return JSON.parse(localStorage.getItem('notes_'+weekKey(week))) || {}; }catch(e){ return {}; } }
  function getDayNote(week, dayKey){ const obj = loadNotes(week); return String(obj[dayKey]||''); }
  function setDayNote(week, dayKey, text, opts){ const o = loadNotes(week); o[dayKey] = String(text||''); try{ if(opts&&opts.snapshot){ undoStack.push(snapshotState()); redoStack.length=0; } }catch(_){ } localStorage.setItem('notes_'+weekKey(week), JSON.stringify(o)); }

function restoreSelection(){
  try{
    if (!window.lastSelectedKey) return;
    const el = document.querySelector(`.slot[data-key="${window.lastSelectedKey}"]`);
    if (el) {
      setActiveSlot(el);
      el.scrollIntoView({ block: 'nearest', inline: 'nearest' });
    } else {
      setActiveSlot(null);
    }
  }catch(_){}
}

// 表現形テキストを枠内に2行までで収める（1行=13px, 溢れたら10px）
function autoFitContentLines(){
  const nodes = document.querySelectorAll('.slot .content-left');
  nodes.forEach(el => {
    el.style.fontSize = '13px';
    const fits = el.scrollHeight <= el.clientHeight + 0.5;
    if (!fits){
      el.style.fontSize = '10px';
    }
  });
}

function applyGaColoring(){
  const st = loadWeek(currentMonday);
  document.querySelectorAll('.slot').forEach(el=>{
    const d = st[el.dataset.key];
    if (d && d.ga && !d.tail) el.classList.add('ga-slot');
    else el.classList.remove('ga-slot');
  });
}

  // ===== 描画 =====
  function render(){
　　applyDatalists(appLists);
    weekPicker.value = dateISO(currentMonday);
    leftCol.innerHTML=''; rightCol.innerHTML='';

    if(layoutMode==='5'){
      leftCol.appendChild(buildDay('Mon', 0));
      leftCol.appendChild(buildDay('Tue', 1));
      leftCol.appendChild(buildDay('Wed', 2));
      leftCol.appendChild(buildDay('Thu', 3));
      const friStack = document.createElement('div');
      friStack.className = 'dayStack';
      friStack.appendChild(buildDay('Fri', 4));
      friStack.appendChild(buildWeekend());
      leftCol.appendChild(friStack);
      restoreSelection();
　　　paintSlotsFromStore();
　　　autoFitContentLines();
      document.querySelectorAll('.slots').forEach(sl => applyMerges(sl, loadWeek(currentMonday)));
      applyGaColoring();
      return;
    }

    if(layoutMode==='4'){
      leftCol.appendChild(buildDay('Mon', 0));
      leftCol.appendChild(buildDay('Tue', 1));
      leftCol.appendChild(buildDayStack([
        ['Wed', 2, { combined: true }],
        ['Thu', 3, {}]
      ]));
      const friStack4 = document.createElement('div');
      friStack4.className = 'dayStack';
      friStack4.appendChild(buildDay('Fri', 4));
      friStack4.appendChild(buildWeekend());
      leftCol.appendChild(friStack4);
      restoreSelection();
　　　paintSlotsFromStore();
　　　autoFitContentLines();
      document.querySelectorAll('.slots').forEach(sl => applyMerges(sl, loadWeek(currentMonday)));
      applyGaColoring();
      return;
    }

    leftCol.appendChild(buildDay('Mon', 0));
    leftCol.appendChild(buildDay('Tue', 1));
    leftCol.appendChild(buildDay('Wed', 2, { combined: true }));
    rightCol.appendChild(buildDay('Thu', 3));
    rightCol.appendChild(buildDay('Fri', 4));
    rightCol.appendChild(buildWeekend());
    restoreSelection();
　　paintSlotsFromStore();
　　autoFitContentLines();
    document.querySelectorAll('.slots').forEach(sl => applyMerges(sl, loadWeek(currentMonday)));
    applyGaColoring();
  }

  function buildDayStack(specList){
    const stack = document.createElement('div');
    stack.className = 'dayStack';
    for(const [dk, off, opt] of specList){ stack.appendChild(buildDay(dk, off, opt||{})); }
    return stack;
  }

  function buildDay(dayKey, offsetIdx, opt={}){
    const dayDate = addDays(currentMonday, offsetIdx);
    const wrap = document.createElement('section'); wrap.className = 'day';
    const iso = dateISO(dayDate);
    const isHol = isHolidayISO(iso);
    if (isHol){ wrap.classList.add('is-holiday', 'is-off'); }

    const header = document.createElement('div'); header.className = 'day-header';
    const dateEl = document.createElement('div'); dateEl.className = 'day-header-date'; dateEl.textContent = formatDateJP(dayDate);
    const noteWrap = document.createElement('div'); noteWrap.className = 'day-note-inline';
    const noteInput = document.createElement('textarea'); noteInput.rows = 2; noteInput.className = 'day-note-input';
    noteWrap.appendChild(noteInput);
    noteInput.value = getDayNote(currentMonday, dayKey);
    noteInput.addEventListener('focus', ()=>{ try{ undoStack.push(snapshotState()); redoStack.length=0; }catch(_){}});
    noteInput.addEventListener('input', ()=>{ setDayNote(currentMonday, dayKey, noteInput.value); });
    header.appendChild(dateEl); header.appendChild(noteWrap); wrap.appendChild(header);
// 日付ヘッダー：ダブルクリックでフォーカスON/OFF
header.addEventListener('dblclick', (e)=>{
  if (document.body.classList.contains('focusDay')) {
    exitDayFocus();
  } else {
    enterDayFocus(wrap);
  }
});


    // 曜日ヘッダ 右クリックメニュー
    header.addEventListener('contextmenu', (e)=>{
      e.preventDefault(); e.stopPropagation();
      const off   = loadDayOff(currentMonday);
      const isOff = !!(off[dayKey]?.day);
      const menu = document.createElement('div');
      menu.className = 'ctx-menu';
      Object.assign(menu.style,{position:'fixed',zIndex:'99999',left:e.clientX+'px',top:e.clientY+'px',background:'#fff',border:'1px solid #ddd',borderRadius:'8px',boxShadow:'0 4px 18px rgba(0,0,0,.12)',padding:'6px',fontSize:'13px',minWidth:'220px'});
      const addItem=(label,fn,opts={})=>{ const it=document.createElement('div'); it.textContent=label; it.style.padding='6px 10px'; it.style.cursor=opts.disabled?'not-allowed':'pointer'; it.style.color=opts.danger?'#b91c1c':''; if(!opts.disabled){ it.addEventListener('mouseenter',()=>it.style.background='#f5f5f7'); it.addEventListener('mouseleave',()=>it.style.background=''); it.addEventListener('click',()=>{ fn(); menu.remove(); }); } menu.appendChild(it); };
      addItem(isHol ? 'この日の祝日扱いを解除（手動）' : 'この日を祝日として扱う（手動）', ()=>{ toggleHolidayManual(iso, !isHol); render(); });
      addItem(isOff ? 'この日の「終日休止」を解除' : 'この日を「終日休止」にする', ()=>{ setDayOff(currentMonday, dayKey, { day: !isOff }, { snapshot:true }); render(); });
      addItem('────────', ()=>{}, {disabled:true});
      addItem('この日の休止を「全リセット」', ()=>{ if(confirm('この日の休止設定（終日/セクション/以後/以前）をすべて解除します。よろしいですか？')){ clearDayOffForDay(currentMonday, dayKey, { snapshot:true }); render(); } }, {danger:true});
      addItem('────────', ()=>{}, {disabled:true});
      addItem('この日の「枠の形」をデフォルトに戻す', ()=>{ if (confirm('この日の枠形状（先頭臨時・途中挿入・末尾臨時）をすべて解除して、初期の枠数に戻します。よろしいですか？')) { resetSlotLayoutForDay(currentMonday, dayKey, { snapshot:true }); render(); } });
 addItem('この日を印刷（A4）', ()=> printDayElement(wrap));
      const close=(ev)=>{ if(!menu.contains(ev.target)){ document.removeEventListener('mousedown',close,true); menu.remove(); } };
      document.addEventListener('mousedown', close, true);
      document.body.appendChild(menu);
    });

    const sections = CONFIG[dayKey];
    const off = loadDayOff(currentMonday);
    const dayIsOff = !!(off[dayKey]?.day);

    // 午前
    const am = sections[0];
    const stAm = document.createElement('div'); stAm.className = 'section-title thin';
    const titleSpan = document.createElement('span'); titleSpan.textContent = am.title; stAm.appendChild(titleSpan);
    wrap.appendChild(stAm);

// ここから置き換え
stAm.addEventListener('contextmenu', (e)=>{
  e.preventDefault();
  e.stopPropagation();

  const off = loadDayOff(currentMonday);
  const cur = off[dayKey]?.sections?.[0] === true;

  // シンプルなポップアップメニューを生成
  const menu = document.createElement('div');
  Object.assign(menu.style, {
    position: 'fixed',
    zIndex: '99999',
    left: e.clientX + 'px',
    top:  e.clientY + 'px',
    background: '#fff',
    border: '1px solid #ddd',
    borderRadius: '8px',
    boxShadow: '0 4px 18px rgba(0,0,0,.12)',
    padding: '6px',
    fontSize: '13px',
    minWidth: '240px'
  });

  const addItem = (label, onClick, opts={})=>{
    const it = document.createElement('div');
    it.textContent = label;
    it.style.padding = '8px 12px';
    it.style.cursor = opts.disabled ? 'not-allowed' : 'pointer';
    if (opts.danger) it.style.color = '#b91c1c';
    if (!opts.disabled) {
      it.addEventListener('mouseenter', ()=> it.style.background = '#f5f5f7');
      it.addEventListener('mouseleave', ()=> it.style.background = '');
      it.addEventListener('click', ()=>{
        // クリック時に閉じる → 実行
        closeMenu();
        try { onClick(); } catch(err){ console.error(err); }
      });
    }
    menu.appendChild(it);
  };

  // 項目：午前の休止ON/OFF
  addItem(cur ? '午前の「休止」を解除' : '午前を「休止」にする', ()=>{
    const sections = Object.assign({}, off[dayKey]?.sections||{}, { 0: !cur });
    setDayOff(currentMonday, dayKey, { sections }, { snapshot:true });
    render();
  });

  // 仕切り
  addItem('────────', ()=>{}, { disabled:true });

// 項目：このセクションを印刷（午前=インデックス0だけ残す）
addItem('このセクションを印刷（A4想定）', ()=>{
  printDayKeepSections(wrap, [0]);   // ★ wrap は buildDay() 冒頭で作った section 要素
});
addItem('────────', ()=>{}, {disabled:true});

// この日の「午前＋午後（手術室1）」を印刷
addItem('午前＋午後（手術室1）を印刷', ()=>{
  if (dayKey==='Tue' || dayKey==='Fri') {
    printDayKeepSections(wrap, [0,1]); // 午前(0)＋午後(手術室1=1)
  } else {
    alert('この曜日には午後（手術室1）がありません。');
  }
});


  // 画面に追加 & 外クリックで閉じる
  const closeMenu = (ev)=>{
    if (!ev || !menu.contains(ev.target)) {
      document.removeEventListener('mousedown', closeMenu, true);
      if (menu.parentNode) menu.parentNode.removeChild(menu);
    }
  };
  document.addEventListener('mousedown', closeMenu, true);
  document.body.appendChild(menu);
});
// ここまで置き換え


    const slotsAm = document.createElement('div'); slotsAm.className = 'slots';
slotsAm.dataset.day = (dayKey==='Wed'?'Wed':dayKey);  // ←追加
slotsAm.dataset.section = '0';                         // ←追加
    if (off[dayKey]?.sections?.[0]) { slotsAm.classList.add('section-off'); }
    let count = am.slots;
    if(dayKey==='Wed'){
      if(opt.half==='first'){ count = Math.floor(am.slots/2); }
      if(opt.half==='second'){ count = Math.ceil(am.slots/2); }
    }
    const dayId = (dayKey === 'Wed') ? 'Wed' : dayKey;
    const extraAm = getExtraTailSlots(currentMonday, dayId, 0);
    if (dayKey !== 'Wed' || opt.half === 'second' || opt.combined) count += extraAm;

    const baseCount = count;
    const layoutAm = getSectionLayout(currentMonday, (dayKey==='Wed'?'Wed':dayKey), 0, baseCount);
    for (let i = 0; i < layoutAm.total; i++){
      const time = getSlotTimeHHMMEx(am.start, currentMonday, (dayKey==='Wed'?'Wed':dayKey), 0, i);
      const slot = createSlot({ d: dateISO(dayDate), day: (dayKey==='Wed'?'Wed':dayKey), section: 0, idx: i }, time);
      if (layoutAm.isTemp(i)) slot.classList.add('temp-slot');
      const isTemp = slot.classList.contains('temp-slot');
      if (!isTemp) {
        if (dayIsOff) { slot.classList.add('off'); }
        const ca0 = off[dayKey]?.cutAfter?.[0];
        const cb0 = off[dayKey]?.cutBefore?.[0];
        if (ca0 && hhmmToMinutes(time) >= hhmmToMinutes(ca0)) slot.classList.add('off');
        if (cb0 && hhmmToMinutes(time) <= hhmmToMinutes(cb0)) slot.classList.add('off');
      }
      { const k = `${dateISO(dayDate)}|${(dayKey==='Wed'?'Wed':dayKey)}|0|${i}`;
        if (loadEmerg(currentMonday)[k]) { slot.classList.remove('off'); slot.classList.add('emergency-slot'); } }
      slotsAm.appendChild(slot);
    }
    wrap.appendChild(slotsAm);
    // 午後（火・金）
    if (dayKey === 'Tue' || dayKey === 'Fri'){
      for (let sidx = 1; sidx < sections.length; sidx++){
        const sec = sections[sidx];
        const st = document.createElement('div'); st.className = 'section-title';
        const t = document.createElement('span'); t.textContent = sec.title; st.appendChild(t);
        wrap.appendChild(st);

        // 右クリック：午後セクションの休止/印刷メニュー
        st.addEventListener('contextmenu', (e)=>{
          e.preventDefault();
          e.stopPropagation();

          const off = loadDayOff(currentMonday);
          const cur = off[dayKey]?.sections?.[sidx] === true;

          const menu = document.createElement('div');
          Object.assign(menu.style, {
            position: 'fixed',
            zIndex: '99999',
            left: e.clientX + 'px',
            top:  e.clientY + 'px',
            background: '#fff',
            border: '1px solid #ddd',
            borderRadius: '8px',
            boxShadow: '0 4px 18px rgba(0,0,0,.12)',
            padding: '6px',
            fontSize: '13px',
            minWidth: '240px'
          });

          const addItem = (label, onClick, opts={})=>{
            const it = document.createElement('div');
            it.textContent = label;
            it.style.padding = '8px 12px';
            it.style.cursor = opts.disabled ? 'not-allowed' : 'pointer';
            if (opts.danger) it.style.color = '#b91c1c';
            if (!opts.disabled) {
              it.addEventListener('mouseenter', ()=> it.style.background = '#f5f5f7');
              it.addEventListener('mouseleave', ()=> it.style.background = '');
              it.addEventListener('click', ()=>{
                closeMenu();
                try { onClick(); } catch(err){ console.error(err); }
              });
            }
            menu.appendChild(it);
          };

          // 午後の休止 ON/OFF
          addItem(cur ? '午後の「休止」を解除' : '午後を「休止」にする', ()=>{
            const sections = Object.assign({}, off[dayKey]?.sections||{}, { [sidx]: !cur });
            setDayOff(currentMonday, dayKey, { sections }, { snapshot:true });
            render();
          });

          addItem('────────', ()=>{}, { disabled:true });

          // セクション単体印刷
          addItem('このセクションを印刷（A4想定）', ()=>{
            printDayKeepSections(wrap, [sidx]);  // 午後(手術室1)=1 / 午後(手術室8)=2
          });

          const closeMenu = (ev)=>{
            if (!ev || !menu.contains(ev.target)) {
              document.removeEventListener('mousedown', closeMenu, true);
              if (menu.parentNode) menu.parentNode.removeChild(menu);
            }
          };
          document.addEventListener('mousedown', closeMenu, true);
          document.body.appendChild(menu);
        });

        const slotsEl = document.createElement('div'); slotsEl.className = 'slots';
        const offMap = loadDayOff(currentMonday);
        if (offMap[dayKey]?.sections?.[sidx]) { slotsEl.classList.add('section-off'); }
        const baseCount = sec.slots;
        const layout = getSectionLayout(currentMonday, dayKey, sidx, baseCount);
        for (let i = 0; i < layout.total; i++) {
          const time = getSlotTimeHHMMEx(sec.start, currentMonday, dayKey, sidx, i);
          const slot = createSlot({ d: dateISO(dayDate), day: dayKey, section: sidx, idx: i }, time);
          if (layout.isTemp(i)) slot.classList.add('temp-slot');
          const isTemp = slot.classList.contains('temp-slot');
          if (!isTemp) {
            const o = offMap[dayKey] || {};
            if (dayIsOff || (o.sections && o.sections[sidx])) { slot.classList.add('off'); }
            const caS = o.cutAfter && o.cutAfter[sidx];
            const cbS = o.cutBefore && o.cutBefore[sidx];
            if (caS && hhmmToMinutes(time) >= hhmmToMinutes(caS)) slot.classList.add('off');
            if (cbS && hhmmToMinutes(time) <= hhmmToMinutes(cbS)) slot.classList.add('off');
          }
          { const k = `${dateISO(dayDate)}|${dayKey}|${sidx}|${i}`;
            if (loadEmerg(currentMonday)[k]) { slot.classList.remove('off'); slot.classList.add('emergency-slot'); } }
          slotsEl.appendChild(slot);
        }
        wrap.appendChild(slotsEl);
      }
    }

    { const _off = loadDayOff(currentMonday); if(_off[dayKey]?.full === true){ wrap.classList.add('is-off'); } }
    return wrap;
  }

  function buildWeekend(){
    const dayKey = 'Weekend';
    const dayDate = addDays(currentMonday, 6);
    const wrap = document.createElement('section'); wrap.className = 'day weekend';
    const off = loadDayOff(currentMonday); const dayIsOff = !!(off['Weekend']?.day);

    const header = document.createElement('div'); header.className = 'day-header';
    const title = document.createElement('div'); title.className = 'day-header-date'; title.textContent = '（土/日）';
    const noteWrap = document.createElement('div'); noteWrap.className = 'day-note-inline';
    const noteInput = document.createElement('textarea'); noteInput.className = 'day-note-input'; noteInput.rows = 2; noteWrap.appendChild(noteInput);
    noteInput.value = getDayNote(currentMonday, dayKey);
    noteInput.addEventListener('focus', ()=>{ try{ undoStack.push(snapshotState()); redoStack.length=0; }catch(_){ }});
    noteInput.addEventListener('input', ()=>{ setDayNote(currentMonday, dayKey, noteInput.value); });
    header.appendChild(title); header.appendChild(noteWrap); wrap.appendChild(header);

    const secDef = CONFIG[dayKey][0];
    const st = document.createElement('div'); st.className = 'section-title thin';
    const addBtn = document.createElement('button'); addBtn.className = 'icon-btn'; addBtn.setAttribute('aria-label', '週末に臨時枠追加'); addBtn.textContent = '⊕'; addBtn.addEventListener('click', ()=>{ addExtraTailSlot(currentMonday, dayKey, 0, 1); render(); }); st.appendChild(addBtn);
    const subBtn = document.createElement('button'); subBtn.className = 'icon-btn'; subBtn.setAttribute('aria-label', '週末の臨時枠を1つ削除'); subBtn.textContent = '⊖'; subBtn.addEventListener('click', ()=>{ removeExtraTailSlot(currentMonday, dayKey, 0); render(); }); st.appendChild(subBtn);
    wrap.appendChild(st);

    const slotsEl = document.createElement('div'); slotsEl.className = 'slots';
    if (off['Weekend']?.sections?.[0]) { slotsEl.classList.add('section-off'); }
    const cnt = (secDef.slots|0) + getExtraTailSlots(currentMonday, dayKey, 0);
    for(let i=0;i<cnt;i++){
      const time = getSlotTimeHHMMEx(secDef.start, currentMonday, dayKey, 0, i);
      const slot = createSlot({ d: dateISO(dayDate), day: dayKey, section: 0, idx: i }, time);
      slot.classList.add('temp-slot');
      slotsEl.appendChild(slot);
    }
    wrap.appendChild(slotsEl);
    if (dayIsOff) { wrap.classList.add('is-off'); }
    return wrap;
  }

  function createSlot(meta, time){
    const el = slotTpl.content.firstElementChild.cloneNode(true);
    const timeEl = el.querySelector('.time'); timeEl.textContent = time ? String(time).replace(/^0/, '') : '';

    // 時刻ダブルクリック：個別時刻上書き / 解除
    timeEl.addEventListener('dblclick', (e)=>{
      if(e.shiftKey || e.altKey) return;
      e.preventDefault(); e.stopPropagation();

      const sec = Number(meta.section);
      const ii  = Number(meta.idx);
      const dayKey = meta.day;

      const base = (sec === 0 ? CONFIG[(dayKey==='Wed'?'Wed':dayKey)][0].start : CONFIG[dayKey][sec].start);
      const cur  = getSlotTimeHHMMEx(base, currentMonday, dayKey, sec, ii);

      const input = prompt('この枠の時刻（例 10:00 / 1000 / 950）', cur);
      if(input == null) return;
      const hhmm = normalizeTimeInput(input);
      if(!hhmm){ alert('形式が不正です。例：10:00 / 1000 / 0950 / 950'); return; }

      if(ii > 0){
        const prevHHMM = getSlotTimeHHMMEx(base, currentMonday, dayKey, sec, ii-1);
        if(hhmmToMinutes(hhmm) <= hhmmToMinutes(prevHHMM)){
          alert(`この枠は直前の枠（${prevHHMM}）より遅い時刻にしてください。`);
          return;
        }
      }
      setTimeOverride(currentMonday, dayKey, sec, ii, hhmm);
      render();
    });
    // Shift+DBL：この枠以降の上書きを解除
    timeEl.addEventListener('dblclick', (e)=>{
      if(!e.shiftKey) return;
      e.preventDefault(); e.stopPropagation();
      const { day, section, idx } = meta;
      clearTimeOverrideFrom(currentMonday, day, Number(section), Number(idx));
      render();
    });
    // Alt+DBL：セクション全クリア
    timeEl.addEventListener('dblclick', (e)=>{
      if(!e.altKey) return;
      e.preventDefault(); e.stopPropagation();
      const { day, section } = meta;
      clearTimeOverrideAll(currentMonday, day, Number(section));
      render();
    }, { capture:true });

    el.dataset.key = `${meta.d}|${meta.day}|${meta.section}|${meta.idx}`;

    // クリック選択
    el.addEventListener('click', (e)=>{
      if (isSlotLockedForEdit(el)) return;
      setActiveSlot(el);
      window.lastSelectedKey = el.dataset.key;
    });

    // 初期表示
    const leftEl = el.querySelector('.content-left');
    const surgEl = el.querySelector('.surgeon-tag');
    leftEl.textContent = '（空）';
    surgEl.textContent = '';
    el.classList.add('empty');

    // 右クリック：臨時/休止メニュー
    el.addEventListener('contextmenu', (e)=>{
      e.preventDefault();
      const dayKey  = meta.day; const section = meta.section; const idx = meta.idx;
      const baseCount = CONFIG[dayKey][section].slots;
      const layout = getSectionLayout(currentMonday, dayKey, section, baseCount);

      const menu = document.createElement('div');
      Object.assign(menu.style,{
        position:'fixed',zIndex:'99999',left:e.clientX+'px',top:e.clientY+'px',
        background:'#fff',border:'1px solid #ddd',borderRadius:'8px',
        boxShadow:'0 4px 18px rgba(0,0,0,.12)',padding:'6px',fontSize:'13px',minWidth:'200px'
      });
      function addItem(label, onClick){
        const it=document.createElement('div');
        it.textContent=label;
        it.style.padding='8px 12px';
        it.style.cursor='pointer';
        it.addEventListener('mouseenter', ()=> it.style.background='#f5f5f7');
        it.addEventListener('mouseleave', ()=> it.style.background='');
        it.addEventListener('click', ()=>{ onClick(); document.body.removeChild(menu); });
        menu.appendChild(it);
      }

      // 個別「臨時化（緊急）」
      { const key = el.dataset.key; const em  = loadEmerg(currentMonday); const isEm = !!em[key];
        addItem(isEm ? 'この枠の臨時化を解除' : 'この枠を臨時化（緊急）', ()=>{
          try{ undoStack.push(snapshotState()); redoStack.length=0; }catch(_){}
          setEmergency(currentMonday, key, !isEm); render();
        });
      }

      addItem('この枠の前に臨時枠を挿入', ()=>{
        try{ undoStack.push(snapshotState()); redoStack.length=0; }catch(_){}
        insertTempBefore(currentMonday, dayKey, section, idx); render();
      });
      addItem('この枠の後に臨時枠を挿入', ()=>{
        try{ undoStack.push(snapshotState()); redoStack.length=0; }catch(_){}
        insertTempAfter(currentMonday, dayKey, section, idx); render();
      });
      if (layout.isTemp(idx)){
        addItem('この臨時枠を削除', ()=>{
          try{ undoStack.push(snapshotState()); redoStack.length=0; }catch(_){}
          removeTempAt(currentMonday, dayKey, section, idx); render();
        });
      }

      // 休止（時刻基準）— 祝日は非表示
      const slotHHMM = normalizeTimeInput(timeEl.textContent.trim()) || timeEl.textContent.trim();
      const iso = meta.d;  const isHoliday = isHolidayISO(iso);
      if (!isHoliday) {
        addItem('────────', ()=>{});
        addItem('この枠「以後」を休止', ()=>{
          const off = loadDayOff(currentMonday);
          const cutAfter = Object.assign({}, off[dayKey]?.cutAfter || {});
          cutAfter[section] = String(slotHHMM);
          setDayOff(currentMonday, dayKey, { cutAfter }, { snapshot:true });
          render();
        });
        addItem('この枠「より前」を休止', ()=>{
          const off = loadDayOff(currentMonday);
          const cutBefore = Object.assign({}, off[dayKey]?.cutBefore || {});
          cutBefore[section] = String(slotHHMM);
          setDayOff(currentMonday, dayKey, { cutBefore }, { snapshot:true });
          render();
        });
        addItem('このセクションの「時刻休止」をクリア', ()=>{
          const off = loadDayOff(currentMonday);
          const cutAfter  = Object.assign({}, off[dayKey]?.cutAfter  || {});
          const cutBefore = Object.assign({}, off[dayKey]?.cutBefore || {});
          delete cutAfter[section];
          delete cutBefore[section];
          setDayOff(currentMonday, dayKey, { cutAfter, cutBefore }, { snapshot:true });
          render();
        });
      }

      function closeMenu(ev){
        if (!menu.contains(ev.target)) {
          document.removeEventListener('mousedown', closeMenu, true);
          if (menu.parentNode) menu.parentNode.remove();
        }
      }
      document.addEventListener('mousedown', closeMenu, true);
      document.body.appendChild(menu);
    }, {passive:false});

    return el;
  }

  // ===== ナビゲーション =====
  prevWeekBtn.addEventListener('click', ()=>{ currentMonday = addDays(currentMonday,-7); render(); });
  nextWeekBtn.addEventListener('click', ()=>{ currentMonday = addDays(currentMonday, 7); render(); });
  todayBtn.addEventListener('click', ()=>{ currentMonday = startOfWeek(new Date()); render(); });
  weekPicker.addEventListener('change', (e)=>{
    const v=e.target.value; if(!v) return;
    const [y,m,d]=v.split('-').map(Number);
    currentMonday = startOfWeek(new Date(y, m-1, d));
    render();
  });

  // 画面全体の印刷（フォーカス中はその日だけ）
  printBtn.addEventListener('click', ()=>{
    const day = document.querySelector('.day.is-focused')
             || (window.activeSlotEl && window.activeSlotEl.closest('.day'))
             || document.querySelector('.day');
    if(!day){ window.print(); return; }

    document.body.classList.add('printDay');
    try { window.print(); }
    finally { document.body.classList.remove('printDay'); }
  });

  // 選択セクションだけ印刷
  const printSelectionBtn = document.getElementById('printSelectionBtn');
  printSelectionBtn?.addEventListener('click', ()=>{
    const base = window.activeSlotEl || document.querySelector('.slot');
    if(!base){ alert('印刷するセクションが特定できません（枠を1つ選択してから押してください）'); return; }
    const slotsEl = base.closest('.slots');
    if(!slotsEl){ alert('この枠に対応するセクションが見つかりませんでした'); return; }
    printSection(slotsEl);
  });

  // ==== 設定ボタンとダイアログ ====
  const settingsBtn   = document.getElementById('settingsBtn');
  const settingsDlg   = document.getElementById('settings');
  const settingsForm  = document.getElementById('settingsForm');
  const settingsSave  = document.getElementById('settingsSaveBtn');

  // 開く：現在の値をテキストエリアに流し込む（1行=1候補）
  settingsBtn?.addEventListener('click', ()=>{
    document.getElementById('optIolTypes').value  = (appLists.iolTypes||[]).join('\n');
    document.getElementById('optProc1').value     = (appLists.proc1||[]).join('\n');
    document.getElementById('optProc2').value     = (appLists.proc2||[]).join('\n');
    document.getElementById('optProc3').value     = (appLists.proc3||[]).join('\n');
    document.getElementById('optSurgeons').value  = (appLists.surgeons||[]).join('\n');
    settingsDlg.showModal();
  });

  // 保存
  settingsForm?.addEventListener('close', ()=>{/* noop */});
  settingsSave?.addEventListener('click', (e)=>{
    e.preventDefault();
    const lines = (t)=> t.split('\n').map(s=>s.trim()).filter(Boolean);
    const next = {
      iolTypes:  lines(document.getElementById('optIolTypes').value),
      proc1:     lines(document.getElementById('optProc1').value),
      proc2:     lines(document.getElementById('optProc2').value),
      proc3:     lines(document.getElementById('optProc3').value),
      surgeons:  lines(document.getElementById('optSurgeons').value)
    };
    appLists = next;
    saveSettings(appLists);
    applyDatalists(appLists);
    settingsDlg.close();
  });

  // 初期反映：起動時と毎描画時に最新を反映
  applyDatalists(appLists);

  // 祝日データ キャッシュ（当年＋前後1年）
  (function ensureHolidayCaches(){
    const y = new Date().getFullYear();
    [y - 1, y, y + 1].forEach(ensureHolidayAuto);
  })();

  // スケジュール領域のダブルクリックで枠編集（時刻セルは除外）
  document.getElementById('schedule').addEventListener('dblclick', (e) => {
    const slot = e.target.closest('.slot');
    if (!slot) return;
    if (e.target.closest('.time')) return;
    if (typeof isSlotLockedForEdit === 'function' && isSlotLockedForEdit(slot)) return;
    const key = slot.dataset.key;
    if (key) openEditor([key]);
  }, true);

  // 初期適用＆描画
  applyLayout(layoutMode);

  // ウィンドウ幅変化で表示調整
  let _fitT = null;
  window.addEventListener('resize', () => {
    clearTimeout(_fitT);
    _fitT = setTimeout(() => autoFitContentLines(), 150);
  }, { passive: true });

  // 「編集」ボタン：選択複数→アクティブ→先頭
  editBtn?.addEventListener('click', () => {
    const candEls = [];

    if (typeof multiSelected !== 'undefined' && multiSelected.size){
      for (const k of multiSelected){
        const el = document.querySelector(`.slot[data-key="${k}"]`);
        if (el) candEls.push(el);
      }
    } else if (typeof activeSlotEl !== 'undefined' && activeSlotEl) {
      candEls.push(activeSlotEl);
    } else {
      const first = document.querySelector('.slot');
      if (first) candEls.push(first);
    }

    if (!candEls.length){
      alert('編集する枠が見つかりません');
      return;
    }

    const unlockedEls = candEls.filter(el => !isSlotLockedForEdit(el));
    if (!unlockedEls.length){
      alert('祝日/休止のため編集できる枠がありません');
      return;
    }

    const keys = unlockedEls.map(el => el.dataset.key);
    openEditor(keys);
  });

  // 保存済みデータで画面を塗り直し
  function paintSlotsFromStore(){
    const st = (typeof loadWeek === 'function') ? loadWeek(currentMonday) : {};
    document.querySelectorAll('.slot').forEach(el=>{
      const key  = el.dataset.key;
      const data = st[key];
      const left = el.querySelector('.content-left');
      const surg = el.querySelector('.surgeon-tag');

      el.classList.remove('empty','mergeHead','hiddenRow');
      el.style.gridRowEnd = '';

      if (data && !data.tail) {
        if (typeof fmtContent === 'function') {
          left.innerHTML = fmtContent(data);
        } else {
          left.textContent = [data.io, data.name, data.pid, data.age, data.eye, data.iolType, data.iolPower, data.proc1, data.proc2, data.proc3, data.note]
            .filter(Boolean).join(' / ');
        }
        surg.textContent = data.surgeon ? String(data.surgeon) : '';
        el.classList.remove('empty');
      } else if (data && data.tail) {
        left.textContent = '（空）';
        surg.textContent = '';
        el.classList.add('empty');
      } else {
        left.textContent = '（空）';
        surg.textContent = '';
        el.classList.add('empty');
      }
    });

    // 結合表示
    document.querySelectorAll('.slots').forEach(container=>{
      const children = Array.from(container.children);
      for (let i=0;i<children.length;i++){
        const el  = children[i];
        const key = el.dataset.key;
        const st  = loadWeek(currentMonday) || {};
        const d   = st[key];

        if (d && d.head && Number(d.span||1) > 1){
          const span = Number(d.span);
          el.classList.add('mergeHead');
          el.style.gridRowEnd = `span ${span}`;
          for (let k=1;k<span && i+k<children.length;k++){
            children[i+k].classList.add('hiddenRow');
          }
        }
        if (d && d.tail){
          el.classList.add('hiddenRow');
        }
      }
    });
  }

  /* ====================== 印刷ユーティリティ（個別・日単位） ====================== */

  /** 付け外し簡易ユーティリティ */
  const __PRINT_HIDDEN = new Set();
  function __hideForPrint(el){ if(!el) return; el.classList.add('hide-on-print'); __PRINT_HIDDEN.add(el); }
  function __clearPrintHides(){ __PRINT_HIDDEN.forEach(el=>el.classList.remove('hide-on-print')); __PRINT_HIDDEN.clear(); }

  /**
   * 指定の1日のラップ（buildDayが返す wrap）で、残したいセクションだけを印刷する。
   * keepIdxes は [0]（午前）/ [1]（午後1）/ [2]（午後8）/ [0,1]（午前+午後1）など。
   */
  function printDayKeepSections(dayWrap, keepIdxes){
    // 他の曜日は全部隠す
    document.querySelectorAll('.day').forEach(d => { if(d !== dayWrap) __hideForPrint(d); });
    // ヘッダー以外のUIも隠す（topbar等）
    __hideForPrint(document.querySelector('.topbar'));

    // dayWrap 内の .section-title と 直後の .slots をペア取り
    const kids = Array.from(dayWrap.children);
    const pairs = [];
    for (let i=0; i<kids.length; i++){
      if (kids[i].classList?.contains('section-title')){
        const t = kids[i];
        const s = kids[i+1] && kids[i+1].classList?.contains('slots') ? kids[i+1] : null;
        if (s) pairs.push([t,s]);
      }
    }
    // 不要なセクションを隠す
    pairs.forEach((pair, idx) => {
      if (!keepIdxes.includes(idx)) {
        __hideForPrint(pair[0]);
        __hideForPrint(pair[1]);
      }
    });

    try { window.print(); }
    finally { __clearPrintHides(); }
  }
  /* ====================== 印刷ユーティリティ（連結・セクション単体） ====================== */

  function printCombinedSections(elA, elB, titleText){
    const sheet = document.createElement('div');
    sheet.className = 'print-sheet';

    if (titleText) {
      const h = document.createElement('h2');
      h.textContent = titleText;
      h.style.margin = '0 0 8px';
      h.style.fontSize = '16px';
      sheet.appendChild(h);
    }

    const cloneA = elA.cloneNode(true);
    const cloneB = elB.cloneNode(true);
    sheet.appendChild(cloneA);
    sheet.appendChild(document.createElement('hr'));
    sheet.appendChild(cloneB);

    const style = document.createElement('style');
    style.textContent = `
@media print{
  body > *:not(.print-sheet){ display:none !important; }
  .print-sheet{
    display:block !important;
    width: 190mm;
    margin: 10mm auto;
    font-size: 12px;
  }
  .print-sheet .slot{ break-inside: avoid; }
}
@media screen{ .print-sheet{ display:none; } }`;
    document.head.appendChild(style);
    document.body.appendChild(sheet);

    const cleanup = ()=>{
      sheet.remove();
      style.remove();
      window.removeEventListener('afterprint', cleanup);
    };
    window.addEventListener('afterprint', cleanup);
    window.print();
  }

  /** dayKey と section index で探して印刷（必要に応じて利用） */
  function printTwoSectionsByKey(dayKey, idxA, idxB){
    const a = document.querySelector(`.slots[data-day="${dayKey}"][data-section="${idxA}"]`);
    const b = document.querySelector(`.slots[data-day="${dayKey}"][data-section="${idxB}"]`);
    if(!a || !b){ alert('対象セクションが見つかりません'); return; }
    const ttl = `${dayKey} 手術室1（午前＋午後）`;
    printCombinedSections(a, b, ttl);
  }

  // --- 選択印刷用：一時コンテナ（セクション単体印刷で使用） ---
  function ensurePrintSandbox(){
    let box = document.getElementById('printSandbox');
    if(!box){
      box = document.createElement('div');
      box.id = 'printSandbox';
      box.style.display = 'none';
      document.body.appendChild(box);
    }
    box.innerHTML = '';
    return box;
  }
  function clearPrintSandbox(){
    const box = document.getElementById('printSandbox');
    if(box) box.innerHTML = '';
  }
  function printSection(slotsEl){
    if(!slotsEl) return;
    const box = ensurePrintSandbox();

    const day = slotsEl.closest('.day');
    const titleEl = day?.querySelector('.day-header-date')?.cloneNode(true) || null;
    const sectionTitle = slotsEl.previousElementSibling?.classList?.contains('section-title')
      ? slotsEl.previousElementSibling.cloneNode(true) : null;

    const clone = slotsEl.cloneNode(true);

    const wrap = document.createElement('section');
    wrap.className = 'day';
    const head = document.createElement('div');
    head.className = 'day-header';
    if(titleEl) head.appendChild(titleEl);
    box.appendChild(wrap);
    wrap.appendChild(head);
    if(sectionTitle) wrap.appendChild(sectionTitle);
    wrap.appendChild(clone);

    document.body.classList.add('printRange');
    try { window.print(); }
    finally {
      document.body.classList.remove('printRange');
      clearPrintSandbox();
    }
  }

  // 日単位印刷（右クリックメニューから使用）
  function printDayElement(dayEl){
    if (!dayEl) return;
    const days = document.querySelectorAll('#schedule .day');
    days.forEach(d => { if (d !== dayEl) d.classList.add('hide-on-print'); });
    try { window.print(); }
    finally { days.forEach(d => d.classList.remove('hide-on-print')); }
  }

  /* ====================== 表示整形・ユーティリティ ====================== */

  function toHalfWidthKana(str){
    if (!str) return "";
    // ひらがな→カタカナ
    str = str.replace(/[\u3041-\u3096]/g, ch =>
      String.fromCharCode(ch.charCodeAt(0) + 0x60)
    );
    // 全角カナ→半角カナ（主要）
    const map = {'。':'｡','、':'､','・':'･','「':'｢','」':'｣','ー':'ｰ','゛':'ﾞ','゜':'ﾟ',
      'ァ':'ｧ','ア':'ｱ','ィ':'ｨ','イ':'ｲ','ゥ':'ｩ','ウ':'ｳ','ェ':'ｪ','エ':'ｴ','ォ':'ｫ','オ':'ｵ',
      'カ':'ｶ','ガ':'ｶﾞ','キ':'ｷ','ギ':'ｷﾞ','ク':'ｸ','グ':'ｸﾞ','ケ':'ｹ','ゲ':'ｹﾞ','コ':'ｺ','ゴ':'ｺﾞ',
      'サ':'ｻ','ザ':'ｻﾞ','シ':'ｼ','ジ':'ｼﾞ','ス':'ｽ','ズ':'ｽﾞ','セ':'ｾ','ゼ':'ｾﾞ','ソ':'ｿ','ゾ':'ｿﾞ',
      'タ':'ﾀ','ダ':'ﾀﾞ','チ':'ﾁ','ヂ':'ﾁﾞ','ッ':'ｯ','ツ':'ﾂ','ヅ':'ﾂﾞ','テ':'ﾃ','デ':'ﾃﾞ','ト':'ﾄ','ド':'ﾄﾞ',
      'ナ':'ﾅ','ニ':'ﾆ','ヌ':'ﾇ','ネ':'ﾈ','ノ':'ﾉ',
      'ハ':'ﾊ','バ':'ﾊﾞ','パ':'ﾊﾟ','ヒ':'ﾋ','ビ':'ﾋﾞ','ピ':'ﾋﾟ','フ':'ﾌ','ブ':'ﾌﾞ','プ':'ﾌﾟ','ヘ':'ﾍ','ベ':'ﾍﾞ','ペ':'ﾍﾟ','ホ':'ﾎ','ボ':'ﾎﾞ','ポ':'ﾎﾟ',
      'マ':'ﾏ','ミ':'ﾐ','ム':'ﾑ','メ':'ﾒ','モ':'ﾓ',
      'ャ':'ｬ','ヤ':'ﾔ','ュ':'ｭ','ユ':'ﾕ','ョ':'ｮ','ヨ':'ﾖ',
      'ラ':'ﾗ','リ':'ﾘ','ル':'ﾙ','レ':'ﾚ','ロ':'ﾛ',
      'ワ':'ﾜ','ヲ':'ｦ','ン':'ﾝ','ヴ':'ｳﾞ','ヵ':'ｶ','ヶ':'ｹ'
    };
    return str.replace(/[\u30A1-\u30FA\u30FC\u309B\u309C\u3001\u3002\u30FB\u300C\u300D]/g, ch => map[ch] || ch);
  }

  function flipEye(v){ if(!v) return v; if(v==='R') return 'L'; if(v==='L') return 'R'; if(v==='右') return '左'; if(v==='左') return '右'; return v; }

  function fmtContent(d){
    const parts=[];
    if(d.io) parts.push(d.io);
    if(d.name) parts.push(d.name);
    if(d.pid) parts.push('#'+String(d.pid).replace(/[！-～]/g, s => String.fromCharCode(s.charCodeAt(0)-0xFEE0)));
    if(d.age) parts.push(String(d.age).replace(/[！-～]/g, s => String.fromCharCode(s.charCodeAt(0)-0xFEE0)));
    if(d.eye){ parts.push(`<span class="eye-mark">${d.eye.trim()}</span>`); }
    if(d.iolType || d.iolPower){
      let p = (d.iolPower||'').toString().trim();
      if(p && !isNaN(Number(p))) p = Number(p).toFixed(1);
      parts.push(`${(d.iolType||'').trim()} ${p}`.trim());
    }
    if(d.proc1) parts.push(d.proc1);
    if(d.proc2) parts.push(d.proc2);
    if(d.proc3) parts.push(d.proc3);
    if(d.note)  parts.push('※'+d.note);
    return parts.join(' / ');
  }

  // 片仮名化（IME確定フックにも使用）
  function toKatakana(input){
    if (!input) return "";
    let s = input.normalize('NFKC');
    s = s.replace(/[\u3041-\u3096]/g, ch =>
      String.fromCharCode(ch.charCodeAt(0) + 0x60)
    );
    return s;
  }

  /* ====================== エディタ ====================== */

  function openEditor(keys){
    const editor = document.getElementById('editor');
    const f = document.getElementById('editorForm');
    const st = loadWeek(currentMonday);

    try{
      f.iolType?.setAttribute('list', 'iolTypes');
      f.proc1?.setAttribute('list', 'procList');
      f.proc2?.setAttribute('list', 'procList2');
      f.proc3?.setAttribute('list', 'procList3');
      f.surgeon?.setAttribute('list', 'surgeonsList');
      applyDatalists();
    }catch(_){}

    let firstKey = keys[0];
    const d0 = st[firstKey];
    if(d0 && d0.tail && d0.head){ firstKey = d0.head; }
    const first = st[firstKey] || {};
    const isHead = !!first.head;

    document.getElementById('editorTitle').textContent =
      keys.length>1 ? `選択枠の一括編集（${keys.length}件）` :
      (isHead ? `結合枠の編集（${first.span||1}枠）` : '枠の編集');

    f.name.value = first.name || '';
    f.pid.value  = first.pid  || '';
    f.age.value  = first.age  || '';
    f.eye.value  = first.eye  || '';
    f.io.value   = first.io   || '';
    f.iolType.value  = first.iolType  || '';
    f.iolPower.value = first.iolPower || '';
    f.proc1.value = first.proc1 || '';
    f.proc2.value = first.proc2 || '';
    f.proc3.value = first.proc3 || '';
    f.surgeon.value = first.surgeon || '';
    f.note.value  = first.note || '';
    f.mergeSlots.checked = isHead || keys.length>1;
    f.mergeSpan.value = isHead ? (first.span||1) : Math.max(1, keys.length);
    f.ga.checked = !!first.ga;

    // 氏名欄：IMEヒント＆確定時にカタカナ化
    (function(){
      const nameInput = f.name;
      if (!nameInput) return;
      nameInput.style.imeMode = 'active';
      nameInput.setAttribute('inputmode', 'katakana');

      let composing = false;
      nameInput.addEventListener('compositionstart', ()=> composing = true);
      nameInput.addEventListener('compositionend', ()=>{
        composing = false;
        const pos = nameInput.selectionStart;
        nameInput.value = toKatakana(nameInput.value);
        try { nameInput.setSelectionRange(pos, pos); } catch(_){}
      });
      nameInput.addEventListener('input', ()=>{
        if (composing) return;
        const pos = nameInput.selectionStart;
        nameInput.value = toKatakana(nameInput.value);
        try { nameInput.setSelectionRange(pos, pos); } catch(_){}
      });
      nameInput.addEventListener('blur', ()=>{
        nameInput.value = toKatakana(nameInput.value);
      });
    })();

    editor.returnValue='';
    editor.showModal();

    const onEnterToSave = (e) => {
      if (e.key !== 'Enter') return;
      if (e.isComposing) return;
      const tag = (e.target.tagName || '').toLowerCase();
      if (tag === 'textarea' && e.shiftKey) return; // Shift+Enter は改行
      e.preventDefault();
      try { document.activeElement?.blur(); } catch(_){}
      editor.returnValue = 'save';
      editor.close();
    };
    editor.addEventListener('keydown', onEnterToSave, true);

    editor.addEventListener('close', function handler(){
      editor.removeEventListener('close', handler);
      if(editor.returnValue==='save'){
        let nd = {
          name: toHalfWidthKana(f.name.value.trim()),
          pid:  f.pid.value.trim(),
          age:  f.age.value.trim(),
          eye:  f.eye.value,
          io:   f.io.value,
          iolType: f.iolType.value.trim(),
          iolPower: (()=>{
            const s=f.iolPower.value.trim();
            const v=Number(s.replace(',', '.'));
            return isFinite(v)? v.toFixed(1): s;
          })(),
          proc1: f.proc1.value.trim(),
          proc2: f.proc2.value.trim(),
          proc3: f.proc3.value.trim(),
          surgeon: f.surgeon.value.trim(),
          note:  f.note.value.trim(),
          ga: !!f.ga.checked
        };

        const merge = f.mergeSlots.checked;
        let span = Math.max(1, parseInt(f.mergeSpan.value||'1',10));
        const data = loadWeek(currentMonday);

        function parseKey(key){ const [d,day,section,idx] = key.split('|'); return {d,day,section:Number(section),idx:Number(idx)}; }
        function seqKeys(headKey, n){
          const {d,day,section,idx} = parseKey(headKey);
          const keys=[headKey];
          for(let i=1;i<n;i++){ keys.push(`${d}|${day}|${section}|${idx+i}`); }
          return keys;
        }

        if(first.head){
          const oldKeys = seqKeys(firstKey, first.span||1);
          for(const k of oldKeys){ if(data[k]) delete data[k]; }
        }

        if(merge && span>1){
          const keysToUse = keys.length>1 ? keys.slice().sort((a,b)=> a.localeCompare(b)) : seqKeys(firstKey, span);
          for(let i=1;i<keysToUse.length;i++){
            const d = data[keysToUse[i]];
            if(d && !d.tail){ alert('結合先に既存データがあります。先にクリアしてください。'); return; }
          }
          data[keysToUse[0]] = {...nd, head:true, span: keysToUse.length};
          for(let i=1;i<keysToUse.length;i++) data[keysToUse[i]] = { tail:true, head: keysToUse[0] };
        }else{
          if(Object.values(nd).every(v=>!v)){ delete data[firstKey]; }
          else{ data[firstKey] = nd; }
          if(keys.length>1){
            for(let i=1;i<keys.length;i++){
              if(Object.values(nd).every(v=>!v)) delete data[keys[i]];
              else data[keys[i]] = nd;
            }
          }
        }

        try{ undoStack.push(snapshotState()); redoStack.length=0; }catch(_){}
        saveWeek(currentMonday, data);
        render();
      }else if(editor.returnValue==='clear'){
        const data = loadWeek(currentMonday);
        const dHead = data[firstKey];
        if(dHead && dHead.head){
          const [d,day,section,idx] = firstKey.split('|');
          for(let i=0;i<(dHead.span||1);i++){
            const k = `${d}|${day}|${section}|${Number(idx)+i}`;
            delete data[k];
          }
        }else{
          delete data[firstKey];
        }
        try{ undoStack.push(snapshotState()); redoStack.length=0; }catch(_){}
        saveWeek(currentMonday, data);
        render();
      }
    }, {once:true});
  }

  /* ====================== クリップボード（コピー/貼付/切取）＆ショートカット ====================== */

  const appClipboard = { type:null, data:null };
  let lastCopySourceKey = null;

  function isOccupiedRecord(rec){
    if (!rec) return false;
    const f = ['head','tail','name','pid','age','eye','iolType','iolPower','proc1','proc2','proc3','surgeon','note','io','linkWith'];
    return f.some(k => !!rec[k]);
  }

  function copySlotOrMerge(){
    const el = activeSlotEl;
    if(!el){ alert('スロットを選択してください'); return; }
    const key = el.dataset.key;
    const st  = loadWeek(currentMonday);
    const d   = st[key];
    if(!d){ alert('コピー対象がありません'); return; }

    if (d.head && Number(d.span||1)>1){
      appClipboard.type = 'merge';
      appClipboard.data = { headKey:key, span:Number(d.span), headData:JSON.parse(JSON.stringify(d)) };
    }else{
      appClipboard.type = 'single';
      appClipboard.data = { key, data:JSON.parse(JSON.stringify(d)) };
      lastCopySourceKey = key;
    }
    el.animate([{opacity:1},{opacity:.5},{opacity:1}], {duration:160});
  }

  function pasteToActive({flip=false}={}){
    const clip = appClipboard;
    if(!clip?.type){ alert('コピーされていません'); return; }
    const tEl = activeSlotEl; if(!tEl){ alert('貼り付け先を選択してください'); return; }
    const tKey = tEl.dataset.key;
    const st = loadWeek(currentMonday);

    if(clip.type==='single'){
      if(isOccupiedRecord(st[tKey])){ alert('既にデータがあります'); return; }
      const data = JSON.parse(JSON.stringify(clip.data.data));
      if(flip && data.eye) data.eye = flipEye(data.eye);
      delete data.linkWith;
      st[tKey] = data;
      saveWeek(currentMonday, st); render();
      return;
    }

    if(clip.type==='merge'){
      const span = Number(clip.data.span||1); if(span<=1){ alert('結合情報が不正です'); return; }
      const day = tEl.closest('.day'); if(!day){ alert('貼り付け先が不正です'); return; }
      const list = Array.from(day.querySelectorAll('.slot'));
      const base = list.indexOf(tEl); if(base<0 || base+span-1>=list.length){ alert('貼り付け範囲が日はみ出します'); return; }
      const destKeys = []; for(let i=0;i<span;i++) destKeys.push(list[base+i].dataset.key);
      for(const k of destKeys){ if(isOccupiedRecord(st[k])){ alert('貼り付け先に既存データがあります'); return; } }
      const headData = JSON.parse(JSON.stringify(clip.data.headData||{}));
      delete headData.head; delete headData.tail; delete headData.span; delete headData.linkWith;
      const headKey = destKeys[0];
      st[headKey] = {...headData, head:true, span};
      for(let i=1;i<span;i++) st[destKeys[i]] = { tail:true, head:headKey };
      saveWeek(currentMonday, st); render();
      return;
    }
  }

  function cutActive(){
    const el = activeSlotEl; if(!el) return;
    copySlotOrMerge();
    const st = loadWeek(currentMonday);
    const key = el.dataset.key; const d=st[key]; if(!d) return;
    if(d.head){
      const [d0,day,section,idx] = key.split('|');
      for(let i=0;i<(d.span||1);i++){ delete st[`${d0}|${day}|${section}|${Number(idx)+i}`]; }
    } else {
      delete st[key];
    }
    saveWeek(currentMonday, st); render();
  }

  document.addEventListener('keydown',(e)=>{
    if(isTypingContext(e)) return;
    const k = e.key.toLowerCase();

    if((e.ctrlKey||e.metaKey) && k==='c'){ e.preventDefault(); copySlotOrMerge(); }
    if((e.ctrlKey||e.metaKey) && k==='v'){ e.preventDefault(); pasteToActive({flip:e.shiftKey}); }
    if((e.ctrlKey||e.metaKey) && k==='x'){ e.preventDefault(); cutActive(); }

    if(k==='delete' || k==='backspace'){
      e.preventDefault();
      const el = activeSlotEl; if(!el) return;
      const st = loadWeek(currentMonday);
      delete st[el.dataset.key];
      saveWeek(currentMonday, st); render();
    }

    if(k==='enter'){
      e.preventDefault();
      const el = activeSlotEl || document.querySelector('.slot');
      if(!el) return;
      if (isSlotLockedForEdit(el)) return;
      openEditor([el.dataset.key]);
    }
  }, true);



</script>
</body>
</html>
