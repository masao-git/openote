<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>週間手術スケジュール</title>
  <style>
    :root{--slot-h:28px;--gap:0}
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Hiragino Kaku Gothic ProN','Meiryo',sans-serif}
    .topbar{display:flex;flex-wrap:wrap;justify-content:space-between;gap:8px;padding:8px 12px;border-bottom:1px solid #ddd;position:sticky;top:0;background:#fff;z-index:5}
    .group{display:flex;gap:8px;align-items:center}
    button{padding:6px 10px;border:1px solid #bbb;background:#fff;border-radius:6px;cursor:pointer}
    button.primary{background:#2563eb;color:#fff;border-color:#1e40af}
    .icon-btn{background:transparent!important;border:none!important;padding:0!important;margin-left:6px;font-size:14px;cursor:pointer}
    .icon-btn:hover{opacity:.8}
    #schedule{padding:12px;display:grid;grid-template-columns:1fr 1fr;column-gap:16px;row-gap:0}
    .column{display:flex;flex-direction:column;row-gap:16px}
    .day{border:2px solid #000;background:#fff;position:relative}
    .day-header{display:flex;align-items:center;justify-content:space-between;gap:12px;min-height:32px;padding:4px 8px;background:#f7f7f7;border-bottom:1px solid #ddd;font-weight:700}
    .day-header-date{white-space:nowrap}
    .day-note-inline{flex:1 1 auto;display:flex;justify-content:flex-end;min-width:0}
    .day-note-input{width:100%;min-width:0;height:auto;line-height:1.4;padding:6px 8px;border:1px solid #d1d5db;border-radius:6px;font-size:13px;outline:none;white-space:pre-wrap;word-break:break-word;overflow:auto;resize:none;min-height:2.8em;max-height:2.8em}
    .day-note-input:focus{border-color:#2563eb;box-shadow:0 0 0 1px rgba(37,99,235,.2)}
    .section-title{margin:0;padding:2px 6px;font-size:12px;font-weight:600;border-top:1px solid #999;border-bottom:1px solid #999;background:#f8f8f8;display:flex;align-items:center}
.slots{
  display:grid;
  /* ★ 最低高さは --slot-h、必要なら中身に合わせて伸びる */
  grid-auto-rows:minmax(var(--slot-h), auto);
  row-gap:var(--gap);
  padding:0;
  position:relative;
}
    .slot{border-top:1px solid #d0d5dd;padding:3px 5px;background:#fff;display:grid;grid-template-columns:40px 1fr;gap:6px;align-items:start;cursor:grab;position:relative}
    .slot.empty{opacity:.8;background:#fbfbfb}
	    /* ★ RLセット用：左端の細い縦バー */
    .slot.rl-set-slot::before{
      content:"";
      position:absolute;
      left:1px;              /* 枠の一番左に寄せる */
      top:0;                 /* デフォルトは上下いっぱいに伸ばす */
      bottom:0;
      width:3px;             /* 細いバー */
      border-radius:0;       /* ← 角の丸みをなくす */
      background:#94a3b8;    /* ほんのりグレー寄りの色（他とケンカしにくい） */
      opacity:0.9;
      pointer-events:none;   /* クリック判定には干渉しない */
    }
    /* セットの一番上だけ、上側に少し隙間を空ける */
    .slot.rl-set-top::before{
      border-top-left-radius:999px;
      border-top-right-radius:999px;
      top:4px;               /* 上に 4px の余白 → 上の枠とは切れる */
    }
    /* セットの一番下だけ、下側に少し隙間を空ける */
    .slot.rl-set-bottom::before{
      border-bottom-left-radius:999px;
      border-bottom-right-radius:999px;
      bottom:4px;            /* 下に 4px の余白 → 下の枠とは切れる */
    }

    .time{font-weight:700;text-align:left;padding:0 4px 0 2px;user-select:none;cursor:pointer}
    .content{display:flex;align-items:center;justify-content:space-between;gap:6px;font-size:13px}
    .content-left{flex:1 1 auto;min-width:0;padding-right:52px}
    .surgeon-tag{position:absolute;top:4px;right:6px;white-space:nowrap;font-weight:600;padding:2px 6px;border:1px solid #1e3a8a;border-radius:10px;font-size:12px}
    .slot.empty .surgeon-tag{display:none}

    /* レイアウト切替用 */
    body.fiveCols #schedule{grid-template-columns:repeat(5,minmax(var(--col-min-5,300px),1fr));gap:16px;align-items:start;overflow-x:auto;-webkit-overflow-scrolling:touch}
    body.fiveCols #leftCol, body.fiveCols #rightCol{display:contents}
    body.fourCols #schedule{grid-template-columns:repeat(4,minmax(var(--col-min-4,360px),1fr));gap:16px;align-items:start;overflow-x:auto;-webkit-overflow-scrolling:touch}
    body.fourCols #leftCol, body.fourCols #rightCol{display:contents}
    body.fourCols .dayStack{display:flex;flex-direction:column;gap:16px;min-width:0;width:100%}
    body.fiveCols .dayStack{display:flex;flex-direction:column;gap:16px;min-width:0;width:100%}

    /* 週末 臨時手術（まとめセクション） */
    .weekend{ border:2px dashed #cbd5e1; background:#fafafa; position:relative; }
    .weekend .day-header{ background:#f3f4f6; border-bottom:1px dashed #cbd5e1; }
    .weekend .section-title{ background:#f8fafc; justify-content:flex-start; }

    /* 休止日（終日 or セクション）見た目 */
    .day.is-off { background:#f5f5f5; opacity:.9; }
.day.is-off .slot:not(.temp-slot):not(.emergency-slot),
.slots.section-off .slot:not(.temp-slot):not(.emergency-slot) {
      pointer-events: none;
      background: #eee !important;
      opacity: .8;
    }
    .day.is-off .slots,
    .slots.section-off { filter: grayscale(1) contrast(.9); }

/* 緊急が1つでもあればフィルタ解除（:has は対応ブラウザ用） */
.day.is-off:has(.emergency-slot) .slots,
.slots.section-off:has(.emergency-slot) {filter: none !important;}

/* :has 非対応ブラウザ用フォールバック（JSで .has-emergency を付ける） */
.day.is-off.has-emergency .slots,
.slots.section-off.has-emergency {filter: none !important;}

    /* 臨時（temp）は常に赤＆操作可 */
    .temp-slot{ background: rgba(255, 100, 100, .15) !important; }
    .day.is-off .temp-slot,
    .slots.section-off .temp-slot {
      filter: none; pointer-events: auto; opacity: 1;
    }

/* ▼ この「off」の定義が強いので、緊急・臨時は除外しておく */
.slot.off:not(.emergency-slot):not(.temp-slot){
  background:#bbb !important; opacity:1; pointer-events:auto;}

/* ホバーの薄い青（off・緊急・臨時は塗り替えない） */
.slot:hover:not(.off):not(.emergency-slot):not(.temp-slot) {
  background: rgba(37, 99, 235, 0.08) !important;
}

    /* 祝日見た目 */
    .day.is-holiday .day-header{ background: #fff5f5; }
    .day.is-holiday .day-header-date::after{
      content: " 祝"; display:inline-block; margin-left:.5em; padding:0 .4em; font-size:.85em; color:#b91c1c; border:1px solid #fca5a5; border-radius:6px; background:#ffe4e6;
    }
    /* 祝日でも右クリックを通す保険 */
    .day.is-off .slot, .day.is-holiday .slot { pointer-events:auto; }
    .day.is-off .slots, .day.is-holiday .slots { pointer-events:auto; }

    /* 祝日の枠背景は #bbb（臨時は除外） */
    .day.is-holiday .slot:not(.temp-slot):not(.emergency-slot) { background:#bbb !important; opacity:1 !important; }

/* 祝日でも右クリックを通す（最優先で許可） */
.day.is-holiday .slot,
.day.is-holiday .slot.off,
.day.is-holiday .slots {
  pointer-events: auto !important;
}

/* 緊急（祝日・休止でも最優先で赤＆操作可）— Aより後ろに置く */
.day.is-off  .slot.emergency-slot,
.day.is-holiday .slot.emergency-slot,
.slots.section-off .slot.emergency-slot {
  background: rgba(255,100,100,.15) !important;
  opacity: 1 !important;
  filter: none !important;
  pointer-events: auto !important;
}


/* tail行は DOM は残して非表示（高さ0） */
.hiddenRow { display:none !important; }

/* ブラウザ既定の黒いフォーカス枠を無効化（青枠は .focused で付ける） */
.slot:focus,
.slot:focus-visible {
  outline: none !important;
}

/* クリックで選択された枠の見た目（画面表示専用） */
@media screen {
  .slot.focused{
    outline: 2px solid #2563eb;
    outline-offset: -2px;
    background: rgba(37,99,235,0.06);
  }
}

/* スロット境界から下への“にじみ”を止める */
.slot { overflow: hidden; }

.content { overflow: hidden; }
 .content-left{
  line-height: 1.2;
  overflow: hidden;                 /* はみ出し非表示（共通） */
  display: block;                   /* 高さ計算が安定 */
  max-height: calc(var(--slot-h) - 6px); /* 枠高(28px) - 上下padding(3+3) */
  word-break: break-word;
  white-space: normal;
}

/* 週表示・スロット左側テキスト */
.slot .content-left{
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 2;       /* 2行でカット */
  max-height: calc(2 * 1.2em + 2px); /* 2行分 + α（誤差吸収用の余裕） */
  font-size: 13px;             /* 週表示では 13px 固定 */
}
/* 共通：列・セパレーター */
.slot .content-left .slot-col{
  display: inline-block;
  vertical-align: top;
}

.slot .content-left .slot-sep{
  display: inline-block;
  padding: 0 px;   /* 「｜」前後の余白 */
}
 
  /* 入・外・当日（1文字幅＋中央寄せ） */
  .slot .content-left .slot-col-io{
    min-width: 1ch;
    text-align: center;
  }
 
  /* 氏名（半角カナ11文字＋中央寄せ） */
  .slot .content-left .slot-col-name{
    min-width: 11.5ch;
    text-align: center;
  }
 
  /* ID（10桁＋中央寄せ） */
  .slot .content-left .slot-col-pid{
    min-width: 10ch;
    text-align: center;
  }
 
  /* 眼 R/L/B（1文字＋中央寄せ） */
  .slot .content-left .slot-col-eye{
    min-width: 1.5ch;
    text-align: center;
  }
 
  /* 年齢（半角3桁＋中央寄せ） */
  .slot .content-left .slot-col-age{
    min-width: 3ch;
    text-align: center;
  }
 
  /* IOL種類・度数（ぎりぎり入る＋中央寄せ） */
  .slot .content-left .slot-col-iol{
    min-width: 7.7ch;   /* 足りなければここを少し増やす */
    text-align: center;
  }
 
  /* 術式1〜2（左寄せ） */
 .slot .content-left .slot-col-proc1,
 .slot .content-left .slot-col-proc2{
    min-width: 6ch;
    text-align: left;
  }
 
  /* 備考：末尾なので自由 */
  .slot .content-left .slot-col-note{
    padding-left: 4px;
  }

/* 眼の赤強調（お好みで） */
.eye-mark{
  color: #b91c1c;
  font-weight: bold;
}

.proc2-badge {
  background: #bfdbfe;   /* 色は現状維持 */
  color: #1e3a8a;
  padding: 0 4px;        /* 上下0で高さを抑え、横も少しだけ細く */
  border-radius: 0;      /* 角はそのまま直角 */
  font-size: 0.9em;      /* 少しだけ小さく（13pxベースなら約11.7px） */
  font-weight: 700;
  display: inline-block;
  line-height: 1.0;      /* 行の高さを詰めて“背を低く” */
}

/* ② 結合枠（head）は行数制限を解除して自由に表示 */
.slot.mergeHead .content-left{
  /* 行数制限＆高さ制限を解除 */
  -webkit-line-clamp: unset;
  max-height: none;
  overflow: visible;
  /* -webkit-box だと行数制御前提になるので通常ブロックに戻す */
  display: block;

  /* 好みで：結合枠内は通常サイズに戻す（任意） */
  font-size: 13px;
  line-height: 1.3;
}

/* 結合枠(head)の箱側で中身をクリップしない */
.slot.mergeHead{ overflow: visible; }

 /* 通常枠（データあり）は色を変えない（感染症あり/なしだけで色をつける） */
 .slot:not(.empty){
   background: transparent;
 }


/* 時間バッジ（結合バッジを横長ピルに統一） */
.merge-badge,
.span-badge,
.mergeSpan-badge,
.badge-merge{
  display: inline-block !important;
  writing-mode: horizontal-tb !important; /* 横書きに強制 */
  white-space: nowrap !important;         /* 改行しない */
  width: auto !important;
  height: auto !important;

  font-size: 11px;
  line-height: 1;
  padding: 1px 6px;
  border-radius: 9999px;

  /* 見た目は控えめなグレー系ピル（必要なら調整OK） */
  border: 1px solid #9ca3af;
  background: #f3f4f6;
  color: #111827;

  /* GA/感染との間隔（必要なら微調整） */
  margin-bottom: 4px;
}

/* バッジを縦積みしたい場合に効かせる（任意） */
.ga-badge,
.infection-badge,
.merge-badge,
.span-badge,
.mergeSpan-badge,
.badge-merge{
  display: inline-block;
}

/* 全麻バッジ：横長ピル（“4枠”と同じサイズ感） */
.ga-badge{
  display: inline-block;       /* 1文字ずつ縦崩れ防止 */
  writing-mode: horizontal-tb; /* 念のため */
  white-space: nowrap;         /* 改行なし */

  font-size: 11px;
  line-height: 1;
  padding: 1px 6px;
  border-radius: 9999px;
  border: 1px solid #f59e0b;
  background: #fef3c7;
  color: #92400e;

  pointer-events: none;
  user-select: none;

  margin-top: auto; /* 結合バッジの下側に寄せる用途（必要なら残す） */
}

/* 局麻バッジ（全麻と同じ形・大きさで色だけ緑） */
.local-badge{
  display: inline-block;        /* 1文字ずつ縦崩れ防止 */
  writing-mode: horizontal-tb;  /* ★強制的に横書きにする */
  white-space: nowrap;          /* 改行なし */

  font-size: 11px;
  line-height: 1;
  padding: 1px 6px;
  border-radius: 9999px;

  border: 1px solid #22c55e;    /* 緑系の枠線 */
  background: #dcfce7;          /* 薄い緑 */
  color: #166534;               /* 濃い緑 */

  pointer-events: none;
  user-select: none;

  margin-top: auto;             /* 所要時間バッジの下側に寄せる（ga-badge と同じ） */
}

/* 感染症バッジ：共通デザイン（全麻バッジと同系色のピル） */
.infection-badge{
  writing-mode: horizontal-tb;
  white-space: nowrap;

  font-size: 11px;
  line-height: 1;
  padding: 0px 6px;              /* コメント行の高さをあまり増やさないように縦方向を薄く */
  border-radius: 9999px;
  border: 1px solid #a855f7;     /* 紫系の枠線 */
  background: #f5f3ff;           /* 薄い紫の背景 */
  color: #6b21a8;                /* 濃いめの紫文字 */

  pointer-events: none;
  user-select: none;

  margin-left: 0;
  margin-top: 0;
  vertical-align: baseline;
}

/* 画面（screen）では感染バッジを非表示にする */
@media screen {
  .infection-badge {
    display: none !important;
  }
}

/* 印刷時だけ感染バッジ風ピルを描画する */
@media print {
  /* JS で生成した span.infection-badge 自体は印刷では使わない */
  .infection-badge {
    display: none !important;
  }

  /* ① コメント（note）があるスロット：備考の末尾に付ける */
  .slot.infection-slot .slot-col-note::after,

  /* ② コメントが無いスロット：左側テキスト(content-left)の末尾に付ける */
  .slot.infection-slot:not(:has(.slot-col-note)) .content-left::after {
    content: ' 感染';
    display: inline-block;
    writing-mode: horizontal-tb;
    white-space: nowrap;

    font-size: 9px;
    line-height: 1;
    padding: 0px 6px;
    border-radius: 9999px;
    border: 1px solid #a855f7;   /* 紫系の枠線 */
    background: #f5f3ff;         /* 薄い紫の背景 */
    color: #6b21a8;              /* 濃いめの紫文字 */

    vertical-align: baseline;
    margin-left: 4px;            /* 手前の文字と少し間隔を空ける */
  }
}

/* 祝日/休止を優先したいなら何もしない（←このまま） */
/* もし祝日/休止でも黄色にしたいなら、下を有効化：
.day.is-holiday .slot.ga-slot:not(.temp-slot):not(.emergency-slot),
.slot.off.ga-slot {
  background: #fff9c4 !important;
}
*/

/* --- 感染症あり：紫 --- */
.slot.infection-slot {
  background: rgba(180, 100, 255, 0.18) !important;
}

/* --- 感染症なし：従来の“薄い緑”をここに移す --- */
.slot.noninfection-slot {
  /* ここにさっきの .slot:not(.empty) の色を入れる */
  background: #e8f7ec !important;  /* ← 元の薄い緑の色 */
}

/* --- GA(全麻) は薄い黄色 --- */
.slot.ga-slot {
  background: #fff9c4 !important;
}

/* ★ 感染症あり + 全麻 のときも GA の黄色を優先 */
.slot.ga-slot.infection-slot {
  background: #fff9c4 !important;
}

/* 感染症・全麻を縦並びにする */
#editorForm label[for="infection"],
#editorForm label[for="ga"] {
  grid-column: 1 / -1;   /* 2列をまたいで配置 */
}


/* === 日フォーカス表示（方式A） ===================== */
body.dayFocus { --slot-h: 44px; }              /* スロットを少し背高に */
body.dayFocus #schedule { grid-template-columns: 1fr; }
body.dayFocus .day { display:none; }           /* 他日は隠す */
body.dayFocus .day[data-focus="true"] {display:block;}

/* フォーカス時の文字サイズを少しアップ（お好みで） */
body.dayFocus .time { font-size: 18px; }
body.dayFocus .content-left { font-size: 20px; line-height: 1.3; }

/* フォーカス時：結合枠も同じフォントサイズにする */
body.dayFocus .slot.mergeHead .content-left {
  font-size: 20px !important;
  line-height: 1.3;
}


/* フォーカス時の戻るフローティングボタン */
#focusBackBtn {
  position: fixed;
  top: 56px;            /* トップバーの下あたりに */
  right: 16px;
  z-index: 1000;
  padding: 6px 10px;
  border: 1px solid #bbb;
  background: #fff;
  border-radius: 6px;
  cursor: pointer;
  box-shadow: 0 2px 10px rgba(0,0,0,.08);
}

/* --- フォーカス時に隠すもの --- */
body.dayFocus #mode2col,
body.dayFocus #mode4col,
body.dayFocus #mode5col,
body.dayFocus .topbar [aria-label="レイアウト切替"] {
  display: none !important;
}

/* --- 戻るボタンの配置 --- */
/* 通常は非表示、フォーカス時にトップバー右端へ表示 */
#focusBackBtn {
  display: none;
  padding: 6px 10px;
  border: 1px solid #bbb;
  background: #fff;
  border-radius: 6px;
  cursor: pointer;
  box-shadow: 0 2px 6px rgba(0,0,0,0.08);
  font-size: 0.9rem;
  align-self: center; /* トップバー内で縦位置をそろえる */
  margin-left: 8px;   /* 隣のボタンとの間隔 */
}
body.dayFocus #focusBackBtn {
  display: inline-flex;
  position: static;   /* ← fixedを解除して1行内に */
}

/* --- フォーカス時に残すもの（ピッカー等） --- */
body.dayFocus #prevWeek,
body.dayFocus #nextWeek,
body.dayFocus #todayBtn,
body.dayFocus #weekPicker {
  display: inline-flex !important;
}

/* ===== 統一版：印刷レイアウト（整理済み） ===== */
@media print {
  @page { size: A4 portrait; margin: 10mm; }

  /* 画面UIは隠す */
  .topbar,
  .ctx-menu {
    display: none !important;
  }

  /* 週間でもフォーカスでも：A4いっぱい・1列化 */
  #schedule {
    grid-template-columns: 1fr !important;
    column-gap: 0 !important;
    width: 100% !important;
    margin: 0 !important;
    padding: 0 !important;
  }
  #schedule .column { display: contents !important; }

  /* 行高デフォルト（通常印刷側） */
  :root { --print-slot-h: 8mm; }
  .slots { grid-auto-rows: var(--print-slot-h) !important; }

  /* 基本は途中で切らない（2ページ印刷側であとから上書き） */
  .day,
  .slots,
  .slot {
    break-inside: avoid;
    page-break-inside: avoid;
  }

  /* 右クリック選択印刷で使うフラグ */
  .hide-on-print { display: none !important; }

  /* === 週表示の通常印刷：月〜金だけを1日1ページずつ === */

  /* 土日を完全に印刷対象から除外 */
  body:not(.printWeek2p):not(.dayFocus) #schedule .day[data-day-key="Sat"],
  body:not(.printWeek2p):not(.dayFocus) #schedule .day[data-day-key="Sun"] {
    display: none !important;
  }

  /* 月〜金は必ず1日1ページ */
  body:not(.printWeek2p):not(.dayFocus) #schedule .day {
    break-after: page;
    page-break-after: always;
  }

  /* 臨時/緊急枠の数に応じた自動圧縮（通常印刷のみ） */
  /* 1〜2枠追加 → ちょっとだけ圧縮 */
  body:not(.printWeek2p):not(.dayFocus) #schedule .day.print-tight {
    --print-slot-h: 7.6mm;   /* 8mm → 7.6mm */
  }

  /* 3枠以上追加 → もう一段圧縮 */
  body:not(.printWeek2p):not(.dayFocus) #schedule .day.print-tighter {
    --print-slot-h: 7.2mm;   /* 8mm → 7.2mm */
  }

  /* === 平日2ページ印刷モード専用の調整 === */

  /* 1行の高さをかなり詰める（通常8mm → 4.8mm） */
  body.printWeek2p {
    --print-slot-h: 4.8mm;
  }

  /* スケジュール全体の縦の隙間をほぼゼロに */
  body.printWeek2p #schedule {
    row-gap: 0 !important;
  }
  body.printWeek2p .column {
    row-gap: 0 !important;
  }
  body.printWeek2p .dayStack {
    gap: 0 !important;
  }

  /* 各曜日の上下余白も詰める */
  body.printWeek2p .day {
    margin-top: 0 !important;
    margin-bottom: 0 !important;
  }

  /* 2ページモードでは枠は途中で切れてOK（ページ優先） */
  body.printWeek2p .day,
  body.printWeek2p .slots,
  body.printWeek2p .slot {
    break-inside: auto !important;
    page-break-inside: auto !important;
  }

/* 2ページ印刷用のフォント・見た目調整 */
body.printWeek2p .content-left {
  font-size: 13px !important;
  display: flex;
  align-items: center;   /* 左側のテキスト・バッジ全体を縦中央寄せ */
  line-height: 1.1;
}

/* time は縦方向に中央寄せ＋バッジは下にぶら下げる */
body.printWeek2p .time {
  font-size: 11px !important;
  display: flex;
  flex-direction: column;        /* 上:時刻 / 下:バッジ に縦積み */
  justify-content: center;       /* スロット高さの中央に寄せる */
  align-items: flex-start;       /* 左揃えのまま */
  line-height: 1.1;
}

  /* 2ページ印刷時の術者バッジ：少し小さめ＆縦中央寄せ */
  body.printWeek2p .surgeon-tag {
    font-size: 9px !important;      /* ちょい小さくして下が切れないように */
    padding: 0 4px !important;
    line-height: 1.2 !important;    /* バッジ内の文字も中央寄せ気味に */
    top: 50% !important;            /* スロットの縦中央に配置 */
    transform: translateY(-50%) !important;
  }
  /* 結合枠(head)の術者バッジだけは「全体の中央」ではなく head の上辺に揃える */
body.printWeek2p .slot.mergeHead .surgeon-tag {
  top: 2px !important;              /* 通常枠と同じくらいの位置に */
  transform: none !important;       /* 中央寄せを解除 */
}
  
  /* 午前／午後帯を薄く低く */
  body.printWeek2p .section-title {
    font-size: 9px !important;
    line-height: 1.0 !important;
    padding-top: 0 !important;
    padding-bottom: 0 !important;
    height: 10px !important;
    min-height: 10px !important;
    margin-top: 0 !important;
    margin-bottom: 0 !important;
  }

  /* スロット全体を縦方向センター揃え（結合headだけ上寄せ） */
  body.printWeek2p .slot {
    align-items: center !important;
  }
  body.printWeek2p .slot.mergeHead {
    align-items: flex-start !important;
  }
}

/* === フォーカス表示専用：印刷レイアウト === */
@media print {

  /* --- フォーカス印刷：時刻のフォント --- */
  body.dayFocus .time {
    font-size: 16px;
  }

  /* --- フォーカス印刷：slots を block にする（ただし hide-on-print は尊重） --- */
  body.dayFocus #schedule .slots {
    display: block;   /* !important を外して、hide-on-print の方を優先させる */
  }

  /* --- スロット本体は grid のまま（時刻＋内容を横並び維持） --- */
  body.dayFocus .slot {
    display: grid !important;
    grid-template-columns: 60px 1fr;   /* 時刻 60px + 内容エリア */
    width: 100%;
    align-items: flex-start;
  }

  /* --- 結合枠 tail（hiddenRow）は完全に非表示 --- */
  body.dayFocus .slot.hiddenRow {
    display: none !important;
  }

  /* --- 時刻部分：固定幅で左側に配置 --- */
  body.dayFocus .slot .time {
    display: inline-block;
    width: 40px;
    vertical-align: top;
  }

  /* --- 内容部分：時刻の右に並べる（折り返しも自然に） --- */
  body.dayFocus .slot .content {
    display: inline-block;
    width: calc(100% - 40px);
    vertical-align: top;
    align-items: flex-start;
  }

  /* --- 内容テキスト：普通のブロックに戻して自然な折り返しに --- */
  body.dayFocus .content-left {
    font-size: 18px;
    line-height: 1.3;
    display: block;
    white-space: normal !important;
    overflow: visible !important;
  }

  /* --- 結合枠 head のテキストも通常と同じ扱いに統一 --- */
  body.dayFocus .slot.mergeHead .content-left {
    font-size: 18px !important;
    line-height: 1.3 !important;
  }

  /* --- フォーカス印刷：途中で切れて OK（slot 単位で改ページ許可） --- */
  body.dayFocus .day,
  body.dayFocus .slots,
  body.dayFocus .slot {
    break-inside: auto !important;
    page-break-inside: auto !important;
  }

  /* --- フォーカス印刷：空スロット (.slot.empty) は非表示 --- */
  body.dayFocus .slot.empty {
    display: none !important;
  }

}





/* 週ピッカー右の曜日バッジ */
#weekPickerWeekday {
  margin-left: .5rem;
  font-size: 0.95em;
  opacity: .8;
}
#weekPickerWeekday { display: none; }
body.dayFocus #weekPickerWeekday { display: inline; }

    /* ツールバーに入ったときの見た目（重なり回避） */
    #helpBtn.docked{
      position: static;
      width: 32px; height: 32px; line-height: 32px;
      border-radius: 50%;
      box-shadow: none;
      margin-left: 8px;
      vertical-align: middle;
    }
/* ===== FINAL OVERRIDE: 緊急はどこでも赤 & 操作可（必ずCSSの最下部に置く） ===== */
:where(.day.is-off, .day.is-holiday, .slots.section-off) .slot.emergency-slot,
.slot.off.emergency-slot,
.slot.emergency-slot {
  background: rgba(255,100,100,.15) !important;
  opacity: 1 !important;
  filter: none !important;
  pointer-events: auto !important;
}
/* 緊急/臨時に .focused が付いたら必ず青枠を表示（※画面表示専用） */
@media screen {
  .slot.emergency-slot.focused,
  .slot.temp-slot.focused {
    outline: 2px solid #2563eb;
    outline-offset: -2px;
  }
}

/* ★ スナップ統一：ブラウザの滑らかスクロールを無効化 */
html, body, #schedule, .day, .day .slots {
  scroll-behavior: auto;
}

.eye-mark{
  color: #b91c1c;      /* 赤 */
  font-weight: bold;
}

/* 結合チェックボックス＆ラベルを非表示にしたい場合（任意） */
#mergeSlots,
label[for="mergeSlots"] {
  display: none;
}

/* 連続選択されているスロット自体の見た目（薄い背景だけにする例） */
.slot.multiSelected {
  background-color: rgba(0, 0, 255, 0.04);  /* ほんのり青系でもグレーでも */
  outline: none;
}
/* スロットの縦並びコンテナ */
.slots {
  position: relative; /* 青枠を中で絶対配置するため */
}
/* 連続選択全体を囲む外周青枠 */
.multiRangeOutline {
  position: absolute;
  left: 0;
  right: 0;
  top: 0;              /* ← 重要：外周を枠位置に合わせるため */
  border: 2px solid #2563eb;      /* ← 単枠と同じ色へ統一 */
  border-radius: 0px;              /* ← 角なし（単枠に合わせる） */
  pointer-events: none;
  box-sizing: border-box;
}
  </style>
  <style>
   #helpBtn{
     position: fixed; top: 12px; right: 12px;
     width: 32px; height: 32px; line-height: 32px;
     padding: 0; font: inherit; font-size: 16px;
     border: 1px solid #ddd; border-radius: 50%;
     background: #fff; box-shadow: 0 2px 10px rgba(0,0,0,.08);
     text-align: center; cursor: pointer; z-index: 10000;
   }
    #helpBtn:hover{ box-shadow: 0 4px 16px rgba(0,0,0,.12); }
    @media print{ #helpBtn{ display: none !important; } }
	
    /* Help dialog basic styling */
    #helpDialog{ border:none; padding:0; }
    #helpDialog::backdrop{ background: rgba(0,0,0,.35); }
    #helpDialog > div{
      max-height: min(70vh, 600px);
      overflow:auto;
      background:#fff;
      border-radius:12px;
      box-shadow: 0 10px 30px rgba(0,0,0,.18);
    }
    #helpDialog h2{ margin:0 0 .5rem; font-size:1.1rem; }
    #helpCloseBtn{
      display:block; margin:16px 0 0 auto;
      height:32px; padding:0 12px; border:1px solid #ddd;
      border-radius:8px; background:#fff; cursor:pointer;
    }
    @media print{ #helpDialog{ display:none !important; } }

    /* help content: keyboard key, table */
    #helpDialog kbd{
      display:inline-block; min-width:1.6em; padding:.15em .4em;
      border:1px solid #ccc; border-bottom-width:2px; border-radius:6px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size:.92em; background:#f8f8f8;
    }
    #helpDialog table.help-table{
      width:100%; border-collapse:collapse; margin:.5rem 0 0;
      font-size:.95em;
    }
    #helpDialog table.help-table th,
    #helpDialog table.help-table td{
      border-top:1px solid #eee; padding:.5rem .25rem; text-align:left; vertical-align:top;
    }
    #helpDialog table.help-table th{ width:32%; font-weight:600; }
	
/* グループ全体を右端に寄せて、ボタン同士はきっちり詰める */
.json-controls {
  display: inline-flex;
  align-items: center;
  gap: 4px;           /* ボタン間のすき間 */
  margin-left: auto;  /* ここで「右寄せ」の役割を担当 */
}

/* ? ボタンはグループのすぐ右に軽くくっつけるイメージ */
#helpBtn {
  margin-left: 4px !important;  /* もし元CSSで auto になっていても上書き */
}

/* 保存情報の文字を少しだけ小さく＆折り返しにくく */
#saveInfo.save-info {
  margin-left: 8px;
  white-space: nowrap;
  font-size: 11px;
}

/* 読込・保存ボタンの余白を少なめに */
#loadJsonBtn,
#saveJsonBtn {
  margin-left: 0;
  margin-right: 0;
}

	/* フォーカス表示では 2P印刷ボタンを非表示 */
body.dayFocus #printWeek2pBtn {
  display: none !important;
}



.iol-table-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  column-gap: 12px;
  row-gap: 0;              /* ★ 行間スキマなし */
  margin-top: 4px;
}


.iol-header,
.iol-cell {
  margin: 0;
  padding: 2px 8px;        /* ★ 縦方向の余白を小さく */
  font-size: 13px;
}
/* IOLの各行（種類・度数・用途）を横並びで統一 */
.iol-cell {
  display: flex;
  align-items: center;
  gap: 4px;
}

/* 種類・度数・用途：グレー枠の中で少し幅広に */
.iol-input,
.iol-select {
  width: 6.5em;        /* ★ ここを広げるだけ（6.5〜8emくらいで好み調整OK） */
  padding: 1px 3px;
  height: 1.8em;
  box-sizing: border-box;
}

/* IOL① ヘッダ */
.iol-table-grid > .iol-header:nth-child(1) {
  background: #fafafa;
  border: 1px solid #ddd;
  border-bottom: none;
  border-radius: 4px 4px 0 0;
  padding: 4px 8px;
}

/* IOL① 種類・度数行 */
/* IOL① 種類行（常に中段） */
.iol-table-grid > .iol-cell:nth-child(4) {
  background: #fafafa;
  border-left: 1px solid #ddd;
  border-right: 1px solid #ddd;
  padding: 4px 8px;
}

/* IOL① 度数行：デフォルトはここでカードを閉じる */
.iol-table-grid > .iol-cell:nth-child(7) {
  background: #fafafa;
  border-left: 1px solid #ddd;
  border-right: 1px solid #ddd;
  border-bottom: 1px solid #ddd;
  border-radius: 0 0 4px 4px;
  padding: 4px 8px;
}

/* IOL① 用途行（showIolUse時だけ下端として表示） */
#editor.showIolDetail .iol-table-grid > .iol-cell:nth-child(10) {
  background: #fafafa;
  border: 1px solid #ddd;
  border-top: none;
  border-radius: 0 0 4px 4px;
  padding: 4px 8px;
}

/* showIolUse中は度数行を中段扱いに変更 */
#editor.showIolDetail .iol-table-grid > .iol-cell:nth-child(7) {
  border-bottom: none;
  border-radius: 0;
}

/* IOL② ヘッダ */
.iol-table-grid > .iol-header:nth-child(2) {
  background: #fafafa;
  border: 1px solid #ddd;
  border-bottom: none;
  border-radius: 4px 4px 0 0;
  padding: 4px 8px;
}

/* IOL② 種類行 */
.iol-table-grid > .iol-cell:nth-child(5) {
  background: #fafafa;
  border-left: 1px solid #ddd;
  border-right: 1px solid #ddd;
  padding: 4px 8px;
}

/* IOL② 度数行：通常はここでカードを閉じる */
.iol-table-grid > .iol-cell:nth-child(8) {
  background: #fafafa;
  border-left: 1px solid #ddd;
  border-right: 1px solid #ddd;
  border-bottom: 1px solid #ddd;
  border-radius: 0 0 4px 4px;
  padding: 4px 8px;
}

/* IOL② 用途行：詳細表示時だけ下端にする */
#editor.showIolDetail .iol-table-grid > .iol-cell:nth-child(11) {
  background: #fafafa;
  border: 1px solid #ddd;
  border-top: none;            /* ★ ここで二重線を防ぐ */
  border-radius: 0 0 4px 4px;
  padding: 4px 8px;
}

/* 詳細表示中は度数行を中段扱いに変更 */
#editor.showIolDetail .iol-table-grid > .iol-cell:nth-child(8) {
  border-bottom: none;         /* ★ 下の線を消して用途に引き継ぐ */
  border-radius: 0;
}


/* IOL③ ヘッダ */
.iol-table-grid > .iol-header:nth-child(3) {
  background: #fafafa;
  border: 1px solid #ddd;
  border-bottom: none;
  border-radius: 4px 4px 0 0;
  padding: 4px 8px;
}

/* IOL③ 種類行 */
.iol-table-grid > .iol-cell:nth-child(6) {
  background: #fafafa;
  border-left: 1px solid #ddd;
  border-right: 1px solid #ddd;
  padding: 4px 8px;
}

/* IOL③ 度数行：通常はここでカードを閉じる */
.iol-table-grid > .iol-cell:nth-child(9) {
  background: #fafafa;
  border-left: 1px solid #ddd;
  border-right: 1px solid #ddd;
  border-bottom: 1px solid #ddd;
  border-radius: 0 0 4px 4px;
  padding: 4px 8px;
}

/* IOL③ 用途行：詳細表示時だけ下端にする */
#editor.showIolDetail .iol-table-grid > .iol-cell:nth-child(12) {
  background: #fafafa;
  border: 1px solid #ddd;
  border-top: none;            /* ★ 二重線防止 */
  border-radius: 0 0 4px 4px;
  padding: 4px 8px;
}

/* 詳細表示中は度数行を中段扱いに変更 */
#editor.showIolDetail .iol-table-grid > .iol-cell:nth-child(9) {
  border-bottom: none;         /* ★ 下線を用途に譲る */
  border-radius: 0;
}


/* ① IOL②・③のセル：位置は維持して中身だけ隠す */
.iol-extra-cell {
  visibility: hidden;   /* ← display:none をやめて visibility で隠す */
}

/* ② 用途行は行ごと消したいので display:none のまま */
.iol-use-cell {
  display: none;
}

/* ③ 詳細表示モード：IOL②・③＋用途をいっしょに表示 */
#editor.showIolDetail .iol-extra-cell {
  visibility: visible;
}

#editor.showIolDetail .iol-use-cell {
  display: flex;        /* 他の .iol-cell と同じ flex で表示 */
}


	
  </style>
  </head>
<body>
  <header class="topbar">
    <div class="group">
      <button id="prevWeek">« 前週</button>
      <input type="date" id="weekPicker" />
      <button id="nextWeek">次週 »</button>
      <button id="todayBtn">今週</button>
　　　 <button id="settingsBtn">設定</button>
      <button id="printBtn">印刷</button>
	  <button id="printWeek2pBtn">2P印刷</button>
    </div>
    <div class="group">
      <button id="editBtn" class="primary">編集</button>
      <button id="undoBtn">元に戻す</button>
      <button id="redoBtn">やり直し</button>
    </div>
    <div class="group" aria-label="レイアウト切替">
      <span>レイアウト:</span>
      <button id="mode2col">2列</button>
      <button id="mode4col">4列</button>
      <button id="mode5col">5列</button>
    </div>
  </header>
  <main id="schedule">
    <div class="column" id="leftCol"></div>
    <div class="column" id="rightCol"></div>
  </main>

<!-- ▼ 編集ダイアログ（旧版と互換の最小項目） -->
<dialog id="editor">
  <form id="editorForm" method="dialog" style="min-width:520px;max-width:720px">
    <h3 id="editorTitle" style="margin:0 0 8px;font-size:16px">枠の編集</h3>
<div style="display:grid;grid-template-columns:120px 1fr;gap:8px;align-items:center">
  <!-- 基本情報 -->
  <label>氏名</label><input name="name" />
  <label>患者ID</label><input name="pid" />
  <label>年齢</label><input name="age" />
  
    <!-- 入外当を先に固める -->
  <label>入/外/当日入院</label>
  <select name="io">
    <option></option><option>入</option><option>外</option><option>当</option>
  </select>
  
  <label>眼</label>
  <div style="display:flex; align-items:center; gap:8px;">
    <select name="eye" style="width:5em;">
      <option value=""></option>
      <option>R</option>
      <option>L</option>
      <option>B</option>
    </select>

    <label for="rlSet" style="white-space:nowrap; font-size:13px;">
      <input type="checkbox" id="rlSet" name="rlSet">
      対眼も連続作成（RLセット）
    </label>
  </div>

  <!-- 次に術者 -->
  <label>術者</label>
  <div style="display:flex;gap:4px;align-items:center;">
    <select name="surgeon" style="min-width:7em;"></select>
    <input name="surgeonFree" placeholder="その他（自由入力）" style="flex:1;">
  </div>

  <!-- 術式1・2 -->
  <label>術式1</label><input name="proc1" />
  <label>
    術式2
    <span style="font-size:11px;color:#777;margin-left:4px;">（デバイス系）</span>
  </label>
  <input name="proc2"
         placeholder="例）iStent / アーメド / Preserflo / 涙点プラグ など" />

  <!-- 備考 -->
  <label>備考</label><textarea name="note" rows="3" style="resize:vertical"></textarea>

  <!-- ▼ 新 IOL 3カラムブロック -->
<label>IOL情報</label>
<div>
  <div class="iol-table-grid">
    <!-- ▼ 1行目：ヘッダ -->
    <div class="iol-header">IOL①</div>
	<div class="iol-header iol-extra-cell">IOL②</div>
	<div class="iol-header iol-extra-cell">IOL③</div>

    <!-- ▼ 2行目：種類 -->
    <div class="iol-cell">
      種類 <input name="iolType"   list="iolTypes"  class="iol-input">
    </div>
    <div class="iol-cell iol-extra-cell">
      種類 <input name="iolType2"  list="iolTypes"  class="iol-input">
    </div>
    <div class="iol-cell iol-extra-cell">
      種類 <input name="iolType3"  list="iolTypes"  class="iol-input">
    </div>

    <!-- ▼ 3行目：度数 -->
    <div class="iol-cell">
      度数 <input name="iolPower"  list="iolPowers" class="iol-input">
    </div>
    <div class="iol-cell iol-extra-cell">
      度数 <input name="iolPower2" list="iolPowers" class="iol-input">
    </div>
    <div class="iol-cell iol-extra-cell">
      度数 <input name="iolPower3" list="iolPowers" class="iol-input">
    </div>

    <!-- ▼ 4行目：用途 -->
    <div class="iol-cell iol-use-cell">
      用途
      <input name="iolUse1" class="iol-input" list="iolUses">
    </div>
    <div class="iol-cell iol-use-cell">
      用途
      <input name="iolUse2" class="iol-input" list="iolUses">
    </div>
    <div class="iol-cell iol-use-cell">
      用途
      <input name="iolUse3" class="iol-input" list="iolUses">
    </div>
  </div> <!-- /.iol-table-grid -->

  <div style="text-align:right; font-size:11px; margin-top:2px;">
    <button type="button"
            id="toggleIolUseRow"
            style="border:none; background:none; color:#2563eb; cursor:pointer; padding:0;">
      IOL②・③を表示
    </button>
  </div>
</div>



  <!-- 入退室時間 -->
<label>入退室時間</label>
<div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
  <input name="durationH" type="text" inputmode="numeric" style="width:2.5em" placeholder="0">
  <span>時間</span>
  <input name="durationM" type="text" inputmode="numeric" style="width:2.5em" placeholder="0">
  <span>分</span>

  <!-- 右端の注釈 -->
  <span style="font-size:12px;color:#666;white-space:nowrap; margin-left:8px;">
    （未入力＝20分）
  </span>
</div>

  <!-- 結合（枠数）は非表示のまま維持 -->
  <label style="display:none">結合（枠数）</label>
  <div style="display:none">
    <input type="checkbox" id="mergeSlots" name="mergeSlots">
    <label for="mergeSlots">この枠から</label>
    <input name="mergeSpan" type="number" min="1" value="1" style="width:5em"> 枠
  </div>

  <!-- 感染症 -->
  <label>感染症</label>
  <div style="display:flex;gap:12px;align-items:center">
    <label><input type="radio" name="infection" value="なし"> なし</label>
    <label><input type="radio" name="infection" value="あり"> あり</label>
    <label><input type="radio" name="infection" value=""> 未選択</label>
  </div>

  <!-- 全麻 -->
  <label>全麻</label>
  <div>
    <input type="checkbox" id="ga" name="ga">
  </div>

  <!-- 局麻（斜視等のみ） -->
  <label>
    局麻
    <span style="font-size:11px;color:#555;margin-left:4px;">（斜視等のみ）</span>
  </label>
  <div>
    <input type="checkbox" id="local" name="local">
  </div>

</div>




    <menu style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
      <button type="button" value="clear" style="color:#b91c1c">クリア</button>
      <button value="cancel">キャンセル</button>
      <button value="save" class="primary">保存</button>
    </menu>
  </form>
</dialog>

<!-- datalist（IOL候補） -->
<datalist id="iolTypes"></datalist>
<datalist id="iolPowers"></datalist>
<datalist id="iolUses">
  <option value="in">
  <option value="out">
  <option value="fix">
</datalist>


  <template id="slotTemplate">
    <div class="slot" draggable="false">
      <div class="time"></div>
      <div class="content">
        <span class="content-left"></span>
        <span class="surgeon-tag" title="術者"></span>
      </div>
    </div>
  </template>

<!-- ▼▼ 選択肢の供給元：datalist（エディタの入力欄の list="" から参照） -->
<datalist id="iolTypes"></datalist>
<datalist id="procList"></datalist>
<datalist id="procList2"></datalist>
<datalist id="surgeonsList"></datalist>

<!-- ▼▼ 設定ダイアログ -->
<dialog id="settings" style="width:min(720px, 92vw); padding:16px;">
  <form id="settingsForm" method="dialog" style="display:flex; flex-direction:column; gap:12px;">
    <h3 style="margin:0 0 8px;">候補リストの編集</h3>

    <label style="display:flex; gap:8px;">
      <span style="width:120px; padding-top:6px;">IOL種類</span>
      <textarea id="optIolTypes" rows="4" style="flex:1;"></textarea>
    </label>

    <label style="display:flex; gap:8px;">
      <span style="width:120px; padding-top:6px;">術式１</span>
      <textarea id="optProc1" rows="4" style="flex:1;"></textarea>
    </label>

    <label style="display:flex; gap:8px;">
      <span style="width:120px; padding-top:6px;">術式２</span>
      <textarea id="optProc2" rows="4" style="flex:1;"></textarea>
    </label>

    <label style="display:flex; gap:8px;">
      <span style="width:120px; padding-top:6px;">術者</span>
      <textarea id="optSurgeons" rows="4" style="flex:1;"></textarea>
    </label>

    <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:8px;">
      <button value="cancel">閉じる</button>
      <button class="primary" id="settingsSaveBtn" value="save">保存</button>
    </div>
  </form>
</dialog>

  <script>
  "use strict";

  // ===== 基本設定 =====
  const CONFIG = {
    Mon: [{ title: "午前（手術室1）", start: "09:30", slots: 8 }],
    Tue: [
      { title: "午前（手術室1）", start: "09:30", slots: 8 },
      { title: "午後（手術室1）", start: "13:00", slots: 12 },
      { title: "午後（手術室8）", start: "13:00", slots: 10 }
    ],
    Wed: [{ title: "午前（手術室9）", start: "09:30", slots: 8 }],
    Thu: [{ title: "午前（手術室1）", start: "09:30", slots: 8 }],
    Fri: [
      { title: "午前（手術室1）", start: "09:30", slots: 8 },
      { title: "午後（手術室1）", start: "13:00", slots: 12 },
      { title: "午後（手術室8）", start: "13:00", slots: 10 }
    ],
    Weekend: [{ title: "週末臨時手術（Sat/Sun）", start: "09:30", slots: 0 }]
  };


  // 要素参照
  const leftCol  = document.getElementById('leftCol');
  const rightCol = document.getElementById('rightCol');
  const weekPicker = document.getElementById('weekPicker');
  const prevWeekBtn = document.getElementById('prevWeek');
  const nextWeekBtn = document.getElementById('nextWeek');
  const todayBtn        = document.getElementById('todayBtn');
  const printBtn        = document.getElementById('printBtn');
  const printWeek2pBtn  = document.getElementById('printWeek2pBtn');
  const slotTpl     = document.getElementById('slotTemplate');
  const mode2 = document.getElementById('mode2col');
  const mode4 = document.getElementById('mode4col');
  const mode5 = document.getElementById('mode5col');
  const editBtn     = document.getElementById('editBtn'); 
  
// ==== シンプル⇅：clickで現在slotを記録し、hiddenRowを飛ばして移動 ====
(function(){
  if (window.__navHeadSimpleBound) return;
  window.__navHeadSimpleBound = true;

  // 1) クリックで現在slotを記録（tailならheadへ寄せる）
  document.addEventListener('click', (e)=>{
    const slot = e.target.closest?.('.slot');
    if (!slot) return;
    // 押した“実際の行”のY中心を記録（hiddenでもOK）
    window.__navRowY = (slot.getBoundingClientRect().top + slot.getBoundingClientRect().bottom) / 2;	
    window.__navCurSlot = slot.classList.contains('hiddenRow')
      ? (function upToHead(n){ while(n && n.classList.contains('hiddenRow')) n = n.previousElementSibling; return n || slot; })(slot)
      : slot;
  }, {capture:true});

  // 2) ⇅でhead単位に移動（hiddenRowは停車しない）
  document.addEventListener('keydown', (e)=>{
    if (e.key!=='ArrowDown' && e.key!=='ArrowUp') return;
    // Ctrl押下時・入力中・ダイアログ開中は無効化
    if (e.ctrlKey) return;
    const t = e.target, tag = t?.tagName?.toLowerCase();
    if (tag==='input' || tag==='textarea' || t?.isContentEditable) return;
    const ed=document.getElementById('editor'), st=document.getElementById('settings');
    if ((ed&&(ed.open||ed.classList?.contains('is-open'))) || 
        (st&&(st.open||st.classList?.contains('is-open')))) return;	
    // Ctrl 押下中はこの簡易ナビを無効化（ショートカットに譲る）
    if (e.ctrlKey) return;
    // フォーカス表示中はこの簡易ナビを無効化（同日内ロジックに譲る）
    if (document.body.classList.contains('dayFocus')) return;	

    // 他ハンドラを止めて自前制御
    e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation();
	
    // dayFocus 中はこのハンドラを無効化（専用ロジックに委譲）
    if (document.body.classList.contains('dayFocus')) return;	

    // 現在地：自前記録 → 既存active系の順でfallback
    let cur = window.__navCurSlot
           || window.activeSlotEl
           || document.querySelector('.slot.active, .slot.is-active, .slot.selected')
           || null;

    // 初回など未選択なら、画面上の最初/最後の非hiddenRowを選ぶ
    if (!cur) {
      const root = document.getElementById('schedule') || document;
  const heads0 = Array.from(root.querySelectorAll('.slot')).filter(s => {
    if (typeof window.isSelectableSlot === 'function') return window.isSelectableSlot(s);
    // フォールバック（以前の基準を温存）
    if (!s || !s.classList?.contains('slot')) return false;
    if (s.classList.contains('hiddenRow')) return false;
    if (s.hidden || s.classList.contains('disabled') || s.classList.contains('locked')) return false;
    const day = s.closest?.('.day');
    if (!day) return false;
    if (day.classList.contains('is-holiday') || day.classList.contains('is-off')) return false;
    const wrap = s.closest?.('.slots');
    if (wrap?.classList?.contains('section-off')) return false;
    if (s.classList.contains('off')) return false;
    return (getComputedStyle(s).display !== 'none');
  });
      if (!heads0.length) return;
      const initTarget = (e.key==='ArrowDown') ? heads0[0] : heads0[heads0.length-1];
      initTarget.dispatchEvent(new MouseEvent('click', {bubbles:true}));
      const target = window.activeSlotEl || initTarget;
      window.__navCurSlot = target;
      // ★ 週表示の初回ジャンプも、即時に中央へスナップ
      target.scrollIntoView({ block: 'center', inline: 'nearest', behavior: 'auto' });
      return;
    }

    // ★ RLセット外周選択中は、⇅の基準を「セットの先頭/末尾」に寄せて
    //    セット単位でジャンプする
    if (window.currentRLSetId) {
      const selEls = Array.from(document.querySelectorAll('.slot.multiSelected'));
      if (selEls.length >= 1) {
        // DOM順にソート（上から順）
        const sorted = selEls.slice().sort((a, b) => {
          if (a === b) return 0;
          const pos = a.compareDocumentPosition(b);
          if (pos & Node.DOCUMENT_POSITION_FOLLOWING) return -1;
          if (pos & Node.DOCUMENT_POSITION_PRECEDING) return 1;
          return 0;
        });
        if (e.key === 'ArrowDown') {
          // ↓ の場合：セット末尾を現在地として扱う → 次の停車駅は「セットのすぐ下」
          cur = sorted[sorted.length - 1];
        } else if (e.key === 'ArrowUp') {
          // ↑ の場合：セット先頭を現在地として扱う → 次の停車駅は「セットのすぐ上」
          cur = sorted[0];
        }
      }
    }

  // 画面全体の「停車駅」＝“選択可能スロット”のみ（祝日/休止/section-off/off/hiddenRow等を一括除外）
    const root = document.getElementById('schedule') || document;
    const list = Array.from(root.querySelectorAll('.slot'));
  const heads = list.filter(s => {
    if (typeof window.isSelectableSlot === 'function') return window.isSelectableSlot(s);
    // フォールバック（↑と同じ判定）
    if (!s || !s.classList?.contains('slot')) return false;
    if (s.classList.contains('hiddenRow')) return false;
    if (s.hidden || s.classList.contains('disabled') || s.classList.contains('locked')) return false;
  // 緊急/臨時は特別扱い（常に候補に含める）
  const isEmOrTemp = s.classList.contains('emergency-slot') || s.classList.contains('temp-slot');
    const day = s.closest?.('.day');
    if (!day) return false;
  // 祝日・休診日でも「緊急/臨時」は例外で通す
  if ((day.classList.contains('is-holiday') || day.classList.contains('is-off')) && !isEmOrTemp) return false;
    const wrap = s.closest?.('.slots');
  // セクション休止でも「緊急/臨時」は例外
  if (wrap?.classList?.contains('section-off') && !isEmOrTemp) return false;
  // 個別offでも「緊急/臨時」は例外
  if (s.classList.contains('off') && !isEmOrTemp) return false;
    return (getComputedStyle(s).display !== 'none');
  });
    if (!heads.length) return;

    // 現在地がtailならheadへ寄せる
    if (cur.classList.contains('hiddenRow')) {
      let p = cur.previousElementSibling;
      while (p && p.classList.contains('hiddenRow')) p = p.previousElementSibling;
      if (p) cur = p;
    }

    // インデックス → 次の停車駅
    const i = heads.indexOf(cur);
    if (i < 0) return;
    const next = heads[i + (e.key==='ArrowDown' ? 1 : -1)];
    if (!next) return;

    // 既存クリック処理に委譲して選択更新
    next.dispatchEvent(new MouseEvent('click', {bubbles:true}));

    // ★ 実際のアクティブスロットを取得（クリックで切り替わっている可能性に対応）
    const target = window.activeSlotEl || next;
    window.__navCurSlot = target; // 自前の現在地も更新

target.scrollIntoView({
  block:  'center',   // 縦方向は既存どおり
  inline: 'center',  // ★ 横方向も中央寄せにする（重要）
  behavior: 'auto'    // パッと移動
});
  }, {capture:true});
})();

// ==== 右移動（シンプル完全版）：真横へ → hiddenRowならheadに正規化 ==== 
(function(){
  if (window.__arrowRightSimpleBound) return;
  window.__arrowRightSimpleBound = true;

  // head取得（hiddenRowなら上へ遡る）
  function getHead(el){ let n=el; while(n && n.classList.contains('hiddenRow')) n=n.previousElementSibling; return n||el; }
  // 休日判定（ローカル）
  function isOffDay(el){ const d=el?.closest?.('.day'); return !!(d && (d.classList.contains('is-holiday')||d.classList.contains('is-off'))); }

  // 右隣の“隣列”で最も近い行のslotを返す（hiddenRowは着地候補に含めない）
  function nearestRightSlot(fromEl){
    if (!fromEl) return null;
    const cur = getHead(fromEl).getBoundingClientRect();
    const EPSX = 3, EPSY = 4;
    const root = document.getElementById('schedule') || document;

    // 右側候補（hiddenRow除外）
    const all = Array.from(root.querySelectorAll('.slot')).filter(s => !s.classList.contains('hiddenRow'));
    const right = [];
    for (const el of all){
      const r = el.getBoundingClientRect(); if (!r) continue;
      if (r.left < cur.right - EPSX) continue; // 右側のみ
      right.push({el, left:r.left, top:r.top, bottom:r.bottom});
    }
    if (!right.length) return null;

    // 隣列だけに固定（最小leftの列）
    const minLeft = Math.min(...right.map(c=>c.left));
    const sameCol = right.filter(c => c.left <= minLeft + EPSX);
    if (!sameCol.length) return null;

   // まず「クリックした実際の行Y」で隣列の同じ行帯を優先
   const rowY = (window.__navRowY ?? ((cur.top + cur.bottom)/2));
   const inRow = sameCol.filter(c => rowY >= c.top - EPSY && rowY <= c.bottom + EPSY);
    const pick = (inRow.length ? inRow : sameCol).sort((a,b)=>{
       if (inRow.length){
         const cya = (a.top + a.bottom)/2, cyb = (b.top + b.bottom)/2;
         const ya = Math.abs(cya - rowY),     yb = Math.abs(cyb - rowY);
         if (ya !== yb) return ya - yb;                 // 行中心に近い方を最優先（= head帯が勝つ）
         const dxA = Math.max(0, a.left - cur.right);
         const dxB = Math.max(0, b.left - cur.right);
         if (dxA !== dxB) return dxA - dxB;             // 次に横の近さ
         return a.top - b.top;                          // 最後に上寄りで安定化
       }else{
         const dyA = Math.min(Math.abs(a.bottom - cur.top), Math.abs(a.top - cur.bottom));
         const dyB = Math.min(Math.abs(b.bottom - cur.top), Math.abs(b.top - cur.bottom));
         if (dyA !== dyB) return dyA - dyB;             // 縦距離
         const dxA = Math.max(0, a.left - cur.right);
         const dxB = Math.max(0, b.left - cur.right);
         return dxA - dxB;                              // 横距離
       }
     });
    // ★ 休日列でも「緊急/臨時」があれば着地を許可
    for (const c of pick){
      const el = c.el;
      const isEmOrTemp = el.classList.contains('emergency-slot') || el.classList.contains('temp-slot');
      if (isEmOrTemp) return el;
      if (!isOffDay(el)) return el;
    }
    return null; // 隣列が休日のみなら着地なし（上位でフォールバックすればOK）
  }

  // →キーで移動（hiddenRowに当たったらheadへ正規化して選択）
  document.addEventListener('keydown', (e)=>{
    if (e.key !== 'ArrowRight') return;
    // フォーカス中はこの横移動を無効化（フォーカス用ロジックに委譲）
    if (document.body.classList.contains('dayFocus')) return;	
    // Ctrl+→ は週/日ジャンプに譲る（通常の横移動は無効化）
    if (e.ctrlKey) return;
	const t = e.target, tag = t?.tagName?.toLowerCase();
	if (tag==='input' || tag==='textarea' || t?.isContentEditable) return;
	const ed=document.getElementById('editor'), st=document.getElementById('settings');
	if ((ed&&(ed.open||ed.classList?.contains('is-open'))) || (st&&(st.open||st.classList?.contains('is-open')))) return;


    // 現在位置の取得（クリックで選んだ要素を優先）
    let cur = window.__navCurSlot
            || window.activeSlotEl
            || document.querySelector('.slot.active, .slot.is-active, .slot.selected');
    if (!cur) return;

    // 衝突回避
    e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation();

 // ★直前のスクロール影響を避けるため、毎回ここで rowY を“今のrect”から決定
 { const head = getHead(cur); const r = head.getBoundingClientRect();
   window.__navRowY = head.classList.contains('mergeHead') ? (r.top + 1) : ((r.top + r.bottom)/2);
 }
  
    // 出発点はhead基準
    cur = getHead(cur);

    let next = nearestRightSlot(cur);
    if (!next) return;

    // --- 着地の正規化（休止/祝日/セクション休止を回避）---
    const isSel = (el)=>{
      if (window.isSelectableSlot) return window.isSelectableSlot(el);
      // フォールバック（念のため）
      if (!el || !el.classList?.contains('slot')) return false;
      if (el.hidden || el.classList.contains('hiddenRow') || el.classList.contains('disabled') || el.classList.contains('locked')) return false;
      const isEmOrTemp = el.classList.contains('emergency-slot') || el.classList.contains('temp-slot');
      const day = el.closest?.('.day');
      const slotsWrap = el.closest?.('.slots');
      if (day && (day.classList.contains('is-off') || day.classList.contains('is-holiday')) && !isEmOrTemp) return false;
      if (slotsWrap?.classList?.contains('section-off') && !isEmOrTemp) return false;
      if (el.classList.contains('off') && !isEmOrTemp) return false;
      return true;
    };

    // まず head を基準に判定
    let head = getHead(next);
    if (!isSel(head)) {
      const day = head.closest?.('.day');
      // 同日内の「選択可能」候補を収集
      const allInDay = day ? Array.from(day.querySelectorAll('.slot')).filter(isSel) : [];
      if (allInDay.length) {
        // クリック行Y（__navRowY）に最も近い候補へ寄せる
        const targetY = (()=>{
          if (typeof window.__navRowY === 'number') return window.__navRowY;
          const r = head.getBoundingClientRect(); return (r.top + r.bottom) / 2;
        })();
        head = allInDay
          .map(el => ({ el, r: el.getBoundingClientRect() }))
          .sort((a,b)=>{
            const ya = Math.abs(((a.r.top+a.r.bottom)/2) - targetY);
            const yb = Math.abs(((b.r.top+b.r.bottom)/2) - targetY);
            if (ya !== yb) return ya - yb;
            return a.r.top - b.r.top; // 同距離なら上寄りで安定
          })[0].el;
      } else {
        // 同日内に選択可能枠が無ければ「右側の営業日」へフォールバック
        const days = Array.from(document.querySelectorAll('.day'));
        const i = days.indexOf(day);
        let found = null;
        for (let j = i + 1; j < days.length; j++) {
          const f = window.findFirstSelectableInDay?.(days[j]);
          if (f && isSel(f)) { found = f; break; }
        }
        if (!found) return; // 着地先なし → 何もしない
        head = found;
      }
    }

    head.dispatchEvent(new MouseEvent('click', {bubbles:true}));
    window.__navCurSlot = head;
    { const rr = head.getBoundingClientRect();
      window.__navRowY = head.classList.contains('mergeHead') ? (rr.top + 1) : ((rr.top + rr.bottom)/2);
    }	
    (window.activeSlotEl || head).scrollIntoView({
      block:  'center',
      inline: 'center',   // ★ 左右も中央寄せにする
      behavior: 'auto'    // ★ アニメーションなしで一発スナップ
    });
  }, {capture:true});

  // クリックで現在地を記録（次回の起点にする）
  document.addEventListener('click', (e)=>{
    const slot = e.target.closest?.('.slot'); if (!slot) return;
    const r = slot.getBoundingClientRect();
    window.__navRowY = slot.classList.contains('mergeHead') ? (r.top + 1) : ((r.top + r.bottom)/2);	
    window.__navCurSlot = getHead(slot);
  }, {capture:true});
})();

// ==== 左移動（シンプル完全版）：真横へ → hiddenRowならheadに正規化 ==== 
(function(){
  if (window.__arrowLeftSimpleBound) return;
  window.__arrowLeftSimpleBound = true;

  // head取得（hiddenRowなら上へ遡る）
  function getHead(el){ let n=el; while(n && n.classList.contains('hiddenRow')) n=n.previousElementSibling; return n||el; }
  // 休日判定（ローカル）
  function isOffDay(el){ const d=el?.closest?.('.day'); return !!(d && (d.classList.contains('is-holiday')||d.classList.contains('is-off'))); }

  // 左隣の“隣列”で最も近い行のslotを返す（hiddenRowは着地候補に含めない）
  function nearestLeftSlot(fromEl){
    if (!fromEl) return null;
    const cur = getHead(fromEl).getBoundingClientRect();
    const EPSX = 3, EPSY = 3;
    const root = document.getElementById('schedule') || document;

    // 左側候補（hiddenRow除外）
    const all = Array.from(root.querySelectorAll('.slot')).filter(s => !s.classList.contains('hiddenRow'));
    const left = [];
    for (const el of all){
      const r = el.getBoundingClientRect(); if (!r) continue;
      if (r.right > cur.left + EPSX) continue; // 左側のみ
      left.push({el, right:r.right, top:r.top, bottom:r.bottom});
    }
    if (!left.length) return null;

    // 隣列だけに固定（最大rightの列）
    const maxRight = Math.max(...left.map(c=>c.right));
    const sameCol = left.filter(c => c.right >= maxRight - EPSX);
    if (!sameCol.length) return null;

    // 「クリックした実際の行Y」で隣列の同じ行帯を優先
    const rowY = (window.__navRowY ?? ((cur.top + cur.bottom)/2));
    const inRow = sameCol.filter(c => rowY >= c.top - EPSY && rowY <= c.bottom + EPSY);

    const pick = (inRow.length ? inRow : sameCol).sort((a,b)=>{
       if (inRow.length){
         const cya = (a.top + a.bottom)/2, cyb = (b.top + b.bottom)/2;
         const ya = Math.abs(cya - rowY),     yb = Math.abs(cyb - rowY);
         if (ya !== yb) return ya - yb;                 // 行中心に近い方を最優先
         const dxA = Math.max(0, cur.left - a.right);
         const dxB = Math.max(0, cur.left - b.right);
         if (dxA !== dxB) return dxA - dxB;             // 次に横の近さ
         return a.top - b.top;                          // 最後に上寄りで安定化
       }else{
         const dyA = Math.min(Math.abs(a.bottom - cur.top), Math.abs(a.top - cur.bottom));
         const dyB = Math.min(Math.abs(b.bottom - cur.top), Math.abs(b.top - cur.bottom));
         if (dyA !== dyB) return dyA - dyB;
         const dxA = Math.max(0, cur.left - a.right);
         const dxB = Math.max(0, cur.left - b.right);
         return dxA - dxB;
       }
     });
    // ★ 休日列でも「緊急/臨時」があれば着地を許可
    for (const c of pick){
      const el = c.el;
      const isEmOrTemp = el.classList.contains('emergency-slot') || el.classList.contains('temp-slot');
      if (isEmOrTemp) return el;
      if (!isOffDay(el)) return el;
    }
    return null;
  }

  // ←キーで移動（hiddenRowに当たったらheadへ正規化して選択）
  document.addEventListener('keydown', (e)=>{
    if (e.key !== 'ArrowLeft') return;
    // フォーカス中はこの横移動を無効化（フォーカス用ロジックに委譲）
    if (document.body.classList.contains('dayFocus')) return;	
    // Ctrl+← は週/日ジャンプに譲る（通常の横移動は無効化）
    if (e.ctrlKey) return;
	const t = e.target, tag = t?.tagName?.toLowerCase();
    if (tag==='input' || tag==='textarea' || t?.isContentEditable) return;
    const ed=document.getElementById('editor'), st=document.getElementById('settings');
    if ((ed&&(ed.open||ed.classList?.contains('is-open'))) || (st&&(st.open||st.classList?.contains('is-open')))) return;


    // 現在位置の取得（クリックで選んだ要素を優先）
    let cur = window.__navCurSlot
            || window.activeSlotEl
            || document.querySelector('.slot.active, .slot.is-active, .slot.selected');
    if (!cur) return;


  // --- 現在地が「オフ日 / 祝日」の水面下にいる場合は、左優先で営業日に正規化 ---
  (function(){
    const day0 = cur.closest?.('.day'); if (!day0) return;
    // ★ 緊急/臨時に居るなら“寄せ”を行わず、その場を優先
    if (cur.classList?.contains('emergency-slot') || cur.classList?.contains('temp-slot')) return;

    const isOffDay = (d)=>{
      if (!d) return false;
      if (d.classList.contains('is-holiday') || d.classList.contains('is-off')) return true;
      // セクション休止が日全体に及ぶケースも想定して念のため確認
      const slotsWrap = d.querySelector('.slots');
      return !!(slotsWrap && slotsWrap.classList.contains('section-off'));
    };
    if (!isOffDay(day0)) return;
    const days = Array.from(document.querySelectorAll('.day'));
    const i = days.indexOf(day0);
    let found = null;
    // 左（過去日）を優先
    for (let j = i - 1; j >= 0; j--) {
      if (!isOffDay(days[j])) { found = days[j]; break; }
    }
    // 左に無ければ右へ
    if (!found) {
      for (let j = i + 1; j < days.length; j++) {
        if (!isOffDay(days[j])) { found = days[j]; break; }
      }
    }
    if (found) {
      const first = window.findFirstSelectableInDay?.(found);
      if (first) { setActiveSlot(first, {scroll:false}); cur = first; }
    }
  })();

    // 衝突回避
    e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation();

 { const head = getHead(cur); const r = head.getBoundingClientRect();
   window.__navRowY = head.classList.contains('mergeHead') ? (r.top + 1) : ((r.top + r.bottom)/2);
 }

    // 出発点はhead基準
    cur = getHead(cur);

    let next = nearestLeftSlot(cur);
    if (!next) return;

    // --- 着地の正規化（←専用：オフ日/祝日は無条件で回避）---
    const isNavSelectable = (el)=>{
      if (!el || !el.classList?.contains('slot')) return false;
      const isEmOrTemp = el.classList.contains('emergency-slot') || el.classList.contains('temp-slot');
      // 親 day が is-off / is-holiday なら ← では必ず不可
      const day = el.closest?.('.day');
      if (day && (day.classList.contains('is-off') || day.classList.contains('is-holiday')) && !isEmOrTemp) return false;
      // セクション休止も不可
      const wrap = el.closest?.('.slots');
      if (wrap?.classList?.contains('section-off') && !isEmOrTemp) return false;
      // 個別 off も不可
      if (el.classList.contains('off') && !isEmOrTemp) return false;
      // hiddenRow / lock / disabled 等は既存の選別に委譲（念のため）
      if (el.hidden || el.classList.contains('hiddenRow') || el.classList.contains('disabled') || el.classList.contains('locked')) return false;
      return true;
    };

    let target = getHead(next);
    // 着地がナビ上不適なら寄せ直し
    if (!isNavSelectable(target)) {
      const day = target.closest?.('.day');
      // 1) 同日内の「ナビ選択可」候補から、__navRowY に最も近い枠へ
      const sameDay = day ? Array.from(day.querySelectorAll('.slot')).map(getHead).filter(isNavSelectable) : [];
      if (sameDay.length) {
        const ty = (typeof window.__navRowY === 'number')
          ? window.__navRowY
          : ((target.getBoundingClientRect().top + target.getBoundingClientRect().bottom) / 2);
        target = sameDay
          .map(el => ({ el, r: el.getBoundingClientRect() }))
          .sort((a,b)=>{
            const ya = Math.abs(((a.r.top+a.r.bottom)/2) - ty);
            const yb = Math.abs(((b.r.top+b.r.bottom)/2) - ty);
            if (ya !== yb) return ya - yb;
            return a.r.top - b.r.top;
          })[0].el;
      } else {
        // 2) 同日内が全滅なら、左側の営業日で最初の選択可スロットへ
        const days = Array.from(document.querySelectorAll('.day'));
        const i = days.indexOf(day);
        let found = null;
        for (let j = i - 1; j >= 0; j--) {
          const f = window.findFirstSelectableInDay?.(days[j]);
          if (f && isNavSelectable(f)) { found = f; break; }
        }
        if (!found) return; // 着地先なし → 何もしない
        target = getHead(found);
      }
    }
    const head = target;
    head.dispatchEvent(new MouseEvent('click', {bubbles:true}));
    window.__navCurSlot = head;
    { const rr = head.getBoundingClientRect();
      window.__navRowY = head.classList.contains('mergeHead') ? (rr.top + 1) : ((rr.top + rr.bottom)/2);
    }
    (window.activeSlotEl || head).scrollIntoView({
      block:  'center',
      inline: 'center',   // ★ 左右も中央寄せに
      behavior: 'auto'    // ★ 即時スクロール
    });
  }, {capture:true});
})();


   // ===== ダブルクリックで編集起動（週/フォーカス共通、最優先で拾う） =====
   (function(){
     const sched = document.getElementById('schedule');
     if (!sched) return;
 
     function isLockedOrHidden(slot){
       if (!slot || !slot.classList) return true;
       if (slot.classList.contains('hiddenRow')) return true;  // tailは編集不可
       if (typeof isSlotLockedForEdit === 'function' && isSlotLockedForEdit(slot)) return true;
       return false;
     }
     function resolveSlot(node){
       if (!node) return null;
       return node.closest ? node.closest('.slot') : null;
     }
     function resolveHead(slot){
       // 明示 head があればそれ、なければ hiddenRow でない枠＝単独=head
       let p = slot;
       while (p && p.classList && p.classList.contains('slot')){
         if (p.classList.contains('mergeHead')) return p;
         if (!p.classList.contains('hiddenRow')) return p;
         p = p.previousElementSibling;
       }
       return slot;
     }
     function fireEditFor(slot){
       if (!slot) return;
       // まずアクティブに（Enter/ボタン経路と同条件に揃える）
       if (typeof setActiveSlot === 'function') setActiveSlot(slot);
       // 既存の編集起動経路を優先的に使用
       if (editBtn && typeof editBtn.click === 'function') {
         editBtn.click();
         return;
       }
       if (typeof beginEditActive === 'function') {
         beginEditActive();
         return;
       }
       if (typeof openEditor === 'function') {
         const k = slot.dataset ? slot.dataset.key : undefined;
         if (k) openEditor([k]);
       }
     }
 
     // capture で最優先・他ハンドラに止められないようにする
     sched.addEventListener('dblclick', function(e){
       // 入力中/モーダル中/時刻セルは除外（既存ルールを踏襲）
       if (typeof isTypingContext === 'function' && isTypingContext(e)) return;
       if (document.querySelector('dialog[open], .modal.is-open, .editor.is-open')) return;
       if (e.target && e.target.closest && e.target.closest('.time')) return;
 
       const slot = resolveSlot(e.target);
       if (!slot) return;
       if (isLockedOrHidden(slot)) return;
 
       e.preventDefault();
       e.stopPropagation();
 
       const head = resolveHead(slot);
       fireEditFor(head);
     }, { capture: true });
   })();
// ==== 設定（候補リスト） ====
// ストレージキー
const SETTINGS_KEY = 'schedule_lists_settings';

// 既定値
function defaultLists(){
  const powers = [];
  for (let v = 15.0; v <= 30.001; v += 0.5) powers.push(v.toFixed(1)); // 使うなら
  return {
    iolTypes: ["Ni","Ho","HoT","Am","AmT","参","Le","LeT","Ko"],
    proc1: ["白内障","VIT+IOL","VITのみ","IOL強膜内固定","眼瞼内反手術"],
    proc2: ["iStent","アーメド","プリザーフロ","涙点プラグ"],
     // 術者：ショートカット:氏名 の形式（設定画面から自由に編集可）
     surgeons: [
       "k:木村",
       "o:岡部",
       "g:後藤田",
       "mi:宮部",
       "i:飯田",
       "mo:森山",
       "h:秦",
       "t:内匠"
     ]
  };
}

// 読込／保存
function loadSettings(){
  try{
    const s = localStorage.getItem(SETTINGS_KEY);
    const v = s ? JSON.parse(s) : {};
    // 欠けている配列は既定で補完
    return Object.assign(defaultLists(), v||{});
  }catch(_){
    return defaultLists();
  }
}
function saveSettings(obj){
  localStorage.setItem(SETTINGS_KEY, JSON.stringify(obj||{}));
}

// datalist に反映
function setOptions(dl, arr){
  if (!dl) return;
  dl.innerHTML = '';
  (arr||[]).forEach(v=>{
    const opt = document.createElement('option');
    opt.value = String(v);
    dl.appendChild(opt);
  });
}
// グローバルにショートカットマップを持つ
window.__surgeonShortcutMap = window.__surgeonShortcutMap || {};

function applyDatalists(lists){
  setOptions(document.getElementById('iolTypes'),  lists.iolTypes);
  setOptions(document.getElementById('procList'),  lists.proc1);
  setOptions(document.getElementById('procList2'), lists.proc2);

  // ── 術者：設定の配列（"code:名前" or "名前"）から
  //     1) 名前配列
  //     2) ショートカットマップ
  //     を生成する
  const raw = lists.surgeons || [];
  const names = [];
  const map = {};

  raw.forEach(line => {
    const text = String(line || '').trim();
    if (!text) return;

    let code = '';
    let name = '';

    const idx = text.indexOf(':');
    if (idx > 0) {
      code = text.slice(0, idx).trim();
      name = text.slice(idx + 1).trim();
    } else {
      // 「木村」だけの行も一応許容（ショートカットなし）
      name = text;
    }

    if (!name) return;
    names.push(name);
    if (code) {
      map[code.toLowerCase()] = name;
    }
  });

  // datalist（もし今後も使うなら）を名前だけで更新
  setOptions(document.getElementById('surgeonsList'), names);

  // 編集ダイアログ内の <select name="surgeon"> を更新
  const sSelect = document.querySelector('#editorForm select[name="surgeon"]');
  if (sSelect) {
    sSelect.innerHTML = '';

    const empty = document.createElement('option');
    empty.value = '';
    empty.textContent = '';
    sSelect.appendChild(empty);

    names.forEach(n => {
      const opt = document.createElement('option');
      opt.value = String(n);
      opt.textContent = String(n);
      sSelect.appendChild(opt);
    });
  }

  // グローバルショートカットマップに反映
  window.__surgeonShortcutMap = map;
}


// グローバル設定オブジェクト
let appLists = loadSettings();

  // ===== 日付ユーティリティ =====
  let currentMonday = startOfWeek(new Date());
  function startOfWeek(d){ const x=new Date(d.getFullYear(), d.getMonth(), d.getDate()); const g=x.getDay(); const diff=(g===0?-6:1-g); x.setDate(x.getDate()+diff); x.setHours(0,0,0,0); return x; }
  function addDays(d,n){ const x=new Date(d); x.setDate(x.getDate()+n); return x; }
  function dateISO(d){ const y=d.getFullYear(); const m=String(d.getMonth()+1).padStart(2,'0'); const day=String(d.getDate()).padStart(2,'0'); return `${y}-${m}-${day}`; }
  function weekKey(date){ return dateISO(startOfWeek(date)); }
  function formatDateJP(d){ const y=d.getFullYear(), m=d.getMonth()+1, day=d.getDate(); const w="日月火水木金土"[d.getDay()]; return `${y}/${m}/${day}（${w}）`; }
  function hhmmToMinutes(hhmm){ const [H, M] = String(hhmm).split(':').map(Number); return (isFinite(H) && isFinite(M)) ? H*60 + M : 0; }
  function addMinutes(hhmm, minutes){ let s = String(hhmm).trim().replace(/[！-～]/g, c => String.fromCharCode(c.charCodeAt(0) - 0xFEE0)).replace(/：/g, ':'); const m = /^(\d{1,2}):(\d{2})$/.exec(s); if (!m) return null; const h = Number(m[1]), mm = Number(m[2]); const dt = new Date(2000,0,1,h,mm); if (isNaN(dt.getTime())) return null; dt.setMinutes(dt.getMinutes() + Number(minutes || 0)); return dt.toTimeString().slice(0,5); }
  function normalizeTimeInput(raw){ if(!raw) return null; let s = String(raw).trim(); let m = /^(\d{1,2}):(\d{2})$/.exec(s); if(m){ const h=Number(m[1]), mm=Number(m[2]); if(h>=0&&h<=23&&mm>=0&&mm<=59) return `${String(h).padStart(2,'0')}:${String(mm).padStart(2,'0')}`; return null; } s = s.replace(/\s+/g,'').replace(/[^\d]/g,''); if(s.length===3 || s.length===4){ const hh=s.slice(0,s.length-2), mm=s.slice(-2); const h=Number(hh), m2=Number(mm); if(h>=0&&h<=23&&m2>=0&&m2<=59) return `${String(h).padStart(2,'0')}:${String(m2).padStart(2,'0')}`; } return null; }


// === 日フォーカス・ヘルパー ==========================
function enterDayFocus(dayEl) {
  if (!dayEl) return;

  // ★ focus時：複数選択と外枠を完全クリア（ダミー青枠対策）
  document.querySelectorAll('.multiRangeOutline').forEach(el => el.remove());
  document.querySelectorAll('.slot.multiSelected, .slot.is-selected')
    .forEach(el => {
      el.classList.remove('multiSelected');
      el.classList.remove('is-selected');
    });
  if (window.multiSelected) {
    try { window.multiSelected.clear(); } catch(_){}
  }

  // --- 状態を保存 ---
  window.focusDate = dayEl?.dataset?.date || window.focusDate; // ← ★これ
  window.__weekStartBeforeFocus = document.getElementById('weekPicker')?.value;

  // --- フォーカスモードに入る ---
  document.body.classList.add('dayFocus');
  document.querySelectorAll('#schedule .day').forEach(d => {
    d.style.display = (d === dayEl) ? 'block' : 'none';
    if (d === dayEl) d.setAttribute('data-focus', 'true');
    else d.removeAttribute('data-focus');
  });

  // --- ピッカー/内部状態を当日に“統一”（changeは発火しない） ---
  (function syncPickerAndState(){
    const iso = dayEl?.dataset?.date; // 例: "2025-11-06"
    if (!iso) return;
    const [y,m,d] = iso.split('-').map(Number);
    const dt = new Date(y, m-1, d);

    // ① フォーカス日の単一の真実を確定
    if (typeof setFocusDateStore === 'function') setFocusDateStore(dt);
    else window.currentFocusDate = dt;
    if (typeof mondayOf === 'function') window.currentMonday = mondayOf(dt);

    // ② ピッカーは当日へ（週ロジックは抑止：changeは発火しない）
    const picker = document.getElementById('weekPicker');
    if (picker){
      window.__suppressWeekChange = true;
      picker.value = iso;
      window.__setWeekdayFromISO?.(iso); // バッジだけ同期
      window.__suppressWeekChange = false; // ここで即解除
    }
  })();
  // --- 戻るボタン（存在しなければ追加） ---
  if (!document.getElementById('focusBackBtn')) {
    const btn = document.createElement('button');
    btn.id = 'focusBackBtn';
    btn.textContent = '戻る';
    btn.addEventListener('click', exitDayFocus);
    (document.querySelector('.topbar .group:nth-of-type(2)') ||
     document.querySelector('.topbar'))?.appendChild(btn);
  }

  // --- スクロール位置はそのまま（不要なjump抑制） ---
  // フォーカス突入時：未選択なら当日の先頭スロットを選ぶ
  const cur = getActiveSlot?.();
  const curDay = cur?.closest?.('.day');
  if (!cur || curDay !== dayEl) ensureInitialSelectionForDay(dayEl);

  // ★ フォーカス突入直後：現在のアクティブスロットを“パッ”とセンタリング
  requestAnimationFrame(() => window.__centerActiveInWeekSoon?.());
}

function exitDayFocus() {

  // ★ 週表示へ戻るときも残骸を確実に削除
  document.querySelectorAll('.multiRangeOutline').forEach(el => el.remove());
  document.querySelectorAll('.slot.multiSelected, .slot.is-selected')
    .forEach(el => {
      el.classList.remove('multiSelected');
      el.classList.remove('is-selected');
    });
  if (window.multiSelected) {
    try { window.multiSelected.clear(); } catch(_){}
  }

  // ---- フラグ（呼び元で制御）----
  const skipRestore = !!window.__skipRestoreOnExit;         // Ctrl+, など「復元せずに外部で合わせる」用
  window.__skipRestoreOnExit = false;
  const targetMon = window.__targetMondayOnExit || null;    // 明示ターゲット（月曜Date）指定用（任意）
  window.__targetMondayOnExit = null;

  // === 週表示で「アクティブを中央」に寄せるワンショット（週表示専用の箱を使う） ===
  function __centerActiveInWeekNow(){
    const el  = (window.getActiveSlot && window.getActiveSlot()) || document.querySelector('.slot.focused');
    if (!el) return;
    const box = (window.__getScrollBox && window.__getScrollBox()) || document.scrollingElement || document.documentElement;
    if (!box) return;

    const br  = box.getBoundingClientRect ? box.getBoundingClientRect() : {
      top: 0, left: 0,
      height: window.innerHeight,
      width:  window.innerWidth
    };
    const sr  = el.getBoundingClientRect();

    const currentTop  = box.scrollTop  || 0;
    const currentLeft = box.scrollLeft || 0;
    const viewH = ('clientHeight' in box ? box.clientHeight : window.innerHeight);
    const viewW = ('clientWidth'  in box ? box.clientWidth  : window.innerWidth);

    // --- 縦方向：中央寄せ ---
    let targetTop = (sr.top - br.top + currentTop) + (sr.height/2) - (viewH/2);
    const maxTop = Math.max(0, (box.scrollHeight || 0) - viewH);
    const nextTop = Math.max(0, Math.min(Math.round(targetTop), maxTop));

    // --- 横方向：中央寄せ ---
    let targetLeft = (sr.left - br.left + currentLeft) + (sr.width/2) - (viewW/2);
    const maxLeft = Math.max(0, (box.scrollWidth || 0) - viewW);
    const nextLeft = Math.max(0, Math.min(Math.round(targetLeft), maxLeft));

    box.scrollTop  = nextTop;
    box.scrollLeft = nextLeft;
  }

  // 後追いでセンタリング（描画完了後に一発だけ）
  function __centerActiveInWeekSoon(){
    // 1フレーム後に一度だけ実行
    requestAnimationFrame(__centerActiveInWeekNow);
  }



  // ---- モード解除（UIのみ）----
  document.body.classList.remove('dayFocus');
  document.querySelectorAll('#schedule .day').forEach(d => {
    d.style.display = '';         // フォーカス時の inline を解除
    d.removeAttribute('data-focus');
  });
  document.getElementById('focusBackBtn')?.remove();
  window.focusDate = null;

  // 以降は「復元」ロジック。スキップ指定でも週表示で“必ず”中央寄せを後追いで実行
  if (skipRestore) {
    // ★ 上寄せが予約されている場合は中央寄せを行わない（render側で実施）
    if (!window.__snapTopOnNextRender) {
      __centerActiveInWeekSoon();
    }
    return;
  }

  const picker = document.getElementById('weekPicker');
  const z = n => String(n).padStart(2,'0');
  const ymd = d => `${d.getFullYear()}-${z(d.getMonth()+1)}-${z(d.getDate())}`;

  // A) 明示ターゲット（月曜）に合わせる指示がある場合
  if (targetMon && picker instanceof HTMLInputElement) {
    const mon = new Date(targetMon.getFullYear(), targetMon.getMonth(), targetMon.getDate());
    window.currentMonday = mon;
    picker.value = ymd(mon);
    picker.dispatchEvent(new Event('change', { bubbles: true }));
    window.__weekStartBeforeFocus = null;
    // 週ビュー描画完了後に中央寄せ（後追いで複数回）
    __centerActiveInWeekSoon();
    return;
  }

  // B) 従来の「フォーカス前の週」に戻す（戻るボタン等）
  if (picker instanceof HTMLInputElement && window.__weekStartBeforeFocus) {
    // __weekStartBeforeFocus は "YYYY-MM-DD" 想定
    const [Y,M,D] = String(window.__weekStartBeforeFocus).split('-').map(Number);
    const mon = new Date(Y, (M||1)-1, D||1);
    window.currentMonday = mon;
    picker.value = ymd(mon);
    picker.dispatchEvent(new Event('change', { bubbles: true }));
    // 週ビュー描画完了後に中央寄せ（後追いで複数回）
    __centerActiveInWeekSoon();	
  }
  window.__weekStartBeforeFocus = null;
}

// 固定ヘッダー高（常に差し引く）
function __getHeaderOffsetPx(){
  const topbar = document.querySelector('.topbar');
  return topbar ? Math.ceil(topbar.getBoundingClientRect().height) : 0;
}

// スクロール親
function __getScrollParent(node){
  let p = node?.parentElement;
  while (p && p !== document.body){
    const s = getComputedStyle(p);
    const ovY = s.overflowY || s.overflow;
    if (/(auto|scroll)/.test(ovY) && p.scrollHeight > p.clientHeight) return p;
    p = p.parentElement;
  }
  return document.scrollingElement || document.documentElement;
}

function applyUndoWithFocus(){
  const preferKey = window.lastSelectedKey || null;
  const wasFocus = document.body.classList.contains('dayFocus');

  // 既存の undo を実行（内部で render() していてもOK）
  try { if (typeof undo === 'function') undo(); } catch{}

  // 描画の一本化：フォーカス中は必ずフォーカス維持で、週表示は念のため render
  if (wasFocus) {
    reRenderPreservingFocus(preferKey);
  } else {
    try { render(); } catch{}
  }
}

function applyRedoWithFocus(){
  const preferKey = window.lastSelectedKey || null;
  const wasFocus = document.body.classList.contains('dayFocus');

  try { if (typeof redo === 'function') redo(); } catch{}

  if (wasFocus) {
    reRenderPreservingFocus(preferKey);
  } else {
    try { render(); } catch{}
  }
}

// 週→日 再入用のユーティリティ
function __findDayByISO(iso){
  if (!iso) return null;
  const esc = (window.CSS?.escape ? CSS.escape(iso) : iso);
  // data-day="YYYY-MM-DD" を優先。なければ見出しテキストから一致を探す
  return document.querySelector(`.day[data-day="${esc}"]`)
      || Array.from(document.querySelectorAll('.day'))
           .find(d => (d.querySelector('.day-header-date')?.textContent || '').includes(iso));
}

// フォーカス維持・完全復元（ISO優先）
 function reRenderPreservingFocus(preferKey){
   const inFocus = document.body.classList.contains('dayFocus');
 
   // ① フォーカス日を“UIの状態”から取得（pickerより window.focusDate を信用）
   let focusISO = inFocus ? (window.focusDate || null) : null;
   if (!focusISO && inFocus) {
     const txt = document.querySelector('.day[data-focus="true"] .day-header-date')?.textContent || '';
     const m = txt && txt.match(/(\d{4})\/(\d{2})\/(\d{2})/);
     if (m) focusISO = `${m[1]}-${m[2]}-${m[3]}`;
   }
 
   // ② フォーカスは解除せず、そのまま週を再描画
   preserveScrollWhile(()=> render());
 
   // 週表示ならここで終わり
   if (!inFocus) return;
 
   // ③ ピッカーを当日に戻す（change抑止）。週ナビ関数は呼ばない
   if (focusISO){
     const picker = document.getElementById('weekPicker');
     if (picker){
       const prev = window.__suppressWeekChange;
       window.__suppressWeekChange = true;
       picker.value = focusISO;
       window.__suppressWeekChange = prev;
     }
     // UI基準日も維持
     window.focusDate = focusISO;
   }
 
   // ④ 当日の .day を残して他日を隠す（フォーカス表示を復元）
   if (typeof enforceFocusView === 'function') enforceFocusView();
 
   // ⑤ スロット再選択：preferKey > lastSelectedKey > 当日先頭
   const dayEl = __findDayByISO?.(focusISO) || document.querySelector('body.dayFocus .day[data-focus="true"]');
   const pickByKey = (key)=>{
     if (!key) return null;
     const sel = `.slot[data-key="${(window.CSS?.escape ? CSS.escape(key) : key)}"]`;
     return (dayEl && dayEl.querySelector(sel)) || document.querySelector(sel);
   };
   const target = pickByKey(preferKey) || pickByKey(window.lastSelectedKey);
   if (target) setActiveSlot(target); else if (dayEl) ensureInitialSelectionForDay(dayEl);
 }



// Escで解除（1回だけバインド）
if (!window.__focusEscBound){
  document.addEventListener('keydown', (e)=>{
      if (e.key === 'Escape'){
        // モーダルが開いているときはフォーカス解除に進まない（<dialog> のESCデフォルト閉じを優先）
        const modalOpen = document.querySelector('dialog[open]');
        if (modalOpen) return;
        if (document.body.classList.contains('dayFocus')){
          e.preventDefault();
          exitDayFocus();
        }
      }
  }, true);
  window.__focusEscBound = true;
}


  // ===== 時刻オーバーライド（週単位） =====
  function loadTimeOverrides(week){ try{ return JSON.parse(localStorage.getItem('timeovr_'+weekKey(week))) || {}; }catch(e){ return {}; } }
  function saveTimeOverrides(week, obj){ localStorage.setItem('timeovr_'+weekKey(week), JSON.stringify(obj||{})); }
  function setTimeOverride(week, dayKey, section, idx, hhmm){ const store = loadTimeOverrides(week); const key = `${dayKey}|${section}`; if(!store[key]) store[key] = {}; store[key][idx] = hhmm; saveTimeOverrides(week, store); }
  function clearTimeOverrideFrom(week, dayKey, section, idx){ const store = loadTimeOverrides(week); const key = `${dayKey}|${section}`; if(store[key]){ for(const k of Object.keys(store[key])){ if(Number(k) >= idx) delete store[key][k]; } if(Object.keys(store[key]).length===0) delete store[key]; saveTimeOverrides(week, store); } }
  function clearTimeOverrideAll(week, dayKey, section){ const store = loadTimeOverrides(week); const key = `${dayKey}|${section}`; if(store[key]){ delete store[key]; saveTimeOverrides(week, store); } }
  function getSlotTimeHHMMEx(baseHHMM, week, dayKey, section, idx){ let store = {}; try { store = JSON.parse(localStorage.getItem('timeovr_' + weekKey(week))) || {}; } catch(_) {} const table = store[`${dayKey}|${section}`] || {}; let anchorIdx = -1, anchorHHMM = baseHHMM; for (const k of Object.keys(table)){ const n = Number(k); if (Number.isFinite(n) && n <= idx && n > anchorIdx){ anchorIdx = n; anchorHHMM = table[k]; } } const steps = idx - (anchorIdx >= 0 ? anchorIdx : 0); return addMinutes(anchorHHMM, steps * 20); }
function debugTimeOverrides(label){
  try {
    const raw = localStorage.getItem('timeovr_' + weekKey(currentMonday));
    const store = raw ? JSON.parse(raw) : {};
    console.log('==== timeovr DEBUG:', label, '====');
    console.log(JSON.stringify(store, null, 2));
  } catch(e){
    console.warn('debugTimeOverrides failed:', e);
  }
}

// ★スロット削除時に、所要時間アンカーを片付ける共通ヘルパー
function cleanupTimeOverrideOnDelete(firstKey, store){
  try{
    if (!firstKey) return;

    let key = firstKey;
    let rec = store[key];

    // tail を指定して消すパターンにも対応（tail.head に head のキーが入っている前提）
    if (rec && rec.tail && rec.head){
      key = rec.head;
      rec = store[key] || rec; // 念のため
    }

    const p = parseKey(key);   // { d, day, section, idx }
    if (!p) return;

    // head なら span を見る。なければ単枠扱いで 1
    const span = (rec && rec.head)
      ? Math.max(1, Number(rec.span || 1))
      : 1;

    // 「削除するブロックの末尾の次」から後ろのアンカーをクリア
    clearTimeOverrideFrom(
      currentMonday,
      p.day,         // Mon / Tue ...
      p.section,     // 0,1,2...
      p.idx + span   // 末尾 idx + 1
    );
  }catch(e){
    console.warn('cleanupTimeOverrideOnDelete failed:', e);
  }
}

function autoRebuildTimeOverridesForSectionAfterDelete(anyKey, store){
  try{
    if (!anyKey) return;
    const { day, section } = parseKey(anyKey);
    if (!day || section == null) return;

    // 1) この day/section のアンカーをいったん全削除
    clearTimeOverrideFrom(
      currentMonday,
      day,
      section,
      0   // idx=0 から先を全部消すイメージ
    );

    // 2) 同じ day/section の「tail 以外」のレコードを idx 昇順に取得
    const entries = Object.keys(store)
      .map(k => ({ key: k, info: parseKey(k), rec: store[k] }))
      .filter(o =>
        o.rec &&
        !o.rec.tail &&
        o.info.day === day &&
        o.info.section === section
      )
      .sort((a, b) => a.info.idx - b.info.idx);

    if (!entries.length) return;

    // 3) 各 head / duration 付き枠に対して、元のロジックと同じ方式でアンカーを張り直す
    for (const { key, rec } of entries){
      const hasDuration = Number(rec.duration || 0) > 0;
      const isMergeHead = !!rec.head && Math.max(1, Number(rec.span || 1)) > 1;

      // duration が入っている枠、または結合 head だけが「押し出しの起点」になる
      if (hasDuration || isMergeHead){
        applyDurationAnchorForHead(key, store);
      }
    }

    if (typeof debugTimeOverrides === 'function'){
      debugTimeOverrides('after autoRebuildTimeOverridesForSectionAfterDelete');
    }
  }catch(e){
    console.warn('autoRebuildTimeOverridesForSectionAfterDelete failed:', e);
  }
}


  // ===== 休止情報 =====
  function loadDayOff(week){ try { return JSON.parse(localStorage.getItem('dayoff_'+weekKey(week))) || {}; } catch(_) { return {}; } }
  function saveDayOffRaw(week, obj){ localStorage.setItem('dayoff_'+weekKey(week), JSON.stringify(obj||{})); }
  function setDayOff(week, dayKey, patch, opts){ const map = loadDayOff(week); const cur = map[dayKey] || {}; map[dayKey] = Object.assign({}, cur, patch||{}); try{ if(opts?.snapshot){ undoStack.push(snapshotState()); redoStack.length=0; } }catch(_){} saveDayOffRaw(week, map); }
  function clearDayOffForDay(week, dayKey, opts){ const map = loadDayOff(week); if (map && map[dayKey] !== undefined) { try{ if(opts?.snapshot){ undoStack.push(snapshotState()); redoStack.length=0; } }catch(_){} delete map[dayKey]; saveDayOffRaw(week, map); } }

  // ===== 個別枠の「臨時化（緊急）」 =====
  function loadEmerg(week){ try{ return JSON.parse(localStorage.getItem('emerg_' + weekKey(week))) || {}; } catch(_){ return {}; } }
  function saveEmergRaw(week, obj){ localStorage.setItem('emerg_' + weekKey(week), JSON.stringify(obj || {})); }
  function setEmergency(week, slotKey, enabled, opts){ const map = loadEmerg(week); if (enabled) map[slotKey] = true; else delete map[slotKey]; try{ if(opts?.snapshot){ undoStack.push(snapshotState()); redoStack.length=0; } }catch(_){} saveEmergRaw(week, map); }

  // ===== 枠数オーバーライド（臨時枠） =====
  function loadSlotOverrides(week){ try{ return JSON.parse(localStorage.getItem('slotovr_'+weekKey(week))) || {}; }catch(e){ return {}; } }
  function saveSlotOverrides(week, obj){ localStorage.setItem('slotovr_'+weekKey(week), JSON.stringify(obj||{})); }
  function getSectionKey(dayKey, section){ return `${dayKey}|${section}`; }
  function ensureSlotOvrShape(ovr, dayKey, section){ const key = getSectionKey(dayKey, section); if (!ovr[key]) ovr[key] = {}; const s = ovr[key]; if (typeof s.extraHead !== 'number') s.extraHead = 0; if (typeof s.extraTail !== 'number') s.extraTail = 0; if (!Array.isArray(s.inserts)) s.inserts = []; s.inserts = Array.from(new Set(s.inserts.filter(n=>Number.isInteger(n) && n>=0))).sort((a,b)=>a-b); return s; }
  function getSectionOvr(week, dayKey, section){ const o = loadSlotOverrides(week) || {}; return ensureSlotOvrShape(o, dayKey, section); }
function resetSlotLayoutForDay(week, dayKey, opts = {}) {
   const ovr = loadSlotOverrides(week) || {};

  // その日の全セクション（例: "Fri|0","Fri|1",...）を削除
  const prefix = `${dayKey}|`;
  let changed = false;
  Object.keys(ovr).forEach(k => {
    if (k.startsWith(prefix)) { delete ovr[k]; changed = true; }
  });
  if (!changed) return;

  // 保存
  saveSlotOverrides(week, ovr);

  // オプションで即反映
   if (opts.snapshot) {
     // フォーカス中でも週表示でも正しく復帰
     if (document.body.classList.contains('dayFocus')) {
       reRenderPreservingFocus();
     } else {
       render();
     }
   }
}

  function setSectionOvr(week, dayKey, section, patch){ const all = loadSlotOverrides(week) || {}; const s = ensureSlotOvrShape(all, dayKey, section); Object.assign(s, patch); saveSlotOverrides(week, all); }
  function getExtraTailSlots(week, dayKey, section){ return getSectionOvr(week, dayKey, section).extraTail|0; }
  function setExtraTailSlots(week, dayKey, section, n){ const v = Math.max(0, Number(n)||0); setSectionOvr(week, dayKey, section, { extraTail: v }); }
  function addExtraTailSlot(week, dayKey, section, n=1){ const s = getSectionOvr(week, dayKey, section); setSectionOvr(week, dayKey, section, { extraTail: s.extraTail + (Number(n)||0) }); }
  function removeExtraTailSlot(week, dayKey, section){ const cur = getExtraTailSlots(week, dayKey, section); if(cur > 0){ setExtraTailSlots(week, dayKey, section, cur - 1); } }
  function getSectionLayout(week, dayKey, section, baseCount){ const s = getSectionOvr(week, dayKey, section); const extraHead = s.extraHead|0; const extraTail = s.extraTail|0; const inserts = Array.from(new Set(s.inserts)).sort((a,b)=>a-b); const total = extraHead + baseCount + inserts.length + extraTail; function isTemp(idx){ if (idx < extraHead) return true; if (idx >= extraHead + baseCount + inserts.length) return true; const posInBody = idx - extraHead; return inserts.includes(posInBody); } function toBaseIndex(idx){ if (isTemp(idx)) return -1; const posInBody = idx - extraHead; const leftInserts = inserts.filter(n => n < posInBody).length; return posInBody - leftInserts; } return { total, isTemp, toBaseIndex, extraHead, extraTail, inserts }; }
  // 指定 day / section の「idx >= fromIdx」のレコードを、delta 分だけ idx シフト
  function shiftSectionRecordsForTempInsert(week, dayKey, section, fromIdx, delta){
    if (!delta) return;

    const store = loadWeek(week) || {};

    // 対象 day / section で idx >= fromIdx のものだけ集める
    const targets = Object.keys(store)
      .map(key => ({ key, info: parseKey(key) }))
      .filter(o =>
        o.info.day === dayKey &&
        o.info.section === section &&
        o.info.idx >= fromIdx
      );

    if (!targets.length) return;

    // 後ろから前へずらす（キー衝突を防ぐ）
    targets.sort((a, b) => b.info.idx - a.info.idx);

    for (const { key, info } of targets){
      const rec = store[key];
      delete store[key];

      const meta = { ...info, idx: info.idx + delta };
      const newKey = slotKey(meta);
      store[newKey] = rec;
    }

    // schedule_ を保存
    saveWeek(week, store);

  // ★ この day / section の duration アンカーを「最初から」組み直す
  if (typeof rebuildDurationAnchorsForDaySection === 'function'){
    rebuildDurationAnchorsForDaySection(dayKey, section, store);    }
  }

  function insertTempBefore(week, dayKey, section, displayIndex){
    const all = loadSlotOverrides(week) || {};
    const s   = ensureSlotOvrShape(all, dayKey, section);

    // 先頭より前に挿入するケース
    if (displayIndex <= 0){
      // 見た目上の「頭出し」枠を 1 つ増やす
      s.extraHead += 1;
      saveSlotOverrides(week, all);

      // ★ データ側も idx 0 以降を 1 つ下に押し出す（データが無ければ何もしない）
      shiftSectionRecordsForTempInsert(week, dayKey, section, 0, +1);

      return;
    }

    // それ以外（本文中に挿入）のケース
  const layout    = getSectionLayout(week, dayKey, section, CONFIG[dayKey][section].slots);
  const posInBody = Math.max(0, displayIndex - layout.extraHead);

  // ★ すでに存在する臨時枠の位置も、挿入位置以降は 1 つ後ろにずらす
  if (Array.isArray(s.inserts) && s.inserts.length){
    s.inserts = s.inserts.map(n => (n >= posInBody ? n + 1 : n));
  }

  if (!s.inserts.includes(posInBody)){
    s.inserts.push(posInBody);
    s.inserts = Array.from(new Set(s.inserts)).sort((a,b)=>a-b);
    saveSlotOverrides(week, all);

    // 実データも同じ fromIdx 以降を 1 つ押し出す
    shiftSectionRecordsForTempInsert(week, dayKey, section, posInBody, +1);
  }
  }
  // 結合枠にも対応した「この枠の後に臨時枠を挿入」
function insertTempAfter(week, dayKey, section, displayIndex){
  const all       = loadSlotOverrides(week) || {};
  const s         = ensureSlotOvrShape(all, dayKey, section);
  const baseCount = CONFIG[dayKey][section].slots;
  const layout    = getSectionLayout(week, dayKey, section, baseCount);

  // クリックされた表示 index に対応する「ベース index」（0,1,2,...）
  const baseIdx = Math.max(0, displayIndex - layout.extraHead);

  // 対象スロットの span を取得（結合枠なら span>1）
  const store = loadWeek(week) || {};
  let span    = 1;

  for (const key of Object.keys(store)){
    const info = parseKey(key);   // { d, day, section, idx }
    if (info.day === dayKey && info.section === section && info.idx === baseIdx){
      const rec     = store[key];
      const recSpan = Number(rec && rec.span);
      if (rec && !rec.tail && Number.isFinite(recSpan) && recSpan > 1){
        span = recSpan;          // 結合 head の span を採用
      }
      break;
    }
  }

  // ★ 結合枠全体の「後ろ」に挿入したいので、baseIdx + span を挿入位置とする
  const insertAt = baseIdx + span;

  // 既存の臨時枠インデックスで、挿入位置以降のものは 1 つ後ろへずらす
  if (Array.isArray(s.inserts) && s.inserts.length){
    s.inserts = s.inserts.map(n => (n >= insertAt ? n + 1 : n));
  }

  // 今回の挿入位置を追加（重複は避けてソート）
  if (!s.inserts.includes(insertAt)){
    s.inserts.push(insertAt);
    s.inserts = Array.from(new Set(s.inserts)).sort((a,b)=> a - b);
  }

  // レイアウトオーバーライドを保存
  saveSlotOverrides(week, all);

  // 実データ（schedule_）を、insertAt 以降 1 コマ分後ろへ押し出す
  // → その後 rebuildDurationAnchorsForDaySection により結合枠の時間も再計算される
  shiftSectionRecordsForTempInsert(week, dayKey, section, insertAt, +1);
}

  function removeTempAt(week, dayKey, section, displayIndex){
    const all = loadSlotOverrides(week) || {};
    const s = ensureSlotOvrShape(all, dayKey, section);
    const baseCount = CONFIG[dayKey][section].slots;
    const layout = getSectionLayout(week, dayKey, section, baseCount);

    if (!layout.isTemp(displayIndex)) return;

    if (displayIndex >= layout.total - 1 && s.extraTail > 0){
      s.extraTail -= 1;
      saveSlotOverrides(week, all);
      return;
    }

    if (displayIndex < s.extraHead && s.extraHead > 0){
      s.extraHead -= 1;
      saveSlotOverrides(week, all);
	  
	  // ★ 先頭臨時枠を削除した場合も、idx=0 以降を詰める必要がある
	  slideSectionDataUpFromIndex(week, dayKey, section, 0);
	  
      return;
    }

    // ★ 本体の途中に挿入されていた臨時枠を削除するケース
  const posInBody = displayIndex - s.extraHead;
  const i = s.inserts.indexOf(posInBody);
  if (i >= 0){
    // 1) レイアウト上の臨時枠情報を削除
    s.inserts.splice(i, 1);
    saveSlotOverrides(week, all);

    // 2) この臨時枠が「挟まっていた位置」そのものが baseIdx なので、
    //    その位置以降のデータを 1 コマ前に詰める
    const baseIdx = posInBody;
    slideSectionDataUpFromIndex(week, dayKey, section, baseIdx);
  }
  }



// ★ 臨時枠を削除したときに、
//    その直後（baseIdx）以降のデータを、
//    「その日・そのセクションで実際に存在する一番最後の idx」まで
//    すべて 1 コマずつ前に詰める。
//    → 一番最後の idx の枠だけ空になる（誰も消えない）。
function slideSectionDataUpFromIndex(week, dayKey, section, baseIdx){
  const store = loadWeek(week) || {};

  // 1) この day / section で実際に存在する最大 idx を求める
  let maxIdx = -1;
  let dISOForKeys = null;

  for (const key of Object.keys(store)){
    const p = parseKey(key);  // { d, day, section, idx }
    if (!p) continue;
    if (p.day !== dayKey || p.section !== section) continue;
    if (p.idx > maxIdx){
      maxIdx = p.idx;
      dISOForKeys = p.d;  // 実際の d を使う
    }
  }

  // データがない／詰める範囲が存在しない場合
  if (maxIdx < 0 || baseIdx > maxIdx) {
    if (typeof rebuildDurationAnchorsForDaySection === 'function'){
      rebuildDurationAnchorsForDaySection(dayKey, section, store);
    }
    return;
  }

  // dISO は store に実際に入っているキーから取得したものを使う
  const dISO = dISOForKeys;

  // 2) baseIdx 〜 maxIdx-1 までを 1 コマずつ前に詰める
  //    例：baseIdx=2 のとき
  //      idx=2 <- 3
  //      idx=3 <- 4
  //      ...
  //      idx=maxIdx-1 <- maxIdx
  for (let idx = baseIdx; idx < maxIdx; idx++){
    const fromKey = `${dISO}|${dayKey}|${section}|${idx+1}`;
    const toKey   = `${dISO}|${dayKey}|${section}|${idx}`;

    if (store[fromKey]){
      store[toKey] = store[fromKey];
    } else {
      delete store[toKey];
    }
  }

  // 3) いちばん最後の idx（maxIdx）は、前に詰めた結果「余り」になるので空にする
  const lastKey = `${dISO}|${dayKey}|${section}|${maxIdx}`;
  delete store[lastKey];

  saveWeek(week, store);

  if (typeof rebuildDurationAnchorsForDaySection === 'function'){
    rebuildDurationAnchorsForDaySection(dayKey, section, store);
  }
}



  // ===== Undo / Redo =====
  let undoStack = [];
  let redoStack = [];

// === 結合→即編集用の Undo バッチが開いているかどうか ===
let mergeEditBatchOpen = false;

  // === Undo履歴のバッチング用フラグ ===
  let undoBatchDepth = 0;
  let undoBatchSnapshot = null;

  function beginUndoBatch(){
    if (undoBatchDepth === 0){
      try{
        undoBatchSnapshot = snapshotState();  // バッチ開始時の状態を1回だけ保存
      }catch(e){
        undoBatchSnapshot = null;
      }
    }
    undoBatchDepth++;
  }

  function endUndoBatch(){
    if (undoBatchDepth === 0) return;
    undoBatchDepth--;
    if (undoBatchDepth === 0 && undoBatchSnapshot){
      // バッチの最初の状態を1ステップとして積む
      undoStack.push(undoBatchSnapshot);
      redoStack.length = 0;
      undoBatchSnapshot = null;
    }
  }

  function inUndoBatch(){
    return undoBatchDepth > 0;
  }

  function snapshotState(){
    return {
      week:   loadWeek(currentMonday),             // ← ★ 本体スケジュール
      timeovr: loadTimeOverrides(currentMonday),   // 所要時間アンカー
      slotovr: loadSlotOverrides(currentMonday),
      notes:   loadNotes(currentMonday),
      dayoff:  loadDayOff(currentMonday),
      emerg:   loadEmerg(currentMonday)
    };
  }
  function restoreState(snap){
    if(!snap) return;
    const wk = weekKey(currentMonday);
 
    // ★ スケジュール本体を戻す
    localStorage.setItem('schedule_' + wk, JSON.stringify(snap.week || {}));
 
    // 所要時間アンカーやその他の拡張テーブルも戻す
    localStorage.setItem('timeovr_' + wk, JSON.stringify(snap.timeovr || {}));
    localStorage.setItem('slotovr_' + wk, JSON.stringify(snap.slotovr || {}));
    localStorage.setItem('notes_'  + wk, JSON.stringify(snap.notes  || {}));
    localStorage.setItem('dayoff_' + wk, JSON.stringify(snap.dayoff || {}));
    localStorage.setItem('emerg_'  + wk, JSON.stringify(snap.emerg  || {}));
  }
const __saveTimeOverrides = saveTimeOverrides;
saveTimeOverrides = function(week, obj){
  try{
    // ★ バッチ中はここで snapshot を積まない
    if (!inUndoBatch()){
      undoStack.push(snapshotState());
      redoStack.length = 0;
    }
  }catch(e){}
  __saveTimeOverrides(week, obj);
};

const __saveSlotOverrides = saveSlotOverrides;
saveSlotOverrides = function(week, obj){
  try{
    if (!inUndoBatch()){
      undoStack.push(snapshotState());
      redoStack.length = 0;
    }
  }catch(e){}
  __saveSlotOverrides(week, obj);
};
// ⭐⭐⭐ ← ここに追加（saveWeek のラップ）
//
const __saveWeek = saveWeek;
saveWeek = function(week, obj){
  try{
    if (!inUndoBatch()){        // ★ バッチ中は積まない
      undoStack.push(snapshotState());
      redoStack.length = 0;
    }
  }catch(e){}

  __saveWeek(week, obj);        // 本来の saveWeek
};
  function undo(){ if(undoStack.length === 0){ alert('戻せる操作がありません'); return; } const prev = undoStack.pop(); const cur  = snapshotState(); redoStack.push(cur); restoreState(prev); render(); }
  function redo(){ if(redoStack.length === 0){ alert('やり直し可能な操作がありません'); return; } const next = redoStack.pop(); const cur  = snapshotState(); undoStack.push(cur); restoreState(next); render(); }
  document.getElementById('undoBtn')?.addEventListener('click', undo);
  document.getElementById('redoBtn')?.addEventListener('click', redo);
  function isTypingContext(e){ const el = e.target; const tag = (el?.tagName || '').toLowerCase(); return el?.isContentEditable || tag === 'input' || tag === 'textarea' || tag === 'select'; }
document.addEventListener('keydown', (e)=>{
  if(isTypingContext(e)) return;
  const k = e.key.toLowerCase(); 

  if((e.ctrlKey || e.metaKey) && !e.shiftKey && k === 'z'){        // Undo
    e.preventDefault();
    applyUndoWithFocus();

  }else if((e.ctrlKey || e.metaKey) && (k === 'y' || (e.shiftKey && k === 'z'))){ // Redo
    e.preventDefault();
    applyRedoWithFocus();

  }else if ((e.ctrlKey || e.metaKey) && !e.shiftKey && k === 'm'){ // ★ 複数空枠 → 結合枠
    e.preventDefault();
    createMergeFromMultiSelection();
  }
}, true);



// ===== 編集ロック判定（祝日/休止→編集不可。臨時/緊急は除外） =====
function isSlotLockedForEdit(slotEl){
  if (!slotEl) return true;                       // 要素が無ければ安全側で不可
  if (slotEl.classList.contains('emergency-slot')) return false; // 緊急は常に可
  if (slotEl.classList.contains('temp-slot'))      return false; // 臨時（週末など）も可

  // セクション/時刻による休止 → .off が付く
  if (slotEl.classList.contains('off')) return true;

  // 祝日（.day に is-holiday が付く）は編集不可
  const day = slotEl.closest('.day');
  if (day && day.classList.contains('is-holiday')) return true;

  return false;
}

  // ===== レイアウト切替 =====
  const MODE_KEY = 'layoutMode';
  let layoutMode = localStorage.getItem(MODE_KEY) || '2';
function applyLayout(mode){
  // dayFocus 中はレイアウト変更を無効化
  if (document.body.classList.contains('dayFocus')) return;

  layoutMode = mode;
  document.body.classList.remove('fiveCols','fourCols');
  if(mode==='5') document.body.classList.add('fiveCols');
  if(mode==='4') document.body.classList.add('fourCols');
  localStorage.setItem(MODE_KEY, layoutMode);
  render();

  // ★ レイアウト変更直後にも、週移動と同様に「アクティブ確定＋中央寄せ」を実行
  window.__postWeekMoveCenter?.();
}


  mode2?.addEventListener('click', ()=> applyLayout('2'));
  mode4?.addEventListener('click', ()=> applyLayout('4'));
  mode5?.addEventListener('click', ()=> applyLayout('5'));

// === Ctrl+2 / Ctrl+4 / Ctrl+5 でレイアウト切替（2列/4列/5列） ===
(function(){
  if (window.__bindCtrlLayout) return;
  window.__bindCtrlLayout = true;

  const isEditable = (t)=>{
    const tag = t?.tagName?.toLowerCase();
    return tag === 'input' || tag === 'textarea' || t?.isContentEditable;
  };
  const isDialogOpen = ()=>{
    const ed = document.getElementById('editor');
    const st = document.getElementById('settings');
    return !!((ed && (ed.open || ed.classList?.contains('is-open'))) ||
              (st && (st.open || st.classList?.contains('is-open'))));
  };

  document.addEventListener('keydown', (e)=>{
    if (!e.ctrlKey) return;
    if (isEditable(e.target) || isDialogOpen()) return;

    // 数字キー（上段/テンキー両対応）
    const k = e.key;                     // '2','4','5' など
    const c = e.code;                    // 'Digit2','Numpad2' など
    const is2 = (k === '2' || c === 'Digit2' || c === 'Numpad2');
    const is4 = (k === '4' || c === 'Digit4' || c === 'Numpad4');
    const is5 = (k === '5' || c === 'Digit5' || c === 'Numpad5');

    if (is2 || is4 || is5) {
      e.preventDefault(); e.stopImmediatePropagation();
      if (typeof window.applyLayout !== 'function') return;
      if (is2) return window.applyLayout('2');
      if (is4) return window.applyLayout('4');
      if (is5) return window.applyLayout('5');
    }
  }, {capture:true});
})();

  // ===== 祝日（オフライン自動計算＋上書き） =====
  function ymd(d){ return d.toISOString().slice(0,10); }
  function isoToDate(iso){ const [Y,M,D]=iso.split('-').map(Number); return new Date(Y, M-1, D); }
  function vernalEquinoxDay(Y){ return Math.floor(20.8431 + 0.242194*(Y-1980) - Math.floor((Y-1980)/4)); }
  function autumnalEquinoxDay(Y){ return Math.floor(23.2488 + 0.242194*(Y-1980) - Math.floor((Y-1980)/4)); }
  function nthWeekdayOfMonth(Y, M, weekday, n){ const d = new Date(Y, M-1, 1); const first = d.getDay(); const delta = (weekday - first + 7) % 7; return 1 + delta + 7*(n-1); }
  function genHolidaysAuto(year){ const H = new Set(); const push = (m, d)=> H.add(`${year}-${String(m).padStart(2,'0')}-${String(d).padStart(2,'0')}`); push(1,1); push(2,11); if(year >= 2020) push(2,23); push(4,29); push(5,3); push(5,4); push(5,5); push(8,11); push(11,3); push(11,23); const MON=1,SUN=0; push(1, nthWeekdayOfMonth(year, 1, MON, 2)); push(7, nthWeekdayOfMonth(year, 7, MON, 3)); push(9, nthWeekdayOfMonth(year, 9, MON, 3)); push(10, nthWeekdayOfMonth(year,10, MON, 2)); push(3, vernalEquinoxDay(year)); push(9, autumnalEquinoxDay(year)); const isHoliday = (iso)=> H.has(iso); const addSubstitute = (isoStart)=>{ let d = isoToDate(isoStart); do { d.setDate(d.getDate()+1); } while (d.getDay() === SUN || isHoliday(ymd(d))); H.add(ymd(d)); }; for(const iso of Array.from(H)){ const dt = isoToDate(iso); if (dt.getDay() === SUN) addSubstitute(iso); } const span = (m)=> new Date(year, m, 0).getDate(); for(let m=1;m<=12;m++){ for(let d=2; d<span(m-1); d++){ const cur = `${year}-${String(m).padStart(2,'0')}-${String(d).padStart(2,'0')}`; const prev = ymd(new Date(year, m-1, d-1)); const next = ymd(new Date(year, m-1, d+1)); const wd = isoToDate(cur).getDay(); if (!H.has(cur) && H.has(prev) && H.has(next) && wd !== SUN){ H.add(cur); } } } return H; }
  function loadHolidayAuto(year){ try{ const s = localStorage.getItem('holidays_auto_'+year); return s? new Set(JSON.parse(s)) : new Set(); }catch(_){ return new Set(); }
  }
  function saveHolidayAuto(year, set){ localStorage.setItem('holidays_auto_'+year, JSON.stringify(Array.from(set||[]))); }
  function ensureHolidayAuto(year){ let s = loadHolidayAuto(year); if(!s || s.size===0){ s = genHolidaysAuto(year); saveHolidayAuto(year, s); } return s; }
  function loadHolidayPatch(year){ try{ return JSON.parse(localStorage.getItem('holidays_patch_'+year))||{}; }catch(_){ return {}; } }
  function loadHolidayManual(){ try{ return JSON.parse(localStorage.getItem('holidays_manual'))||{}; }catch(_){ return {}; } }
  function saveHolidayManual(obj){ localStorage.setItem('holidays_manual', JSON.stringify(obj||{})); }
  function isHolidayISO(iso){ const Y = Number(iso.slice(0,4)); const manual = loadHolidayManual(); if (manual[iso] === true)  return true; if (manual[iso] === false) return false; const patch = loadHolidayPatch(Y); if (patch[iso]) return true; const auto = ensureHolidayAuto(Y); return auto.has(iso); }
  function toggleHolidayManual(iso, toFlag){ const m = loadHolidayManual(); m[iso] = toFlag; saveHolidayManual(m); }

  // ===== ノート =====
  function loadNotes(week){ try{ return JSON.parse(localStorage.getItem('notes_'+weekKey(week))) || {}; }catch(e){ return {}; } }
  function getDayNote(week, dayKey){ const obj = loadNotes(week); return String(obj[dayKey]||''); }
  function setDayNote(week, dayKey, text, opts){ const o = loadNotes(week); o[dayKey] = String(text||''); try{ if(opts&&opts.snapshot){ undoStack.push(snapshotState()); redoStack.length=0; } }catch(_){ } localStorage.setItem('notes_'+weekKey(week), JSON.stringify(o)); }

 // 描画後の「青枠復元」専用：スクロールは一切させない
 function restoreSelection(){
   try{
    // ★ 先頭選択を予約しているときは、旧選択の復元をスキップ
    if (window.__selectFirstOnNextRender) return;   
     if (!window.lastSelectedKey) return;
     const el = document.querySelector(`.slot[data-key="${window.lastSelectedKey}"]`);
     if (el) {
       // ★ 必ずスクロール抑止
       setActiveSlot(el, { scroll: false });
       // ★ ここでは絶対に scrollIntoView を呼ばない
     } else {
       setActiveSlot(null);
     }
   }catch(_){}
 }

// 表現形テキストを枠内に2行までで収める（フォントサイズは固定）
function autoFitContentLines(){
  // もう何もしない（CSSだけに任せる）
}



function applyGaColoring(){
  const st = loadWeek(currentMonday);
  document.querySelectorAll('.slot').forEach(el=>{
    const d = st[el.dataset.key];
    // tail は塗らず、head/単枠のみ色付け（方針どおり）
    if (d && d.ga && !d.tail) el.classList.add('ga-slot');
    else el.classList.remove('ga-slot');
  });
}


  // ===== 描画 =====
  function render(){

if (!window.__initialRenderDone) {
  window.__initialRenderDone = true;

  requestAnimationFrame(() => {
    requestAnimationFrame(() => {          // ← ２回遅延が必須
      const box = document.scrollingElement;
      if (box) box.scrollTop = 0;
    });
  });
}
　　applyDatalists(appLists);
   window.__setWeekdayFromISO?.(document.getElementById('weekPicker')?.value);
  if (document.body.classList.contains('dayFocus') && window.focusDate) {
    // フォーカス中はピッカーを当日に保つ（イベントは発火させない）
    window.__suppressWeekChange = true;
    weekPicker.value = window.focusDate;
    setTimeout(()=> window.__suppressWeekChange = false, 0);
  } else {
    weekPicker.value = dateISO(currentMonday);
  }
    leftCol.innerHTML=''; rightCol.innerHTML='';

    if(layoutMode==='5'){
      leftCol.appendChild(buildDay('Mon', 0));
      leftCol.appendChild(buildDay('Tue', 1));
      leftCol.appendChild(buildDay('Wed', 2));
      leftCol.appendChild(buildDay('Thu', 3));
      const friStack = document.createElement('div');
      friStack.className = 'dayStack';
      friStack.appendChild(buildDay('Fri', 4));
      friStack.appendChild(buildWeekend());
      leftCol.appendChild(friStack);
      restoreSelection();
　　　paintSlotsFromStore();
　　　autoFitContentLines();
      document.querySelectorAll('.slots').forEach(sl => applyMerges(sl, loadWeek(currentMonday)));
     applyGaColoring();
     // ★ 週表示のときだけ、描画完了後に1回だけスナップ（rAFでDOM確定を待つ）
     if (!document.body.classList.contains('dayFocus')) {
       requestAnimationFrame(()=> window.__centerActiveInWeekSoon?.());
     }
     return;
    }

    if(layoutMode==='4'){
      leftCol.appendChild(buildDay('Mon', 0));
      leftCol.appendChild(buildDay('Tue', 1));
      leftCol.appendChild(buildDayStack([
        ['Wed', 2, { combined: true }],
        ['Thu', 3, {}]
      ]));
      const friStack4 = document.createElement('div');
      friStack4.className = 'dayStack';
      friStack4.appendChild(buildDay('Fri', 4));
      friStack4.appendChild(buildWeekend());
      leftCol.appendChild(friStack4);
      restoreSelection();
　　　paintSlotsFromStore();
　　　autoFitContentLines();
      document.querySelectorAll('.slots').forEach(sl => applyMerges(sl, loadWeek(currentMonday)));
     applyGaColoring();
     if (!document.body.classList.contains('dayFocus')) {
       requestAnimationFrame(()=> window.__centerActiveInWeekSoon?.());
     }
     return;
    }

    leftCol.appendChild(buildDay('Mon', 0));
    leftCol.appendChild(buildDay('Tue', 1));
    leftCol.appendChild(buildDay('Wed', 2, { combined: true }));
    rightCol.appendChild(buildDay('Thu', 3));
    rightCol.appendChild(buildDay('Fri', 4));
    rightCol.appendChild(buildWeekend());
    restoreSelection();
　　paintSlotsFromStore();
　　autoFitContentLines();
    document.querySelectorAll('.slots').forEach(sl => applyMerges(sl, loadWeek(currentMonday)));
    applyGaColoring();
    enforceFocusView();

    // --- 曜日バッジ更新（フォーカス中は既に正しいので再更新しない）
    if (!document.body.classList.contains('dayFocus')) {
      const iso = document.getElementById('weekPicker')?.value;
      window.__setWeekdayFromISO?.(iso);
    }


// === 未選択なら週の最初の選択可能スロットを自動選択 ===
if (!document.body.classList.contains('dayFocus')) {
  const cur = document.querySelector('.slot.focused');
  if (!cur) {
    const days = Array.from(document.querySelectorAll('#schedule .day'));
    for (const d of days) {
      const first = window.findFirstSelectableInDay?.(d);
      if (first) {
        window.setActiveSlot?.(first, { scroll: false });
        break;
      }
    }
  }
}
// === 中央寄せ/最上部スナップ・フォーカス移譲 ===
if (!document.body.classList.contains('dayFocus')) {
  // ★ 週移動直後は「最上部スナップ」を優先（祝日寄せにも対応）
  requestAnimationFrame(()=> {
    if (window.__snapTopOnNextRender) {
      const iso = window.__snapTopTargetISO;
      window.__snapTopOnNextRender = false;
      window.__snapTopTargetISO    = null;
      // 対象の day を取得：まず「アクティブスロットの属する日」を優先
      let dayEl = null;
      const activeSlot =
        (window.getActiveSlot && window.getActiveSlot()) ||
        document.querySelector('.slot.focused');
      if (activeSlot) {
        dayEl = activeSlot.closest('.day');
      }
      // アクティブが取れない場合は、これまで通り ISO（月曜）→先頭 day をフォールバック
      if (!dayEl && typeof __findDayByISO === 'function' && iso) {
        dayEl = __findDayByISO(iso);
      }
      if (!dayEl) {
        dayEl = document.querySelector('#schedule .day'); // フォールバック：先頭（日=月）
      }
      // 祝日/休診なら翌営業日に寄せる（なければそのまま）
      if (typeof isOffDay === 'function' && dayEl) {
        if (isOffDay(dayEl)) {
          const days = Array.from(document.querySelectorAll('#schedule .day'));
          let i = days.indexOf(dayEl), found = dayEl;
          for (let j=i+1; j<days.length; j++){ if (!isOffDay(days[j])){ found = days[j]; break; } }
          dayEl = found || dayEl;
        }
      }
      // 即時スナップ（瞬間）：scroller計算して scrollTop を直接設定
      if (dayEl) {
        const scroller = (typeof __getScrollParent==='function') ? __getScrollParent(dayEl)
                         : (document.scrollingElement || document.documentElement);
        if (scroller) {
          const headerH = (typeof __getHeaderOffsetPx==='function') ? __getHeaderOffsetPx() : 0;
          const viewH   = ('clientHeight' in scroller ? scroller.clientHeight : window.innerHeight) - headerH;
          // dayEl の scroller 内オフセット
          const offsetTopWithin = (el, s)=>{
            let y=0,n=el; while(n && n!==s){ y += n.offsetTop||0; n = n.offsetParent; } return y;
          };
          const offset = offsetTopWithin(dayEl, scroller);
          const max    = Math.max(0, (scroller.scrollHeight - viewH));

          // ★ ④' ロジック：
          //   - ページ最上部（scrollTop=0）からでも dayEl が十分「画面内」に入るなら 0 スタート
          //   - そうでなければ dayEl をヘッダ直下までスナップ
          //   （2列表示で水曜が下段に行く週などでは、ここでスナップされる）
          const VISIBLE_RATIO = 0.7; // 画面高さの何割より下なら「見えにくい」とみなすかの閾値

          let nextTop;
          if (offset <= viewH * VISIBLE_RATIO) {
            // ページトップからでも十分見える位置 → 先頭からスタート
            nextTop = 0;
          } else {
            // ページトップでは dayEl がほぼ見えない → 従来どおりヘッダ直下までスナップ
            const target = offset - headerH;
            nextTop = Math.max(0, Math.min(Math.round(target), max));
          }

          scroller.scrollTop = nextTop;

          // ★ 予約があれば「今週の先頭“選択可能”枠」を青枠選択（スクロールはしない）
          if (window.__selectFirstOnNextRender) {
            window.__selectFirstOnNextRender = false;
            // 祝日寄せ後の dayEl から最初の編集可能スロットを取得
            const first = (typeof findFirstSelectableInDay==='function') ? findFirstSelectableInDay(dayEl)
                          : dayEl.querySelector('.slot');
            if (first && typeof setActiveSlot==='function') {
              // 複数選択はクリア（残骸対策）
              if (typeof multiSelected!=='undefined') {
                try { multiSelected.clear?.(); } catch(_) {}
                document.querySelectorAll('.slot.is-selected')?.forEach(el=> el.classList.remove('is-selected'));
              }
              setActiveSlot(first, { scroll:false });
              // ★ 旧復元系が後から被せないよう、lastSelectedKey を更新
              window.lastSelectedKey = first?.dataset?.key || null;
              if (window.__slotCursor) window.__slotCursor.activeSlotEl = first;
            }
          }		  
          return; // ▲ 最上部スナップを行ったので中央寄せはスキップ
        }
      }
    }
    // 通常は“瞬間センタースナップ”（微小移動スキップ込み）
    window.__centerActiveInWeekSoon?.();
  });
  const sched = document.getElementById('schedule');
  if (sched && !document.activeElement.closest('#schedule')) {
    sched.setAttribute('tabindex', '-1');
    sched.focus({ preventScroll: true });
  }
}
  }

  
  // === フォーカス時のスクロール維持ヘルパ ===
function __getScrollBox(){
  // フォーカス中はその日の .slots が第一候補
  const hit = document.querySelector('body.dayFocus .day[data-focus="true"] .slots');
  if (hit && hit.scrollHeight > hit.clientHeight) return hit;
  // 次に day 全体
  const day = document.querySelector('body.dayFocus .day[data-focus="true"]');
  if (day && day.scrollHeight > day.clientHeight) return day;
  // 週表示などは schedule かドキュメント
  const sch = document.getElementById('schedule');
  if (sch && sch.scrollHeight > sch.clientHeight) return sch;
  return document.scrollingElement || document.documentElement || document.body;
}

function preserveScrollWhile(doWork){
  const box = __getScrollBox();
  const top = box ? box.scrollTop : null;
  // 実行
  const ret = doWork();
  // 何度かフレーム跨ぎで復元（再レイアウト対策）
  const restore = ()=>{ if (box!=null && top!=null) box.scrollTop = top; };
  requestAnimationFrame(restore);
  requestAnimationFrame(()=> requestAnimationFrame(restore));
  return ret;
}

  // === フォーカスモード時の再表示補正 ===
function enforceFocusView(){

  if (!document.body.classList.contains('dayFocus') || !window.focusDate) return;

  const days = document.querySelectorAll('#schedule .day');
  let hit = null;
  days.forEach(d => {
    if (d.dataset && d.dataset.date === window.focusDate) {
      hit = d;
    }
  });
  if (!hit) {
    days.forEach(d => {
      const txt = d.querySelector('.day-header-date')?.textContent || '';
      const m = txt.match(/(\d{4})\/(\d{2})\/(\d{2})/);
      const iso = m ? `${m[1]}-${m[2]}-${m[3]}` : null;
      if (iso === window.focusDate) hit = d;
    });
  }
   if (!hit) return;

  days.forEach(d => {
    d.style.display = (d === hit) ? 'block' : 'none';
    if (d === hit) d.setAttribute('data-focus','true');
    else d.removeAttribute('data-focus');
  });
 
   // フォーカス表示が確定した時点のピッカー値で曜日バッジを更新
   const picker = document.getElementById('weekPicker');
   if (picker) window.__setWeekdayFromISO?.(picker.value); 
   window.__setWeekdayFromISO?.(window.focusDate);
}


  function buildDayStack(specList){
    const stack = document.createElement('div');
    stack.className = 'dayStack';
    for(const [dk, off, opt] of specList){ stack.appendChild(buildDay(dk, off, opt||{})); }
    return stack;
  }

  function buildDay(dayKey, offsetIdx, opt={}){
    const dayDate = addDays(currentMonday, offsetIdx);
    const wrap = document.createElement('section'); wrap.className = 'day';
    const iso = dateISO(dayDate);
    wrap.dataset.date = iso;             // ← ★これを追加（YYYY-MM-DD）
    wrap.dataset.dayKey = dayKey;        // ← ★曜日も持たせる（Mon/Tue/...）	
    const isHol = isHolidayISO(iso);
    if (isHol){ wrap.classList.add('is-holiday', 'is-off'); }

    const header = document.createElement('div'); header.className = 'day-header';
    const dateEl = document.createElement('div'); dateEl.className = 'day-header-date'; dateEl.textContent = formatDateJP(dayDate);
    const noteWrap = document.createElement('div'); noteWrap.className = 'day-note-inline';
    const noteInput = document.createElement('textarea'); noteInput.rows = 2; noteInput.className = 'day-note-input';
    noteWrap.appendChild(noteInput);
    noteInput.value = getDayNote(currentMonday, dayKey);
    noteInput.addEventListener('focus', ()=>{ try{ undoStack.push(snapshotState()); redoStack.length=0; }catch(_){}});
    noteInput.addEventListener('input', ()=>{ setDayNote(currentMonday, dayKey, noteInput.value); });
    header.appendChild(dateEl); header.appendChild(noteWrap); wrap.appendChild(header);
// 日付ヘッダー：ダブルクリックでフォーカスON/OFF
header.addEventListener('dblclick', (e)=>{
  // 既にフォーカス中なら解除、そうでなければこの日をフォーカス
  if (document.body.classList.contains('dayFocus')) {
    exitDayFocus();
  } else {
    enterDayFocus(wrap);
  }
});


    // 曜日ヘッダ 右クリックメニュー
    header.addEventListener('contextmenu', (e)=>{
      e.preventDefault(); e.stopPropagation();
      const off   = loadDayOff(currentMonday);
      const isOff = !!(off[dayKey]?.day);
      const menu = document.createElement('div');
      menu.className = 'ctx-menu';
      Object.assign(menu.style,{position:'fixed',zIndex:'99999',left:e.clientX+'px',top:e.clientY+'px',background:'#fff',border:'1px solid #ddd',borderRadius:'8px',boxShadow:'0 4px 18px rgba(0,0,0,.12)',padding:'6px',fontSize:'13px',minWidth:'220px'});
      const addItem=(label,fn,opts={})=>{ const it=document.createElement('div'); it.textContent=label; it.style.padding='6px 10px'; it.style.cursor=opts.disabled?'not-allowed':'pointer'; it.style.color=opts.danger?'#b91c1c':''; if(!opts.disabled){ it.addEventListener('mouseenter',()=>it.style.background='#f5f5f7'); it.addEventListener('mouseleave',()=>it.style.background=''); it.addEventListener('click',()=>{ fn(); menu.remove(); }); } menu.appendChild(it); };
      addItem(isHol ? 'この日の祝日扱いを解除（手動）' : 'この日を祝日として扱う（手動）', ()=>{ toggleHolidayManual(iso, !isHol); render(); });
      addItem(isOff ? 'この日の「終日休止」を解除' : 'この日を「終日休止」にする', ()=>{ setDayOff(currentMonday, dayKey, { day: !isOff }, { snapshot:true }); render(); });
      addItem('────────', ()=>{}, {disabled:true});
      addItem('この日の休止を「全リセット」', ()=>{ if(confirm('この日の休止設定（終日/セクション/以後/以前）をすべて解除します。よろしいですか？')){ clearDayOffForDay(currentMonday, dayKey, { snapshot:true }); render(); } }, {danger:true});
      addItem('────────', ()=>{}, {disabled:true});
      addItem('この日の「枠の形」をデフォルトに戻す', ()=>{ if (confirm('この日の枠形状（先頭臨時・途中挿入・末尾臨時）をすべて解除して、初期の枠数に戻します。よろしいですか？')) { resetSlotLayoutForDay?.(currentMonday, dayKey, { snapshot:true }); render(); } });
 addItem('この日を印刷（A4）', ()=> printDayElement(wrap));
      const close=(ev)=>{ if(!menu.contains(ev.target)){ document.removeEventListener('mousedown',close,true); menu.remove(); } };
      document.addEventListener('mousedown', close, true);
      document.body.appendChild(menu);
    });

    const sections = CONFIG[dayKey];
    const off = loadDayOff(currentMonday);
    const dayIsOff = !!(off[dayKey]?.day);

    // 午前
    const am = sections[0];
    const stAm = document.createElement('div'); stAm.className = 'section-title thin';
    const titleSpan = document.createElement('span'); titleSpan.textContent = am.title; stAm.appendChild(titleSpan);
    wrap.appendChild(stAm);

// ここから置き換え
stAm.addEventListener('contextmenu', (e)=>{
  e.preventDefault();
  e.stopPropagation();

  const off = loadDayOff(currentMonday);
  const cur = off[dayKey]?.sections?.[0] === true;

  // シンプルなポップアップメニューを生成
  const menu = document.createElement('div');
  Object.assign(menu.style, {
    position: 'fixed',
    zIndex: '99999',
    left: e.clientX + 'px',
    top:  e.clientY + 'px',
    background: '#fff',
    border: '1px solid #ddd',
    borderRadius: '8px',
    boxShadow: '0 4px 18px rgba(0,0,0,.12)',
    padding: '6px',
    fontSize: '13px',
    minWidth: '240px'
  });

  const addItem = (label, onClick, opts={})=>{
    const it = document.createElement('div');
    it.textContent = label;
    it.style.padding = '8px 12px';
    it.style.cursor = opts.disabled ? 'not-allowed' : 'pointer';
    if (opts.danger) it.style.color = '#b91c1c';
    if (!opts.disabled) {
      it.addEventListener('mouseenter', ()=> it.style.background = '#f5f5f7');
      it.addEventListener('mouseleave', ()=> it.style.background = '');
      it.addEventListener('click', ()=>{
        // クリック時に閉じる → 実行
        closeMenu();
        try { onClick(); } catch(err){ console.error(err); }
      });
    }
    menu.appendChild(it);
  };

  // 項目：午前の休止ON/OFF
  addItem(cur ? '午前の「休止」を解除' : '午前を「休止」にする', ()=>{
    const sections = Object.assign({}, off[dayKey]?.sections||{}, { 0: !cur });
    setDayOff(currentMonday, dayKey, { sections }, { snapshot:true });
    render();
  });

  // 仕切り
  addItem('────────', ()=>{}, { disabled:true });

// 項目：このセクションを印刷（午前=インデックス0だけ残す）
addItem('このセクションを印刷（A4想定）', ()=>{
  printDayKeepSections(wrap, [0]);   // ★ wrap は buildDay() 冒頭で作った section 要素
});
addItem('────────', ()=>{}, {disabled:true});

// この日の「午前＋午後（手術室1）」を印刷
addItem('午前＋午後（手術室1）を印刷', ()=>{
  if (dayKey==='Tue' || dayKey==='Fri') {
    printDayKeepSections(wrap, [0,1]); // 午前(0)＋午後(手術室1=1)
  } else {
    alert('この曜日には午後（手術室1）がありません。');
  }
});


  // 画面に追加 & 外クリックで閉じる
  const closeMenu = (ev)=>{
    if (!ev || !menu.contains(ev.target)) {
      document.removeEventListener('mousedown', closeMenu, true);
      if (menu.parentNode) menu.parentNode.removeChild(menu);
    }
  };
  document.addEventListener('mousedown', closeMenu, true);
  document.body.appendChild(menu);
});
// ここまで置き換え


    const slotsAm = document.createElement('div'); slotsAm.className = 'slots';
slotsAm.dataset.day = (dayKey==='Wed'?'Wed':dayKey);  // ←追加
slotsAm.dataset.section = '0';                         // ←追加
    if (off[dayKey]?.sections?.[0]) { slotsAm.classList.add('section-off'); }
    let count = am.slots;
    if(dayKey==='Wed'){
      if(opt.half==='first'){ count = Math.floor(am.slots/2); }
      if(opt.half==='second'){ count = Math.ceil(am.slots/2); }
    }
    const dayId = (dayKey === 'Wed') ? 'Wed' : dayKey;
    const extraAm = getExtraTailSlots(currentMonday, dayId, 0);
    if (dayKey !== 'Wed' || opt.half === 'second' || opt.combined) count += extraAm;

    const baseCount = count;
    const layoutAm = getSectionLayout(currentMonday, (dayKey==='Wed'?'Wed':dayKey), 0, baseCount);
    for (let i = 0; i < layoutAm.total; i++){
      const time = getSlotTimeHHMMEx(am.start, currentMonday, (dayKey==='Wed'?'Wed':dayKey), 0, i);
      const slot = createSlot({ d: dateISO(dayDate), day: (dayKey==='Wed'?'Wed':dayKey), section: 0, idx: i }, time);
      if (layoutAm.isTemp(i)) slot.classList.add('temp-slot');
      const isTemp = slot.classList.contains('temp-slot');
      if (!isTemp) {
        if (dayIsOff) { slot.classList.add('off'); }
        const ca0 = off[dayKey]?.cutAfter?.[0];
        const cb0 = off[dayKey]?.cutBefore?.[0];
        if (ca0 && hhmmToMinutes(time) >= hhmmToMinutes(ca0)) slot.classList.add('off');
        if (cb0 && hhmmToMinutes(time) <= hhmmToMinutes(cb0)) slot.classList.add('off');
      }
      { const k = `${dateISO(dayDate)}|${(dayKey==='Wed'?'Wed':dayKey)}|0|${i}`;
        if (loadEmerg(currentMonday)[k]) { slot.classList.remove('off'); slot.classList.add('emergency-slot'); } }
      slotsAm.appendChild(slot);
    }
    wrap.appendChild(slotsAm);

    // 午後（火・金）
    if (dayKey === 'Tue' || dayKey === 'Fri'){
      for (let sidx = 1; sidx < sections.length; sidx++){
        const sec = sections[sidx];
        const st = document.createElement('div'); st.className = 'section-title';
        const t = document.createElement('span'); t.textContent = sec.title; st.appendChild(t);
        wrap.appendChild(st);

// ここから置き換え
st.addEventListener('contextmenu', (e)=>{
  e.preventDefault();
  e.stopPropagation();

  const off = loadDayOff(currentMonday);
  const cur = off[dayKey]?.sections?.[sidx] === true;

  // シンプルな右クリックメニュー
  const menu = document.createElement('div');
  Object.assign(menu.style, {
    position: 'fixed',
    zIndex: '99999',
    left: e.clientX + 'px',
    top:  e.clientY + 'px',
    background: '#fff',
    border: '1px solid #ddd',
    borderRadius: '8px',
    boxShadow: '0 4px 18px rgba(0,0,0,.12)',
    padding: '6px',
    fontSize: '13px',
    minWidth: '240px'
  });

  const addItem = (label, onClick, opts={})=>{
    const it = document.createElement('div');
    it.textContent = label;
    it.style.padding = '8px 12px';
    it.style.cursor = opts.disabled ? 'not-allowed' : 'pointer';
    if (opts.danger) it.style.color = '#b91c1c';
    if (!opts.disabled) {
      it.addEventListener('mouseenter', ()=> it.style.background = '#f5f5f7');
      it.addEventListener('mouseleave', ()=> it.style.background = '');
      it.addEventListener('click', ()=>{
        closeMenu();
        try { onClick(); } catch(err){ console.error(err); }
      });
    }
    menu.appendChild(it);
  };

  // 午後の休止 ON/OFF
  addItem(cur ? '午後の「休止」を解除' : '午後を「休止」にする', ()=>{
    const sections = Object.assign({}, off[dayKey]?.sections||{}, { [sidx]: !cur });
    setDayOff(currentMonday, dayKey, { sections }, { snapshot:true });
    render();
  });

  // 仕切り
  addItem('────────', ()=>{}, { disabled:true });

// 項目：このセクションを印刷（この sidx だけ残す）
addItem('このセクションを印刷（A4想定）', ()=>{
  printDayKeepSections(wrap, [sidx]);  // 午後(手術室1)=1 / 午後(手術室8)=2
});

  // 外クリックで閉じる
  const closeMenu = (ev)=>{
    if (!ev || !menu.contains(ev.target)) {
      document.removeEventListener('mousedown', closeMenu, true);
      if (menu.parentNode) menu.parentNode.removeChild(menu);
    }
  };
  document.addEventListener('mousedown', closeMenu, true);
  document.body.appendChild(menu);
});
// ここまで置き換え


        const slotsEl = document.createElement('div'); slotsEl.className = 'slots';
        const offMap = loadDayOff(currentMonday);
        if (offMap[dayKey]?.sections?.[sidx]) { slotsEl.classList.add('section-off'); }
        const baseCount = sec.slots;
        const layout = getSectionLayout(currentMonday, dayKey, sidx, baseCount);
        for (let i = 0; i < layout.total; i++) {
          const time = getSlotTimeHHMMEx(sec.start, currentMonday, dayKey, sidx, i);
          const slot = createSlot({ d: dateISO(dayDate), day: dayKey, section: sidx, idx: i }, time);
          if (layout.isTemp(i)) slot.classList.add('temp-slot');
          const isTemp = slot.classList.contains('temp-slot');
          if (!isTemp) {
            const o = offMap[dayKey] || {};
            if (dayIsOff || (o.sections && o.sections[sidx])) { slot.classList.add('off'); }
            const caS = o.cutAfter && o.cutAfter[sidx];
            const cbS = o.cutBefore && o.cutBefore[sidx];
            if (caS && hhmmToMinutes(time) >= hhmmToMinutes(caS)) slot.classList.add('off');
            if (cbS && hhmmToMinutes(time) <= hhmmToMinutes(cbS)) slot.classList.add('off');
          }
          { const k = `${dateISO(dayDate)}|${dayKey}|${sidx}|${i}`;
            if (loadEmerg(currentMonday)[k]) { slot.classList.remove('off'); slot.classList.add('emergency-slot'); } }
          slotsEl.appendChild(slot);
        }
        wrap.appendChild(slotsEl);
      }
    }

    { const _off = loadDayOff(currentMonday); if(_off[dayKey]?.full === true){ wrap.classList.add('is-off'); } }
    return wrap;
  }

  function buildWeekend(){
    const dayKey = 'Weekend';
    const dayDate = addDays(currentMonday, 6);
    const wrap = document.createElement('section'); wrap.className = 'day weekend';
    const off = loadDayOff(currentMonday); const dayIsOff = !!(off['Weekend']?.day);

    const header = document.createElement('div'); header.className = 'day-header';
    const title = document.createElement('div'); title.className = 'day-header-date'; title.textContent = '（土/日）';
    const noteWrap = document.createElement('div'); noteWrap.className = 'day-note-inline';
    const noteInput = document.createElement('textarea'); noteInput.className = 'day-note-input'; noteInput.rows = 2; noteWrap.appendChild(noteInput);
    noteInput.value = getDayNote(currentMonday, dayKey);
    noteInput.addEventListener('focus', ()=>{ try{ undoStack.push(snapshotState()); redoStack.length=0; }catch(_){ }});
    noteInput.addEventListener('input', ()=>{ setDayNote(currentMonday, dayKey, noteInput.value); });
    header.appendChild(title); header.appendChild(noteWrap); wrap.appendChild(header);

    const secDef = CONFIG[dayKey][0];
    const st = document.createElement('div'); st.className = 'section-title thin';
    const addBtn = document.createElement('button'); addBtn.className = 'icon-btn'; addBtn.setAttribute('aria-label', '週末に臨時枠追加'); addBtn.textContent = '⊕'; addBtn.addEventListener('click', ()=>{ addExtraTailSlot(currentMonday, dayKey, 0, 1); render(); }); st.appendChild(addBtn);
    const subBtn = document.createElement('button'); subBtn.className = 'icon-btn'; subBtn.setAttribute('aria-label', '週末の臨時枠を1つ削除'); subBtn.textContent = '⊖'; subBtn.addEventListener('click', ()=>{ removeExtraTailSlot(currentMonday, dayKey, 0); render(); }); st.appendChild(subBtn);
    wrap.appendChild(st);

    const slotsEl = document.createElement('div'); slotsEl.className = 'slots';
    if (off['Weekend']?.sections?.[0]) { slotsEl.classList.add('section-off'); }
    const cnt = (secDef.slots|0) + getExtraTailSlots(currentMonday, dayKey, 0);
    for(let i=0;i<cnt;i++){
      const time = getSlotTimeHHMMEx(secDef.start, currentMonday, dayKey, 0, i);
      const slot = createSlot({ d: dateISO(dayDate), day: dayKey, section: 0, idx: i }, time);
      slot.classList.add('temp-slot');
      slotsEl.appendChild(slot);
    }
    wrap.appendChild(slotsEl);
    if (dayIsOff) { wrap.classList.add('is-off'); }
    return wrap;
  }

  function createSlot(meta, time){
    const el = slotTpl.content.firstElementChild.cloneNode(true);
    const timeEl = el.querySelector('.time'); timeEl.textContent = time ? String(time).replace(/^0/, '') : '';
    // ★ 時刻セルダブルクリック：開始時刻の手動変更
    timeEl.addEventListener('dblclick', (e)=>{
      // Shift / Alt 付きは下のハンドラに任せる
      if (e.shiftKey || e.altKey) return;
      e.preventDefault();
      e.stopPropagation();

      const dayKey = meta.day;
      const sec    = meta.section;
      const ii     = meta.idx;

      const base = (sec===0
        ? CONFIG[(dayKey==='Wed' ? 'Wed' : dayKey)][0].start
        : CONFIG[dayKey][sec].start
      );
      const cur  = getSlotTimeHHMMEx(base, currentMonday, dayKey, sec, ii);

      const input = prompt('この枠の時刻（例 10:00 / 1000 / 950）', cur);
      if (input == null) return;

      const hhmm = normalizeTimeInput(input);
      if (!hhmm){
        alert('形式が不正です。例：10:00 / 1000 / 0950 / 950');
        return;
      }

      // 直前の枠よりも後ろの時刻であることをチェック
      if (ii > 0){
        const prevBase = (sec===0
          ? CONFIG[(dayKey==='Wed' ? 'Wed' : dayKey)][0].start
          : CONFIG[dayKey][sec].start
        );
        const prevHHMM = getSlotTimeHHMMEx(prevBase, currentMonday, dayKey, sec, ii-1);
        if (hhmmToMinutes(hhmm) <= hhmmToMinutes(prevHHMM)){
          alert(`この枠は直前の枠（${prevHHMM}）より遅い時刻にしてください。`);
          return;
        }
      }

      // ★ 手動変更後、この枠をアンカーとして day/section 全体を再構成
      beginUndoBatch();
      try {
        // 1) この枠の開始時刻をアンカーとして記録
        setTimeOverride(currentMonday, dayKey, sec, ii, hhmm);

        // 2) 所要時間・結合枠に基づく後続アンカーを再計算
        const store = loadWeek(currentMonday);
        rebuildDurationAnchorsForDaySection(dayKey, sec, store, {
          keepAnchor: { idx: ii, hhmm }
        });
      } finally {
        endUndoBatch();
      }

      render();
    });

    // Shift＋ダブルクリック：この枠以降の override をデフォルトに戻す
    timeEl.addEventListener('dblclick', (e)=>{
      if (!e.shiftKey) return;
      e.preventDefault();
      e.stopPropagation();
      const { day, section, idx } = meta;
      clearTimeOverrideFrom(currentMonday, day, Number(section), Number(idx));
      render();
    });

    // Alt＋ダブルクリック：この day/section 全体の override をデフォルトに戻す
    timeEl.addEventListener('dblclick', (e)=>{
      if (!e.altKey) return;
      e.preventDefault();
      e.stopPropagation();
      const { day, section } = meta;
      clearTimeOverrideAll(currentMonday, day, Number(section));
      render();
    }, { capture:true });
    timeEl.addEventListener('dblclick', (e)=>{ if(!e.shiftKey) return; e.preventDefault(); e.stopPropagation(); const { day, section, idx } = meta; clearTimeOverrideFrom(currentMonday, day, Number(section), Number(idx)); render(); });
    timeEl.addEventListener('dblclick', (e)=>{ if(!e.altKey) return; e.preventDefault(); e.stopPropagation(); const { day, section } = meta; clearTimeOverrideAll(currentMonday, day, Number(section)); render(); }, { capture:true });

    el.dataset.key = `${meta.d}|${meta.day}|${meta.section}|${meta.idx}`;
el.addEventListener('click', (e)=>{
  if (isSlotLockedForEdit(el)) return; 
  setActiveSlot(el);
  window.lastSelectedKey = el.dataset.key;
});
    const leftEl = el.querySelector('.content-left'); const surgEl = el.querySelector('.surgeon-tag');
    leftEl.textContent = '（空）'; surgEl.textContent = ''; el.classList.add('empty');


    el.addEventListener('contextmenu', (e)=>{
      e.preventDefault();
      const dayKey  = meta.day; const section = meta.section; const idx = meta.idx;
      const baseCount = CONFIG[dayKey][section].slots; const layout = getSectionLayout(currentMonday, dayKey, section, baseCount);
      const menu = document.createElement('div');
      Object.assign(menu.style,{position:'fixed',zIndex:'99999',left:e.clientX+'px',top:e.clientY+'px',background:'#fff',border:'1px solid #ddd',borderRadius:'8px',boxShadow:'0 4px 18px rgba(0,0,0,.12)',padding:'6px',fontSize:'13px',minWidth:'200px'});
      function addItem(label, onClick){ const it=document.createElement('div'); it.textContent=label; it.style.padding='8px 12px'; it.style.cursor='pointer'; it.addEventListener('mouseenter', ()=> it.style.background='#f5f5f7'); it.addEventListener('mouseleave', ()=> it.style.background=''); it.addEventListener('click', ()=>{ onClick(); document.body.removeChild(menu); }); menu.appendChild(it); }

      // 個別「臨時化（緊急）」
      {
        const key  = el.dataset.key;
        const em   = loadEmerg(currentMonday) || {};
        const isEm = !!em[key];

        // 日付（ISO）から祝日判定
        const meta      = parseKey(key);   // { d, day, section, idx } など
        const iso       = meta && meta.d;
        const isHoliday = iso ? isHolidayISO(iso) : false;

        // ★ 祝日のときだけ「臨時化」メニューを出す
        if (isHoliday) {
          addItem(
            isEm ? 'この枠の臨時化を解除' : 'この枠を臨時化（緊急）',
            ()=>{
              try { undoStack.push(snapshotState()); redoStack.length = 0; } catch(_){}
              setEmergency(currentMonday, key, !isEm);
              render();
            }
          );
        }
      }


      // ★ RLセット関連フラグ
      //    isRLSingleMember: 片側だけ選ばれているとき true
      //    rlBlockStartIdx / rlBlockEndIdx: セット全体の表示 idx 範囲
      let isRLSingleMember = false;
      let rlBlockStartIdx = null;
      let rlBlockEndIdx   = null;

      try {
        if (typeof findRLSetRangeForSlot === 'function') {
          const data = loadWeek(currentMonday);
          const info = data && findRLSetRangeForSlot(el, data);
          const base = info && data[info.baseKey];
          const rlId = base && base.meta && base.meta.rlSetId;

          if (info && rlId && Array.isArray(info.keys) && info.keys.length >= 2) {
            // ▼ セット全体が選択されているかどうかをチェック
            let wholeSelected = true;
            for (const k of info.keys) {
              const slotEl = document.querySelector(`.slot[data-key="${k}"]`);
              if (!slotEl) {
                wholeSelected = false;
                break;
              }
              // セット選択時につくクラス：multiSelected
              if (!slotEl.classList.contains('multiSelected')) {
                wholeSelected = false;
                break;
              }
            }

            if (!wholeSelected) {
              // 片側だけ選ばれている → 構造変更系は全部NG
              isRLSingleMember = true;
            } else {
              // セット全体が選ばれている
              // → rlBlockStartIdx / rlBlockEndIdx を決めて「1ブロック扱い」にする
              const len = info.keys.length; // 普通は 2

              if (el.classList.contains('rl-set-top')) {
                // 上側を右クリックしている → ここが先頭
                rlBlockStartIdx = idx;
                rlBlockEndIdx   = idx + (len - 1);
              } else if (el.classList.contains('rl-set-bottom')) {
                // 下側を右クリック → ここが末尾
                rlBlockStartIdx = idx - (len - 1);
                rlBlockEndIdx   = idx;
              } else {
                // 念のためのフォールバック：idx をそのまま使う
                rlBlockStartIdx = idx;
                rlBlockEndIdx   = idx + (len - 1);
              }
            }
          }
        }
      } catch(e){
        console && console.warn && console.warn('RL guard in ctx menu failed:', e);
      }



      if (!isRLSingleMember) {

        addItem('この枠の前に臨時枠を挿入', ()=>{
          const batch = (typeof beginUndoBatch === 'function')
            ? beginUndoBatch('temp-insert-before')
            : null;
          try {
            // RLセットがセット選択されていれば、その「先頭 idx」の前に挿入
            const targetIdx = (rlBlockStartIdx != null ? rlBlockStartIdx : idx);
            insertTempBefore(currentMonday, dayKey, section, targetIdx);
          } finally {
            if (typeof endUndoBatch === 'function') {
              endUndoBatch(batch);
            }
          }
          render();
        });

        addItem('この枠の後に臨時枠を挿入', ()=>{
          const batch = (typeof beginUndoBatch === 'function')
            ? beginUndoBatch('temp-insert-after')
            : null;
          try {
            // RLセットがセット選択されていれば、その「末尾 idx」の後ろに挿入
            const targetIdx = (rlBlockEndIdx != null ? rlBlockEndIdx : idx);
            insertTempAfter(currentMonday, dayKey, section, targetIdx);
          } finally {
            if (typeof endUndoBatch === 'function') {
              endUndoBatch(batch);
            }
          }
          render();
        });

        // （この下の「臨時枠削除」「休止系」はそのままでOK）
        if (layout.isTemp(idx)){
          addItem('この臨時枠を削除', ()=>{
            const batch = (typeof beginUndoBatch === 'function')
              ? beginUndoBatch('temp-remove')
              : null;
            try {
              removeTempAt(currentMonday, dayKey, section, idx);
            } finally {
              if (typeof endUndoBatch === 'function') {
                endUndoBatch(batch);
              }
            }
            render();
          });
        }

      // 休止（時刻基準）— 祝日は非表示
      (() => {
        const key = el.dataset.key;
        const metaInfo = parseKey(key);   // { d, day, section, idx } など
        const iso      = metaInfo && metaInfo.d;
        const isHoliday= iso ? isHolidayISO(iso) : false;
        if (isHoliday) return;

        // 週データとこの枠のレコード
        const store      = loadWeek(currentMonday) || {};
        const recHere    = store[key];
        const hasDataHere= !!recHere;

        // 同じセクション内のスロット一覧（DOM 順）
        const slotsContainer = el.parentElement; // .slots
        if (!slotsContainer) return;
        const slotEls = Array.from(slotsContainer.querySelectorAll('.slot'));
        const domIdx  = slotEls.indexOf(el);
        if (domIdx < 0) return;

        let hasDataBefore = false;
        let hasDataAfter  = false;

        for (let i = 0; i < slotEls.length; i++){
          const sEl = slotEls[i];
          const k   = sEl.dataset.key;
          if (!k) continue;
          const r = store[k];

          // ★ tail だけのレコード（結合の延長枠）や
          //   ゴースト tail は「データあり」とはみなさない
          if (!r || r.tail) continue;

          if (i < domIdx) {
            hasDataBefore = true;
          } else if (i > domIdx) {
            hasDataAfter = true;
          }
          if (hasDataBefore && hasDataAfter) break;
        }


        // このマス自体はデータなし かつ 前後にどこまでデータがあるか
        const canPauseHere       = !hasDataHere;
        const canPauseBeforeHere = canPauseHere && !hasDataBefore;
        const canPauseAfterHere  = canPauseHere && !hasDataAfter;

        // 現在の休止状態
        const off       = loadDayOff(currentMonday);
        const cutAfter  = off[dayKey]?.cutAfter  || {};
        const cutBefore = off[dayKey]?.cutBefore || {};
        const hasOff    = !!(cutAfter[section] || cutBefore[section]);

        // 「以前/以後」も出せず、クリア対象の休止も無ければ何も出さない
        if (!canPauseBeforeHere && !canPauseAfterHere && !hasOff) return;

        addItem('────────', () => {});

        // この枠の時刻（HH:MM）
        const timeText = timeEl.textContent.trim();
        const slotHHMM = normalizeTimeInput(timeText) || timeText;

        // この枠「以後」を休止（★後ろ側にデータがないマスだけ）
        if (canPauseAfterHere) {
          addItem('この枠「以後」を休止', () => {
            const off0      = loadDayOff(currentMonday);
            const cutAfter0 = Object.assign({}, off0[dayKey]?.cutAfter || {});
            cutAfter0[section] = String(slotHHMM);
            setDayOff(currentMonday, dayKey, { cutAfter: cutAfter0 }, { snapshot: true });
            render();
          });
        }

        // この枠「より前」を休止（★前側にデータがないマスだけ）
        if (canPauseBeforeHere) {
          addItem('この枠「より前」を休止', () => {
            const off0       = loadDayOff(currentMonday);
            const cutBefore0 = Object.assign({}, off0[dayKey]?.cutBefore || {});
            cutBefore0[section] = String(slotHHMM);
            setDayOff(currentMonday, dayKey, { cutBefore: cutBefore0 }, { snapshot: true });
            render();
          });
        }

        // このセクションの「時刻休止」をクリア（★何か休止があるときだけ）
        if (hasOff) {
          addItem('このセクションの「時刻休止」をクリア', () => {
            const off1       = loadDayOff(currentMonday);
            const cutAfter1  = Object.assign({}, off1[dayKey]?.cutAfter  || {});
            const cutBefore1 = Object.assign({}, off1[dayKey]?.cutBefore || {});
            delete cutAfter1[section];
            delete cutBefore1[section];
            setDayOff(currentMonday, dayKey, { cutAfter: cutAfter1, cutBefore: cutBefore1 }, { snapshot: true });
            render();
          });
        }
      })();

      } // if (!isRLSingleMember) ここまで

  // ==== RLセット解除 ====
  (()=>{
    try {
      const data = loadWeek(currentMonday);
      if (!data || typeof findRLSetRangeForSlot !== 'function') return;

      // このスロットが RLセットに属しているかどうか判定
      const info = findRLSetRangeForSlot(el, data);
      const baseRec = info && data[info.baseKey];
      const rlId = baseRec?.meta?.rlSetId;
      if (!info || !rlId) return;  // RLセットでなければメニューを出さない

      addItem('RLセットを解除（リンクのみ）', ()=>{
        if (!confirm('このRLセットのリンクを解除します（枠自体は残ります）。よろしいですか？')) {
          return;
        }

        const data2 = loadWeek(currentMonday);
        const info2 = findRLSetRangeForSlot(el, data2);
        const base2 = info2 && data2[info2.baseKey];
        const rlId2 = base2?.meta?.rlSetId;
        if (!info2 || !rlId2) return;

        // R/L 両ヘッドから rlSetId を外す
        for (const headKey of info2.keys) {
          const rec = data2[headKey];
          if (!rec || !rec.meta) continue;
          if (rec.meta.rlSetId !== rlId2) continue;
          delete rec.meta.rlSetId;
          // metaが空になったらプロパティごと削除してクリーンに
          if (!Object.keys(rec.meta).length) {
            delete rec.meta;
          }
        }

        saveWeek(currentMonday, data2);
        render();

        // セット選択状態をクリア
        if (typeof clearMultiSelection === 'function') {
          clearMultiSelection();
        }
        window.currentRLSetId = null;

        // 操作した枠にフォーカスを戻す
        const k = el.dataset.key;
        if (k && typeof setActiveSlot === 'function') {
          const el2 = document.querySelector(`.slot[data-key="${CSS.escape(k)}"]`);
          if (el2) setActiveSlot(el2);
        }
      });
    } catch (e) {
      console.warn('RLセット解除メニューの生成に失敗しました:', e);
    }
  })();
  
      function closeMenu(ev){ if (!menu.contains(ev.target)) { document.removeEventListener('mousedown', closeMenu, true); if (menu.parentNode) menu.parentNode.removeChild(menu); } }
      document.addEventListener('mousedown', closeMenu, true); document.body.appendChild(menu);
    }, {passive:false});

    return el;
  }

  // ===== ナビゲーション =====
prevWeekBtn.addEventListener('click', (e)=>{
  e.preventDefault();
  e.stopImmediatePropagation();

  // ★ 週またぎ時は複数選択をクリア（従来の挙動は維持）
  if (typeof multiSelected!=='undefined') { 
    multiSelected.clear?.(); 
    document.querySelectorAll('.slot.is-selected')
      ?.forEach(el => el.classList.remove('is-selected'));
  }

  // ★ Ctrl+← を擬似的に押したことにする
  const ev = new KeyboardEvent('keydown', {
    key: 'ArrowLeft',
    code: 'ArrowLeft',
    ctrlKey: true,
    bubbles: true
  });
  document.dispatchEvent(ev);
});

nextWeekBtn.addEventListener('click', (e)=>{
  e.preventDefault();
  e.stopImmediatePropagation();

  if (typeof multiSelected!=='undefined') { 
    multiSelected.clear?.(); 
    document.querySelectorAll('.slot.is-selected')
      ?.forEach(el => el.classList.remove('is-selected'));
  }

  // ★ Ctrl+→ を擬似的に押したことにする
  const ev = new KeyboardEvent('keydown', {
    key: 'ArrowRight',
    code: 'ArrowRight',
    ctrlKey: true,
    bubbles: true
  });
  document.dispatchEvent(ev);
});

todayBtn.addEventListener('click', (e)=>{
  // 通常のリンク動作などは無効化
  e.preventDefault();
  e.stopImmediatePropagation();

  // マルチ選択状態は念のためクリア（従来の挙動を維持したい場合）
  if (typeof multiSelected !== 'undefined') {
    multiSelected.clear?.();
    document.querySelectorAll('.slot.is-selected')
      ?.forEach(el => el.classList.remove('is-selected'));
  }

  // ★ Ctrl+, を擬似的に押したことにする
  const ev = new KeyboardEvent('keydown', {
    key: ',',
    code: 'Comma',
    ctrlKey: true,
    bubbles: true
  });
  document.dispatchEvent(ev);
});

  weekPicker.addEventListener('change', (e)=>{ if (window.__suppressWeekChange) return;
    if (typeof multiSelected!=='undefined') { 
      multiSelected.clear?.(); 
      document.querySelectorAll('.slot.is-selected')?.forEach(el=> el.classList.remove('is-selected'));
    }
    if (window.__suppressWeekChange) return;  // ★フォーカス中ピッカー更新を抑止
    const v=e.target.value; if(!v) return;
    const [y,m,d]=v.split('-').map(Number);
    const mon = startOfWeek(new Date(y, m-1, d));
    window.__suppressCenterN = (window.__suppressCenterN|0) + 2;
    window.__snapTopOnNextRender = true;
    window.__snapTopTargetISO   = (typeof dateISO==='function') ? dateISO(mon) : mon.toISOString().slice(0,10);
    currentMonday = mon;
    render();
    window.__postWeekMoveCenter?.();	
  });

// ★ 週表示の通常印刷：月〜金だけ印刷 ＋ 背が高い曜日だけ自動で少し縮小
printBtn.addEventListener('click', () => {
  const days = Array.from(document.querySelectorAll('#schedule .day'));
  if (!days.length) {
    window.print();
    return;
  }

  // フォーカス表示中は、従来通りその日だけ印刷
  if (document.body.classList.contains('dayFocus')) {
    window.print();
    return;
  }

  const weekendDays = [];
  const weekdayDays = [];

  // ヘッダーの「(土)/(日)」を見て、平日と土日に分ける
  for (const d of days) {
    const header = d.querySelector('.day-header-date');
    const txt = header?.textContent || '';
    if (txt.includes('土') || txt.includes('日')) {
      weekendDays.push(d);
    } else {
      weekdayDays.push(d);
    }
  }

  // ① 土日は hide-on-print で隠す
  const hiddenDays = [];
  weekendDays.forEach(d => {
    d.classList.add('hide-on-print');
    hiddenDays.push(d);
  });

  // ② 緊急枠/臨時枠の「数」に応じて圧縮レベルを変える
  const tightDays = [];
  const tighterDays = [];
  weekdayDays.forEach(d => {
    const cnt = d.querySelectorAll('.slot.emergency-slot, .slot.temp-slot').length;
    if (cnt >= 1 && cnt <= 2) {
      d.classList.add('print-tight');
      tightDays.push(d);
    } else if (cnt >= 3) {
      d.classList.add('print-tighter');
      tighterDays.push(d);
    }
  });

  try {
    window.print();
  } finally {
    hiddenDays.forEach(d => d.classList.remove('hide-on-print'));
    tightDays.forEach(d => d.classList.remove('print-tight'));
    tighterDays.forEach(d => d.classList.remove('print-tighter'));
  }
});

// === 2ページ印刷モード（今は月〜金＋土日も含めて2枚に収める） ===
printWeek2pBtn?.addEventListener('click', ()=>{
  const days = Array.from(document.querySelectorAll('#schedule .day'));
  if (!days.length) {
    window.print();
    return;
  }

  // ★ 2ページ印刷モード ON（行高やセクションタイトル圧縮などのCSSが効く）
  document.body.classList.add('printWeek2p');

  try {
    window.print();
  } finally {
    document.body.classList.remove('printWeek2p');
  }
});


const printSelectionBtn = document.getElementById('printSelectionBtn');
printSelectionBtn?.addEventListener('click', ()=>{
  // ルール：アクティブスロットの属する「直近の .slots」を印刷
   const base = getActiveSlot?.() || document.querySelector('.slot');
  if(!base){
    alert('印刷するセクションが特定できません（枠を1つ選択してから押してください）');
    return;
  }
  const slotsEl = base.closest('.slots');
  if(!slotsEl){
    alert('この枠に対応するセクションが見つかりませんでした');
    return;
  }
  printSection(slotsEl);
});

// ==== 設定ボタンとダイアログ ====
const settingsBtn   = document.getElementById('settingsBtn');
const settingsDlg   = document.getElementById('settings');
const settingsForm  = document.getElementById('settingsForm');
const settingsSave  = document.getElementById('settingsSaveBtn');

// 開く：現在の値をテキストエリアに流し込む（1行=1候補）
settingsBtn?.addEventListener('click', ()=>{
  document.getElementById('optIolTypes').value  = (appLists.iolTypes||[]).join('\n');
  document.getElementById('optProc1').value     = (appLists.proc1||[]).join('\n');
  document.getElementById('optProc2').value     = (appLists.proc2||[]).join('\n');
  document.getElementById('optSurgeons').value  = (appLists.surgeons||[]).join('\n');
  settingsDlg.showModal();
});

// 保存
settingsForm?.addEventListener('close', ()=>{/* noop（念のため） */});
settingsSave?.addEventListener('click', (e)=>{
  // <button value="save"> なので dialog は閉じる挙動ですが、確実に先に保存処理
  e.preventDefault();

  const lines = (t)=> t.split('\n').map(s=>s.trim()).filter(Boolean);

  const next = {
    iolTypes:  lines(document.getElementById('optIolTypes').value),
    proc1:     lines(document.getElementById('optProc1').value),
    proc2:     lines(document.getElementById('optProc2').value),
    surgeons:  lines(document.getElementById('optSurgeons').value)
  };

  appLists = next;
  saveSettings(appLists);
  applyDatalists(appLists);
  settingsDlg.close();  // 閉じる
});

// 初期反映：起動時と毎描画時に最新を反映
applyDatalists(appLists);


  // 祝日データ キャッシュ（当年＋前後1年）
  (function ensureHolidayCaches(){ const y = new Date().getFullYear(); [y - 1, y, y + 1].forEach(ensureHolidayAuto); })();

// ★ ダブルクリック編集を委譲で一括対応（F5直後でも必ず効く）
 // =============================
 // 選択状態（SST）とユーティリティ
 // =============================
 (function initSlotCursorCore(){
   if (!window.__slotCursor)
     window.__slotCursor = { activeSlotEl: null, activeDayIndex: null };
 
   // 現在選択を取得
   window.getActiveSlot = function(){ return window.__slotCursor.activeSlotEl; };
 
function isSelectableSlot(el){
  // 基本ガード
  if (!el || !el.classList?.contains('slot')) return false;
  if (el.hidden) return false;                              // <div hidden> 対応
  if (el.classList.contains('hiddenRow')) return false;     // 結合枠 tail 除外
  if (el.classList.contains('disabled')) return false;
  if (el.classList.contains('locked')) return false;
  if (getComputedStyle(el).display === 'none') return false; // CSS非表示除外

  // 例外：臨時/緊急は最優先で「選択可」
  const isTempOrEmergency = el.classList.contains('temp-slot') || el.classList.contains('emergency-slot');
  if (isTempOrEmergency) return true;

  // 手動オフ（個別休止）＝原則「選択不可」
  if (el.classList.contains('off')) return false;

  // セクション休止（親 .slots.section-off）＝「選択不可」
  const slotsWrap = el.closest?.('.slots');
  if (slotsWrap?.classList?.contains('section-off')) return false;

  // 祝日/終日休止（親 .day が is-holiday / is-off）＝「選択不可」
  const day = el.closest?.('.day');
  if (day && (day.classList.contains('is-holiday') || day.classList.contains('is-off'))) return false;

  return true;
}

// 祝日/休診日の day 判定（集中管理）
function isOffDay(dayEl){
  return !!(dayEl && (dayEl.classList.contains('is-holiday') || dayEl.classList.contains('is-off')));
}

  // 廃止: setActiveSlot に統合済み。互換確保のため当面は no-op（後日削除可）
  function syncFocused(){ /* no-op */ }
 
// （重複していた旧統合版は削除）
  // 統合版: setActiveSlot は青枠・状態更新・スクロールまで一元管理
  window.setActiveSlot = function(el, opts){
    opts = opts || {};
    const doScroll = opts.scroll !== false; // ★ 既定は維持。週移動系からは必ず {scroll:false}

    // 無効要素 → 全解除
    if (!isSelectableSlot(el)) {
      const prev0 = window.__slotCursor?.activeSlotEl || document.querySelector('.slot.focused');
      if (prev0?.classList) prev0.classList.remove('focused');
      if (window.__slotCursor) window.__slotCursor.activeSlotEl = null;
      window.__navCurSlot = null;
      window.lastSelectedKey = null;
      return;
    }

  // 祝日/休診日の day を渡された場合は「営業日の最初の枠」へ寄せる
  (function normalizeAwayFromHoliday(){
    // ★ 緊急/臨時は“寄せず”にその場で選択させる
    const isEmOrTemp = el?.classList?.contains('emergency-slot') || el?.classList?.contains('temp-slot');
    if (isEmOrTemp) return;  
    const day = el.closest?.('.day');
    if (!isOffDay(day)) return;
    const days = Array.from(document.querySelectorAll('.day'));
    let idx = days.indexOf(day);
    // 右（翌日）優先で営業日を探す → なければ左へ
    let j = idx + 1, found = null;
    for(; j < days.length; j++){
      if (!isOffDay(days[j])){ found = days[j]; break; }
    }
    if (!found){
      for(j = idx - 1; j >= 0; j--){
        if (!isOffDay(days[j])){ found = days[j]; break; }
      }
    }
    if (found){
      const first = window.findFirstSelectableInDay?.(found);
      if (first) el = first; // ← “渡された祝日枠”はここで置換
    }
  })();
  
    // hiddenRow（結合枠tail）の場合は head へ寄せる
    while (el && el.classList.contains('hiddenRow')) el = el.previousElementSibling;

    const prev = window.__slotCursor?.activeSlotEl || document.querySelector('.slot.focused');
    if (prev && prev !== el) prev.classList.remove('focused');

    // 状態同期
    if (window.__slotCursor) window.__slotCursor.activeSlotEl = el;
    window.__navCurSlot = el; // 簡易ナビと同期
    window.lastSelectedKey = el?.dataset?.key || null;

    // day index 更新
    const day = el.closest?.('.day');
    if (day && window.__slotCursor) {
      const idx = Array.from(day.parentElement?.querySelectorAll?.('.day') || []).indexOf(day);
      if (idx >= 0) window.__slotCursor.activeDayIndex = idx;
    }

    // 青枠＋フォーカス＋スクロール
    el.classList.add('focused');
    try { el.focus?.({ preventScroll: true }); } catch(_){}
    if (doScroll) try { el.scrollIntoView({ block: 'nearest', inline: 'nearest' }); } catch(_){}
  };

// === 週ビュー：アクティブスロットを縦横とも中央に寄せる（切替直後専用・シンプル版） ===
window.__centerActiveInWeekSoon = function(){
  // ★ 抑止カウンタは「週表示のときだけ」効かせる（フォーカス中は無視）
  if (!document.body.classList.contains('dayFocus') && window.__suppressCenterN > 0) {
    window.__suppressCenterN--;
    return;
  }

  const run = () => {
    const el =
      (window.getActiveSlot && window.getActiveSlot()) ||
      document.querySelector('.slot.focused');
    if (!el) return;

    try {
      // ★ 実際のスクロールコンテナをブラウザに任せて、
      //    縦横とも「中央付近」に一発でスナップさせる
      el.scrollIntoView({
        block:  'center',   // 上下方向 → 中央付近
        inline: 'center',   // 左右方向 → 中央付近
        behavior: 'auto'    // アニメーションなし（瞬時）
      });
    } catch (_e) {
      // scrollIntoView 非対応環境は、単純な nearest だけでも OK
      try { el.scrollIntoView(); } catch(_e2) {}
    }
  };

  // ★ レイアウト確定後に一度だけ実行（2フレーム待ちで安定させる）
  requestAnimationFrame(() => {
    requestAnimationFrame(run);
  });
};


window.__postWeekMoveCenter = function(){
  // フォーカスモード中は週移動扱いにしない
  if (document.body.classList.contains('dayFocus')) return;

  requestAnimationFrame(() => {
    // 1) 既存のアクティブを優先
    let el =
      (window.getActiveSlot && window.getActiveSlot()) ||
      document.querySelector('.slot.focused');

    // ★ 前の週など「今の DOM に存在しないスロット」を掴んでいる場合は捨てる
    if (el && !document.body.contains(el)) {
      el = null;
    }

    // 2) 何もなければ「週の先頭の選択可能スロット」を探す
    if (!el) {
      const days = Array.from(document.querySelectorAll('#schedule .day'));
      for (const d of days) {
        const first =
          (window.findFirstSelectableInDay && window.findFirstSelectableInDay(d)) ||
          d.querySelector('.slot');
        if (first) { el = first; break; }
      }
    }

    // ★ それでも見つからない場合は、保険として最初の .slot を拾う
    if (!el) {
      el = document.querySelector('#schedule .slot');
    }
    if (!el) return;

    // 3) 正式にアクティブ設定（ここではスクロールさせない）
    if (typeof window.setActiveSlot === 'function') {
      window.setActiveSlot(el, { scroll: false });
    } else {
      // 念のため古い .focused をクリアしてから付け直す
      document.querySelectorAll('.slot.focused')
        .forEach(s => s.classList.remove('focused'));
      el.classList.add('focused');
    }

    // ★ suppress が邪魔しないようにリセットしてから、いつものセンタリング関数を呼ぶ
    window.__suppressCenterN = 0;
    window.__centerActiveInWeekSoon?.();
  });
};



// 互換：現在のアクティブ枠を取得
window.getActiveSlot = function(){
  return window.__slotCursor?.activeSlotEl || document.querySelector('.slot.focused') || null;
};
// 旧APIは空実装に
window.syncFocused = function(){ /* unified into setActiveSlot */ };
 
   window.findFirstSelectableInDay = function(dayEl){
     if (!dayEl) return null;
     const list = dayEl.querySelectorAll('.slot');
     for (const el of list) if (isSelectableSlot(el)) return el;
     return null;
   };
 
   window.ensureInitialSelectionForDay = function(dayEl){
     if (window.__slotCursor.activeSlotEl?.closest?.('.day') === dayEl) return;
     const first = findFirstSelectableInDay(dayEl);
     if (first) setActiveSlot(first);
   };
 
window.moveVertWithinDay = function(fromEl, delta){
  if (!isSelectableSlot(fromEl)) return false;
  const dayEl = fromEl.closest?.('.day');
  if (!dayEl) return false;
  const list = Array.from(dayEl.querySelectorAll('.slot')).filter(isSelectableSlot);
  const i = list.indexOf(fromEl);
  if (i < 0) return false;
  const j = i + (delta > 0 ? 1 : -1);
  if (j < 0 || j >= list.length) return false; // 端では止まる

  const target = list[j];
  setActiveSlot(target);

  const inFocus = document.body.classList.contains('dayFocus');
  if (inFocus) {
    // ★ フォーカス表示中：実際の表示枠の中央に「必ず見えるように」スナップ
    target.scrollIntoView({ block: 'center', inline: 'nearest', behavior: 'auto' });
  } else {
    // ★ 週表示中：smooth をやめて即時センタリング（追従遅れを防ぐ）
    centerSlotInView(target, { instant: true });
  }

  return true;
}

  // === アクティブスロットを中央に寄せる ===
  function centerSlotInView(slotEl, opts){
    opts = opts || {};
    const instant = opts.instant === true;  // ★ true のときはパッと（smooth禁止）
    if (!slotEl) return;
    const dayEl = slotEl.closest('.day');
    if (!dayEl) return;

    const scrollBox = __getScrollParent(dayEl);
    if (!scrollBox) return;

    const boxRect = scrollBox.getBoundingClientRect();
    const slotRect = slotEl.getBoundingClientRect();

    const currentTop = scrollBox.scrollTop;
    const slotTop = slotRect.top - boxRect.top + currentTop;
    const slotCenter = slotTop + slotRect.height / 2;

    // スロットを可視領域中央に配置
    let target = slotCenter - scrollBox.clientHeight / 2;

    // 0〜最大範囲内に収める
    target = Math.max(0, Math.min(target, scrollBox.scrollHeight - scrollBox.clientHeight));

    if (instant) {
      // ★ パッと移動（ぐーっと動かない）
      scrollBox.scrollTop = target;
    } else {
      // スムーズスクロールで自然な動きに
      scrollBox.scrollTo({ top: target, behavior: 'smooth' });
    }
  }
 })();
 
    function moveVertWithCrossDay(fromEl, delta) {
  const inFocus = document.body.classList.contains('dayFocus');
  if (inFocus) {
    // フォーカス表示では同日内のみ（セクションまたぎ可）
    moveVertWithinDay(fromEl, delta);
    return;
  }

  // --- 週モード（日またぎあり） ---
  const curDay = fromEl.closest('.day');
  if (!curDay) return;

  // 同日内に次スロットがあれば優先
  if (moveVertWithinDay(fromEl, delta)) return;

  // 日またぎ処理（“選択可能なスロット”がある日だけへ
  const allDays = Array.from(document.querySelectorAll('.day'));
  const step = (delta > 0 ? 1 : -1);
  let i = allDays.indexOf(curDay) + step;
  // 選択可能判定：存在すれば window.isSelectableSlot を優先
  const isSel = (el)=>{
    if (typeof window.isSelectableSlot === 'function') return window.isSelectableSlot(el);
    // フォールバック（最低限）
    if (!el || !el.classList?.contains('slot')) return false;
    if (el.hidden || el.classList.contains('hiddenRow') || el.classList.contains('disabled') || el.classList.contains('locked')) return false;
    const wrap = el.closest?.('.slots');
    if (wrap?.classList?.contains('section-off')) return false;
    if (el.classList.contains('off')) return false;
    const day = el.closest?.('.day');
    if (day && (day.classList.contains('is-holiday') || day.classList.contains('is-off'))) return false;
    return true;
  };
  while (i >= 0 && i < allDays.length) {
    const nextDay = allDays[i];
    // その日の“選択可能なスロット”だけを候補にする
    const list = Array.from(nextDay.querySelectorAll('.slot')).filter(isSel);
    if (!list.length) { i += step; continue; }

    const target = (delta > 0) ? list[0] : list[list.length - 1];
    setActiveSlot(target);

    // ★ 週表示での日またぎ時も、即時センタリングで必ず画面内に捕まえる
    centerSlotInView(target, { instant: true });

    return;
  }
  // 着地先が無ければ何もしない
}

  // 初期適用＆描画
  applyLayout(layoutMode);

// ✅（任意）画面サイズ変更でも再調整したいならここに追加
let _fitT = null;
window.addEventListener('resize', () => {
  clearTimeout(_fitT);
  _fitT = setTimeout(() => autoFitContentLines(), 150);
}, { passive: true });

// 「編集」ボタン：選択中（複数対応）→ なければアクティブ → それも無ければ先頭
editBtn?.addEventListener('click', () => {
  // ★ RLセット外周選択中は「セット操作モード」とみなし、編集をブロック
  //   → どちらかの枠をクリックして単枠青枠にしてから編集してもらう
  if (window.currentRLSetId && document.querySelector('.slot.multiSelected')) {
    // 必要なら案内を出してもよい（今は静かに無視）
    // alert('RLセット選択中です。どちらかの枠をクリックしてから編集してください。');
    return;
  }

  // まず DOM 要素で候補を集める
  const candEls = [];

  if (typeof multiSelected !== 'undefined' && multiSelected.size){
    for (const k of multiSelected){
      const el = document.querySelector(`.slot[data-key="${k}"]`);
      if (el) candEls.push(el);
    }
    // ★ 週またぎでキーが無効だった場合のフォールバック
    if (!candEls.length) {
      const cur = getActiveSlot?.() || document.querySelector('.slot.focused');
      if (cur) candEls.push(cur);
      else {
        const first = document.querySelector('.slot');
        if (first) candEls.push(first);
      }
    }
  } else {
     const cur = getActiveSlot?.();
     if (cur) {
       candEls.push(cur);
     } else {
       const first = document.querySelector('.slot');
       if (first) candEls.push(first);
     }
   }

  if (!candEls.length){
    alert('編集する枠が見つかりません');
    return;
  }

  // ★ 祝日/休止ロックを除外（緊急・臨時は除外されず残る）
  const unlockedEls = candEls.filter(el => !isSlotLockedForEdit(el));

  if (!unlockedEls.length){
    // 何か選ばれてはいるが、全部ロック枠だった
    alert('祝日/休止のため編集できる枠がありません');
    return;
  }

  const keys = unlockedEls.map(el => el.dataset.key);
  openEditor(keys);
});

// === ここから：週表示スロット用「優先表示」テキスト生成機能 ===

// スロット左側に表示するフィールド定義（優先度付き）
// priority=1: 幅が狭くても必ず出したい
// priority=2: 少し余裕があれば足す
// priority=3: だいぶ余裕があるときに足す
const SLOT_FIELD_DEFS = [
  // ★ 最重要
  { key: 'io',    priority: 1 }, // 入 / 外 / 当
  { key: 'name',  priority: 1 }, // 氏名
  { key: 'pid',   priority: 2 }, // ID（#なし10桁）
  { key: 'age',   priority: 3 }, // 年齢（半角数字3桁）  
  { key: 'eye',   priority: 1 }, // 眼（R/L/B）
  { key: 'iol',   priority: 1 }, // IOL種類・度数
  { key: 'proc1', priority: 1 }, // 術式1（メイン）
  { key: 'proc2', priority: 1 }, // 術式2
  { key: 'note',  priority: 1 }, // 備考
];

// ID 表示用：# を削って最大10桁にそろえる
function formatSlotId(raw){
  if (!raw) return '';
  const s = toHalfWidthNum(String(raw)).replace(/^#/, '');
  return s.slice(0, 10);
}

// スロット幅(px)から「どの priority まで出すか」を決める
function getSlotMaxPriority(width){
  if (!width || width <= 0) return 1;

  // ★ 印刷モード中は、幅に関係なく「全部出す」
  if (document.body && document.body.classList.contains('printMode')){
    return 3;
  }

  // 通常画面時のしきい値
  // 〜300px：最小限（priority 1 のみ）
  // 〜520px：priority 1 & 2（IDまで）
  // 520px〜 ：priority 1〜3（年齢・備考まで）
  if (width < 400) return 1;
  if (width < 520) return 2;
  return 3;
}


/**
 * スロット左側の「優先表示」テキストを生成する
 *  - data : loadWeek() で得た1件分データ
 *  - width: このスロットの横幅(px)
 *
 * 返り値: 「入｜氏名｜ID｜眼｜IOL｜術式1｜…」のような「｜」区切りテキスト
 *   （術者はここには含めない：右端バッジで表示）
 */
function buildSlotMainText(data, width){
  if (!data) return '';

  const maxPri = getSlotMaxPriority(width);
  const texts = [];

  for (const def of SLOT_FIELD_DEFS){
    // 今回の幅では表示対象外の priority はスキップ
    if (def.priority > maxPri) continue;

    let val = '';

    switch(def.key){
      case 'io':
        val = data.io || '';
        break;

      case 'name':
        val = data.name || '';
        break;

      case 'pid':
        val = formatSlotId(data.pid);
        break;

      case 'eye':
        val = (data.eye || '').trim();
        break;

      case 'iol': {
        let p = (data.iolPower || '').toString().trim();
        if (p && !isNaN(Number(p))) p = Number(p).toFixed(1);
        val = `${(data.iolType || '').trim()} ${p}`.trim();
        break;
      }

      case 'proc1': {
        const p1 = String(data.proc1 || '').trim();
        const p2 = String(data.proc2 || '').trim();
        val = [p1, p2].filter(Boolean).join(' ');
        break;
      }

      case 'proc2':
        // proc1 側に統合するのでここでは何も表示しない
        val = '';
        break;

      case 'note':
        val = data.note ? `※${data.note}` : '';
        break;

      // age を使う場合：
      // case 'age':
      //   val = data.age ? String(toHalfWidthNum(data.age)) : '';
      //   break;
    }

    if (!val) continue;
    texts.push(val);
  }

  if (!texts.length) return '';

  return texts.join('｜');
}

// 幅に応じて「表示する項目の配列」を返す（文字列ではなく部品）
function buildSlotMainParts(data, width){
  if (!data) return [];

  const maxPri = getSlotMaxPriority(width);
  const parts = [];

  for (const def of SLOT_FIELD_DEFS){
    if (def.priority > maxPri) continue;

    let val = '';

    switch(def.key){
      case 'io':
        val = data.io || '';
        break;

      case 'name':
        val = data.name || '';
        break;

      case 'pid':
        val = formatSlotId(data.pid);
        break;
		
     case 'age':
       // 半角数字3桁相当で表示（toHalfWidthNum は既存関数）
       val = data.age ? String(toHalfWidthNum(data.age)) : '';
       break;
 		

      case 'eye':
        val = (data.eye || '').trim();
        break;

      case 'iol': {
        let p = (data.iolPower || '').toString().trim();
        if (p && !isNaN(Number(p))) p = Number(p).toFixed(1);
        val = `${(data.iolType || '').trim()} ${p}`.trim();
        break;
      }

      case 'proc1':
        val = data.proc1 || '';
        break;

      case 'proc2':
        val = data.proc2 || '';
        break;

      case 'note':
        val = data.note ? `※${data.note}` : '';
        break;
    }

    if (!val) continue;

    parts.push({ key: def.key, label: val });
  }

  return parts;
}

// 既存の buildSlotMainText があれば、こうしておくと他の場所でも使える
function buildSlotMainText(data, width){
  const parts = buildSlotMainParts(data, width);
  return parts.map(p => p.label).join('｜');
}

// === ここまで：週表示スロット用「優先表示」テキスト生成機能 ===



// 保存済みデータで画面の各スロットを塗り直す
function paintSlotsFromStore(){
  const st = (typeof loadWeek === 'function') ? loadWeek(currentMonday) : {};
  const em = loadEmerg(currentMonday) || {}; // ← 今週の緊急マップを読む

  // ★ RLセット情報を事前に集計（rlSetId → headキー配列）
  const rlSets = {};
  Object.keys(st).forEach(k => {
    const rec = st[k];
    if (!rec || rec.tail) return;                // tail は対象外（headだけ目印にする）
    const id = rec.meta && rec.meta.rlSetId;
    if (!id) return;
    if (!rlSets[id]) rlSets[id] = [];
    rlSets[id].push(k);
  });
  // DOM順に近い並びになるよう、キー文字列でソートしておく
  Object.values(rlSets).forEach(arr => arr.sort());

  // フォールバック用の親フラグを一度リセット
  document.querySelectorAll('.day, .slots').forEach(n => n.classList.remove('has-emergency'));

  // 内容（左テキスト＋術者タグ）
  document.querySelectorAll('.slot').forEach(el=>{
    const key  = el.dataset.key;
    const data = st[key];
    const left = el.querySelector('.content-left');
    const surg = el.querySelector('.surgeon-tag');

    // いったん初期化
    el.classList.remove('empty','mergeHead','hiddenRow',
                        'rl-set-slot','rl-set-top','rl-set-bottom');
    el.style.gridRowEnd = '';

    // ★ 緊急フラグをDOMに反映（ここが唯一の反映ポイントでOK）
    const isEm = !!(key && em[key]);
    el.classList.toggle('emergency-slot', isEm);
    if (isEm){
      // :has 非対応ブラウザ向けに親へフォールバックフラグ
      el.closest('.day')?.classList.add('has-emergency');
      el.closest('.slots')?.classList.add('has-emergency');
      el.tabIndex = 0; // キーボード選択可（任意）
    }
 
     // ★ 感染症フラグの反映（週表示）
     const infValue = data?.infection || '';
     el.classList.remove('infection-slot', 'noninfection-slot');
 
     if (infValue === 'あり') {
       el.classList.add('infection-slot');
     } else if (infValue === 'なし') {
       el.classList.add('noninfection-slot');
     }

     // ★ RLセット用の左バークラスを付与
     if (data && data.meta && data.meta.rlSetId) {
       const id = data.meta.rlSetId;
       const arr = rlSets[id];
       if (arr && arr.length > 1) {
         el.classList.add('rl-set-slot');
         const pos = arr.indexOf(key);
         if (pos === 0) {
           el.classList.add('rl-set-top');
         }
         if (pos === arr.length - 1) {
           el.classList.add('rl-set-bottom');
         }
       }
     }

    if (data && !data.tail) {
    // 本体（head も含む）

    const isMergedHead = !!data.head && Number(data.span || 1) > 1;

    try {
      // ▼ 幅を一度だけ計測（単枠・結合枠どちらでも共通）
      let width = 0;
      const contentWrap = el.querySelector('.content');
      if (contentWrap) {
        const rect = contentWrap.getBoundingClientRect();
        width = (rect && rect.width) || 0;
      }
      const safeWidth = width || 9999;

      if (typeof buildSlotMainParts === 'function') {
        // ★ 単枠と同じ優先表示ロジックで parts を作る
        let parts = buildSlotMainParts(data, safeWidth);

        // ★ 結合枠(head)のときだけ：備考を「おまけ」で必ず末尾に追加
        if (isMergedHead && data.note) {
          const hasNote = parts.some(p => p.key === 'note');
          if (!hasNote) {
            parts = parts.concat({ key:'note', label:'※' + data.note });
          }
        }

        renderSlotColumns(left, parts);

      } else if (typeof fmtContent === 'function') {
        left.innerHTML = fmtContent(data);
      } else {
        const fallbackText = [
          data.io, data.name, data.pid, data.age, data.eye,
          data.iolType, data.iolPower,
          data.note
        ].filter(Boolean).join('｜');
        const fallbackParts = fallbackText.split('｜').map((v,i)=>({ key:'col'+i, label:v }));
        renderSlotColumns(left, fallbackParts);
      }
    } catch (e) {
      // 何かあっても旧仕様にフォールバック
      if (typeof fmtContent === 'function') {
        left.innerHTML = fmtContent(data);
      } else {
        left.textContent = [
          data.io, data.name, data.pid, data.age, data.eye,
          data.iolType, data.iolPower,
          data.proc1, data.proc2,
          data.note
        ].filter(Boolean).join(' / ');
      }
    }

  surg.textContent = data.surgeon ? String(data.surgeon) : '';
  el.classList.remove('empty');

  // ▼▼ 結合バッジの表示内容を「◯◯分」にする ▼▼
  // 対象：結合head（span>1）。所要時間があればそれを優先、なければ span×20分
  (function(){
    const span = Number(data.span || 1);
    if (span <= 1) return; // 単枠は従来通りバッジなし
    const durNum = Number(data.duration || 0);
    const displayMin = (Number.isFinite(durNum) && durNum > 0) ? durNum : (span * 20);
    // 既存の結合バッジ候補を探す（環境差分に対応）
    const badge = el.querySelector('.merge-badge, .span-badge, .mergeSpan-badge, .badge-merge');
    if (badge) {
      badge.textContent = `${displayMin}分`;      // 表示を「○○分」に
      badge.setAttribute('aria-label', `${displayMin}分`);
      badge.title = `${displayMin}分`;
    }
  })();
  // ▲▲ ここまで ▼▼
 
      // ▼▼ 感染症バッジ（すべての「感染あり」スロット） ：備考列の先頭に表示 ▼▼
      // 既存の感染症バッジを一旦削除
      el.querySelectorAll('.infection-badge')?.forEach(n => n.remove());

      const isInf = data.infection === 'あり';

      if (isInf) {
        // rAFで他要素（本文・備考）の描画完了を待ってから差し込む
        requestAnimationFrame(() => {
          if (!document.body.contains(el)) return;

          const badge = document.createElement('span');
          badge.className = 'infection-badge';
          badge.textContent = '感染'; // 2文字

          // 1) 備考列（slot-col-note）があれば、その先頭にバッジを入れる
          const noteCol = el.querySelector('.slot-col-note');
          if (noteCol) {
            // コメントの「末尾」にバッジを付ける
            // 先にスペース → そのあとバッジを追加
            noteCol.insertAdjacentText('beforeend', ' ');
            noteCol.insertAdjacentElement('beforeend', badge);
            return;
          }

          // 2) 備考列がない場合：content-left の末尾に簡易 note 列を作ってそこに入れる
          const left = el.querySelector('.content-left');
          if (left) {
            const wrapper = document.createElement('span');
            wrapper.className = 'slot-col-note';
            wrapper.appendChild(badge);
            left.appendChild(wrapper);
            return;
          }

          // 3) それも無ければ最後の保険として time の末尾に付ける
          (el.querySelector('.time') || el).appendChild(badge);
        });
      }
      // ▲▲ ここまで感染症バッジ ▲▲

    } else if (data && data.tail) {
      // tail 行はあとでまとめて非表示にする
      left.textContent = '（空）';
      surg.textContent = '';
      el.classList.add('empty');

    } else {
      left.textContent = '（空）';
      surg.textContent = '';
      el.classList.add('empty');
    }
  });

   // 結合表示＋バッジ（初回描画も含め常に applyMerges() に統一）
   document.querySelectorAll('.slots').forEach(container=>{
     applyMerges(container, st);
   });
}

// 「項目ごとの部品配列」から列付き DOM を組み立てる
// parts: [{ key:'io', label:'入' }, ...]
function renderSlotColumns(leftEl, parts){
  if (!leftEl) return;
  const items = parts || [];
  if (!items.length){
    leftEl.textContent = '（空）';
    return;
  }

  leftEl.textContent = '';

  items.forEach((part, idx) => {
    const key = part.key;
    const label = String(part.label ?? '').trim();
    if (!label) return;

    const prev = items[idx - 1];
    // 2個目以降の前に「｜」セパレーター（ただし proc1 → proc2 の間は除く）
    if (idx > 0){
      const prevKey = prev?.key;
      if (!(prevKey === 'proc1' && key === 'proc2')){
        const sep = document.createElement('span');
        sep.className = 'slot-sep';
        sep.textContent = '｜';
        leftEl.appendChild(sep);
      }
    }

    const col = document.createElement('span');
    col.className = 'slot-col slot-col-' + key;  // ★ ここがポイント：「項目名ベース」

    // 眼だけ eye-mark で強調
    if (key === 'eye' && (label === 'R' || label === 'L' || label === 'B')){
      const eye = document.createElement('span');
      eye.className = 'eye-mark';
      eye.textContent = label;
      col.appendChild(eye);
    }
    // 術式2（デバイス系）はバッジ表示
    else if (key === 'proc2') {
      const badge = document.createElement('span');
      badge.className = 'proc2-badge';
      badge.textContent = label;
      col.appendChild(badge);
    }
    // それ以外は通常テキスト
    else {
      col.textContent = label;
    }

    leftEl.appendChild(col);
  });
}


/* ======================  旧版→新コード 拡張層  ====================== */

/** 週データ（手術枠）ストア：schedule_<week> */
function loadWeek(date){ try{ const k='schedule_'+weekKey(date); return JSON.parse(localStorage.getItem(k))||{}; }catch(_){ return {}; } }
function saveWeek(date,data){
  const k = 'schedule_' + weekKey(date);
  localStorage.setItem(k, JSON.stringify(data || {}));
}


/** Undo スナップショット＆復元に schedule を統合 */
const __snapshotState = snapshotState;
snapshotState = function(){
  const base = __snapshotState();
  base.schedule = loadWeek(currentMonday);
  return base;
};
const __restoreState = restoreState;
restoreState = function(snap){
  __restoreState(snap);
  if (snap && snap.schedule){
    localStorage.setItem('schedule_'+weekKey(currentMonday), JSON.stringify(snap.schedule||{}));
  }
};

/** 共通ユーティリティ */
function parseKey(key){ const [d,day,section,idx] = key.split('|'); return {d,day,section:Number(section),idx:Number(idx)}; }
function slotKey(meta){ return `${meta.d}|${meta.day}|${meta.section}|${meta.idx}`; }
function deepClone(o){ return JSON.parse(JSON.stringify(o)); }
function toHalfWidthNum(str){ if(str==null) return ""; return String(str).replace(/[！-～]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0)); }
function normalizeDiopter(s){ if(!s) return ''; const v = Number(String(s).replace(',', '.')); return isFinite(v) ? v.toFixed(1) : s; }
function normalizePatientFields(obj){
  if(!obj) return obj;
  const o = {...obj};
  if(o.pid != null) o.pid = toHalfWidthNum(o.pid).trim();
  if(o.age != null) o.age = toHalfWidthNum(o.age).trim();
  return o;
}

/** ---- 印刷フィルタ用：付け外し簡易ユーティリティ ---- */
const __PRINT_HIDDEN = new Set();
function __hideForPrint(el){ if(!el) return; el.classList.add('hide-on-print'); __PRINT_HIDDEN.add(el); }
function __clearPrintHides(){ __PRINT_HIDDEN.forEach(el=>el.classList.remove('hide-on-print')); __PRINT_HIDDEN.clear(); }

/**
 * 指定の1日のラップ（buildDayが返す wrap）で、残したいセクションだけを印刷する。
 * keepIdxes は [0]（午前）/ [1]（午後1）/ [2]（午後8）/ [0,1]（午前+午後1）など。
 */
function printDayKeepSections(dayWrap, keepIdxes){
  // 他の曜日は全部隠す
  document.querySelectorAll('.day').forEach(d => { if(d !== dayWrap) __hideForPrint(d); });
  // ヘッダー以外のUIも隠す（topbar等）
  __hideForPrint(document.querySelector('.topbar'));

  // dayWrap 内の .section-title と 直後の .slots をペア取り
  const kids = Array.from(dayWrap.children);
  const pairs = [];
  for (let i=0; i<kids.length; i++){
    if (kids[i].classList?.contains('section-title')){
      const t = kids[i];
      const s = kids[i+1] && kids[i+1].classList?.contains('slots') ? kids[i+1] : null;
      if (s) pairs.push([t,s]);
    }
  }
  // 不要なセクションを隠す
  pairs.forEach((pair, idx) => {
    if (!keepIdxes.includes(idx)) {
      __hideForPrint(pair[0]);
      __hideForPrint(pair[1]);
    }
  });

  // 印刷 → 後始末
  try { window.print(); }
  finally { __clearPrintHides(); }
}

// --- 選択印刷用：一時コンテナ ---
function ensurePrintSandbox(){
  let box = document.getElementById('printSandbox');
  if(!box){
    box = document.createElement('div');
    box.id = 'printSandbox';
    // 画面では非表示（印刷時だけ表示）
    box.style.display = 'none';
    document.body.appendChild(box);
  }
  box.innerHTML = '';
  return box;
}
function clearPrintSandbox(){
  const box = document.getElementById('printSandbox');
  if(box) box.innerHTML = '';
}

// 印刷用：感染症バッジを備考（note）の末尾に差し込む
function addInfectionBadgesForPrint(slotsRoot){
  try {
    const store = loadWeek(currentMonday);
    if (!store) return;

    // 対象スロットを走査
    const slots = slotsRoot.querySelectorAll('.slot[data-key]');
    slots.forEach(slot => {
      // 既存の感染バッジは一旦削除（重複防止）
      slot.querySelectorAll('.infection-badge').forEach(n => n.remove());

      const key  = slot.dataset.key;
      const rec  = store[key];
      if (!rec) return;
      if (rec.tail) return;                     // tail 行はスキップ
      if (rec.infection !== 'あり') return;     // 感染フラグなし

      // バッジ生成
      const badge = document.createElement('span');
      badge.className = 'infection-badge';
      badge.textContent = '感染';

      // 1) 備考列があれば、その「末尾」に入れる
      let noteCol = slot.querySelector('.slot-col-note');
      if (noteCol) {
        noteCol.insertAdjacentText('beforeend', ' ');
        noteCol.insertAdjacentElement('beforeend', badge);
        return;
      }

      // 2) 備考列がない場合：content-left の末尾に簡易 note 列を作成してそこに入れる
      const left = slot.querySelector('.content-left');
      if (left) {
        noteCol = document.createElement('span');
        noteCol.className = 'slot-col slot-col-note';
        // 「※」を付けておくと他の備考と並びが自然
        noteCol.textContent = '※';
        noteCol.insertAdjacentText('beforeend', ' ');
        noteCol.insertAdjacentElement('beforeend', badge);
        left.appendChild(noteCol);
        return;
      }

      // 3) 最後の保険：time 行の末尾に付ける
      (slot.querySelector('.time') || slot).appendChild(badge);
    });
  } catch (e) {
    console.warn('addInfectionBadgesForPrint failed:', e);
  }
}

function printSection(slotsEl){
  if(!slotsEl) return;

  const box = ensurePrintSandbox();

  // タイトル（曜日・日付・セクション名）を拾って載せる
  const day = slotsEl.closest('.day');
  const titleEl = day?.querySelector('.day-header-date')?.cloneNode(true) || null;
  const sectionTitle = slotsEl.previousElementSibling?.classList?.contains('section-title')
    ? slotsEl.previousElementSibling.cloneNode(true) : null;

  // 印刷用に感染バッジを注入（備考欄の末尾）
  addInfectionBadgesForPrint(slotsEl);

  // 複製（見た目を保つため slots を丸ごと clone）
  const clone = slotsEl.cloneNode(true);


  // ラッパー
  const wrap = document.createElement('section');
  wrap.className = 'day'; // 既存スタイルをそのまま使うため
  const head = document.createElement('div');
  head.className = 'day-header';
  if(titleEl) head.appendChild(titleEl);
  box.appendChild(wrap);
  wrap.appendChild(head);
  if(sectionTitle) wrap.appendChild(sectionTitle);
  wrap.appendChild(clone);

  // 印刷フラグを付けて印刷
  document.body.classList.add('printRange');
  try {
    window.print();
  } finally {
    document.body.classList.remove('printRange');
    clearPrintSandbox();
  }
}

function printDayElement(dayEl){
  if (!dayEl) return;
  const days = document.querySelectorAll('#schedule .day');
  days.forEach(d => { if (d !== dayEl) d.classList.add('hide-on-print'); });

  // この日の緊急/臨時枠の数に応じて圧縮レベルを決める
  const cnt = dayEl.querySelectorAll('.slot.emergency-slot, .slot.temp-slot').length;
  let level = 0;
  if (cnt >= 1 && cnt <= 2) {
    dayEl.classList.add('print-tight');
    level = 1;
  } else if (cnt >= 3) {
    dayEl.classList.add('print-tighter');
    level = 2;
  }

  try {
    window.print();
  } finally {
    days.forEach(d => d.classList.remove('hide-on-print'));
    if (level === 1) dayEl.classList.remove('print-tight');
    if (level === 2) dayEl.classList.remove('print-tighter');
  }
}


// ひらがな→カタカナ→半角カタカナ
function toHalfWidthKana(str){
  if (!str) return "";
  // 1) ひらがな → カタカナ
  str = str.replace(/[\u3041-\u3096]/g, ch =>
    String.fromCharCode(ch.charCodeAt(0) + 0x60)
  );
  // 2) 全角カタカナ → 半角カタカナ（主要文字を網羅）
  const map = {
    '。':'｡','、':'､','・':'･','「':'｢','」':'｣','ー':'ｰ','゛':'ﾞ','゜':'ﾟ',
    'ァ':'ｧ','ア':'ｱ','ィ':'ｨ','イ':'ｲ','ゥ':'ｩ','ウ':'ｳ','ェ':'ｪ','エ':'ｴ','ォ':'ｫ','オ':'ｵ',
    'カ':'ｶ','ガ':'ｶﾞ','キ':'ｷ','ギ':'ｷﾞ','ク':'ｸ','グ':'ｸﾞ','ケ':'ｹ','ゲ':'ｹﾞ','コ':'ｺ','ゴ':'ｺﾞ',
    'サ':'ｻ','ザ':'ｻﾞ','シ':'ｼ','ジ':'ｼﾞ','ス':'ｽ','ズ':'ｽﾞ','セ':'ｾ','ゼ':'ｾﾞ','ソ':'ｿ','ゾ':'ｿﾞ',
    'タ':'ﾀ','ダ':'ﾀﾞ','チ':'ﾁ','ヂ':'ﾁﾞ','ッ':'ｯ','ツ':'ﾂ','ヅ':'ﾂﾞ','テ':'ﾃ','デ':'ﾃﾞ','ト':'ﾄ','ド':'ﾄﾞ',
    'ナ':'ﾅ','ニ':'ﾆ','ヌ':'ﾇ','ネ':'ﾈ','ノ':'ﾉ',
    'ハ':'ﾊ','バ':'ﾊﾞ','パ':'ﾊﾟ','ヒ':'ﾋ','ビ':'ﾋﾞ','ピ':'ﾋﾟ','フ':'ﾌ','ブ':'ﾌﾞ','プ':'ﾌﾟ','ヘ':'ﾍ','ベ':'ﾍﾞ','ペ':'ﾍﾟ','ホ':'ﾎ','ボ':'ﾎﾞ','ポ':'ﾎﾟ',
    'マ':'ﾏ','ミ':'ﾐ','ム':'ﾑ','メ':'ﾒ','モ':'ﾓ',
    'ャ':'ｬ','ヤ':'ﾔ','ュ':'ｭ','ユ':'ﾕ','ョ':'ｮ','ヨ':'ﾖ',
    'ラ':'ﾗ','リ':'ﾘ','ル':'ﾙ','レ':'ﾚ','ロ':'ﾛ',
    'ワ':'ﾜ','ヲ':'ｦ','ン':'ﾝ','ヴ':'ｳﾞ','ヵ':'ｶ','ヶ':'ｹ'
  };
  return str.replace(/[\u30A1-\u30FA\u30FC\u309B\u309C\u3001\u3002\u30FB\u300C\u300D]/g, ch => map[ch] || ch);
}

function flipEye(v){ if(!v) return v; if(v==='R') return 'L'; if(v==='L') return 'R'; if(v==='右') return '左'; if(v==='左') return '右'; return v; }

/** 週表示用：優先表示＋「｜」区切りテキストを生成 */
function fmtContent(d){
  if (!d) return '';

  const core = [];      // 重要項目（常に優先して入れる）
  const optional = [];  // 枠に余裕があるときに足していく項目

  // 1) 入院/外来/当日
  let ioLabel = d.io || '';
  // もし「当日」の情報を別に持たせるなら、ここで付け足せる
  // if (d.sameDay) ioLabel = (ioLabel ? ioLabel : '') + '当';
  if (ioLabel) core.push(ioLabel);

  // 2) 氏名
  if (d.name) core.push(d.name);

  // 3) 患者ID（#なし10桁）
  if (d.pid){
    const id = toHalfWidthNum(String(d.pid)).replace(/^#/, '').slice(0, 10);
    core.push(id);
  }

  // 4) 眼（右/左/両）
  if (d.eye){
    core.push(String(d.eye).trim());
  }

  // 5) IOL種類・度数
  if (d.iolType || d.iolPower){
    let p = (d.iolPower || '').toString().trim();
    if (p && !isNaN(Number(p))) p = Number(p).toFixed(1);
    const iol = `${(d.iolType || '').trim()} ${p}`.trim();
    if (iol) core.push(iol);
  }

  // 6) 術式1+2：まとめて1フィールドとして扱う
  if (d.proc1 || d.proc2){
    const procLabel = [d.proc1, d.proc2]
      .map(v => String(v || '').trim())
      .filter(Boolean)
      .join(' ');
    if (procLabel) core.push(procLabel);
  }

  // 7) 備考は「枠に余裕があるとき」に追加
  if (d.note)  optional.push('※' + d.note);

  // --- ここから「長さ」に応じてどこまで入れるか決める ---

  // まず「重要項目だけ」で組み立て
  let text = core.join('｜');
  const lenCore = text.length;

  // ざっくりしきい値（必要ならあとで調整）
  const MAX_NARROW = 24; // 狭い枠：このくらいまで
  const MAX_MEDIUM = 40; // そこそこ広い枠

  if (optional.length === 0){
    // 追加項目が何もないならそのまま
    return text;
  }

  if (lenCore <= MAX_NARROW){
    // かなり短い → optional も全部入れてしまう
    text = core.concat(optional).join('｜');
  } else if (lenCore <= MAX_MEDIUM){
    // そこそこ → optional の先頭だけ足す
    text = core.concat(optional[0]).join('｜');
  }
  // それ以上長いときは core だけ（＝狭い枠は重要項目のみ）

  return text;
}

/** datalist（最低限） */
(function ensureDatalists(){
  const powers=[]; for(let v=15.0; v<=30.001; v+=0.5){ powers.push(v.toFixed(1)); }
  const types=["AcrySof IQ","TECNIS","HOYA Vivinex","PanOptix","EDOF"];
  const dlT = document.getElementById('iolTypes'); const dlP = document.getElementById('iolPowers');
  if(dlT && !dlT.children.length) types.forEach(v=>{const o=document.createElement('option');o.value=v;dlT.appendChild(o);});
  if(dlP && !dlP.children.length) powers.forEach(v=>{const o=document.createElement('option');o.value=v;dlP.appendChild(o);});
})();


const multiSelected = new Set();
function clearMultiSelection(){
  multiSelected.forEach(k=>{
    const el = document.querySelector(`.slot[data-key="${k}"]`);
    if(el) el.classList.remove('multiSelected');
  });
  multiSelected.clear();
}
function addMultiSelect(el){
  const k = el?.dataset?.key; if(!k) return;
  if(!multiSelected.has(k)){ multiSelected.add(k); el.classList.add('multiSelected'); }
}
function findRangeSameDay(aEl,bEl){
  const day = aEl.closest('.day');
  if (!day || day !== bEl.closest('.day')) return [];

  // ★ 同じ .slots（同じセクション）内かチェック
  const secA = aEl.closest('.slots');
  const secB = bEl.closest('.slots');
  if (!secA || secA !== secB) return [];  // セクションまたぎ禁止

  const list = Array.from(secA.querySelectorAll('.slot'));
  const i = list.indexOf(aEl), j = list.indexOf(bEl);
  if (i < 0 || j < 0) return [];
  const [s,e] = i <= j ? [i,j] : [j,i];
  return list.slice(s, e + 1);
}
// === 複数空枠選択 → 結合枠生成（Ctrl+M 用） ===
function createMergeFromMultiSelection(){
  if (!multiSelected || multiSelected.size < 2){
    alert('結合枠を作成するには、同じセクション内の空枠を2枠以上選択してください。');
    return;
  }

  // 適当な1つのキーから container(.slots) を特定
  const anyKey = Array.from(multiSelected)[0];
  const anyEl  = document.querySelector(`.slot[data-key="${CSS.escape(anyKey)}"]`);
  if (!anyEl){
    alert('選択中の枠が見つかりません。');
    return;
  }
  const container = anyEl.closest('.slots');
  if (!container){
    alert('結合枠の作成に失敗しました（セクションが特定できません）。');
    return;
  }

  const list = Array.from(container.querySelectorAll('.slot'));
  const selKeys = new Set(Array.from(multiSelected));

  // firstIdx / lastIdx を求める
  let firstIdx = -1;
  let lastIdx  = -1;
  for (let i = 0; i < list.length; i++){
    const k = list[i].dataset.key;
    if (selKeys.has(k)){
      if (firstIdx === -1) firstIdx = i;
      lastIdx = i;
    }
  }
  if (firstIdx === -1 || lastIdx === -1){
    alert('選択範囲を特定できませんでした。');
    return;
  }

  // 途中に「選択されていない」枠が混じっていたらNG（連続のみ対応）
  for (let i = firstIdx; i <= lastIdx; i++){
    const k = list[i].dataset.key;
    if (!selKeys.has(k)){
      alert('途中に選択されていない枠が含まれています。連続した空枠だけを選択してください。');
      return;
    }
  }

  // スケジュールデータを確認して「空枠のみ」かチェック
  const st = loadWeek(currentMonday);
  for (let i = firstIdx; i <= lastIdx; i++){
    const el = list[i];
    const k  = el.dataset.key;
    const rec = st[k];

    // hiddenRow や既存データがあれば NG
    if (el.classList.contains('hiddenRow') || (rec && Object.keys(rec).length > 0)){
      alert('データが入っている枠、または結合枠の一部が含まれています。空の枠だけを選択してください。');
      return;
    }
  }

  const span = (lastIdx - firstIdx + 1);
  if (span <= 1){
    alert('結合枠を作成するには、2枠以上を選択してください。');
    return;
  }

  const headEl  = list[firstIdx];
  const headKey = headEl.dataset.key;
  const { day, section } = parseKey(headKey);

  // 所要時間は「20分×枠数」で自動設定
  const durationMinutes = span * 20;

  // === ここから Undo バッチ（結合＋最初の編集までまとめる） ===
  let startedHere = false;
  if (!inUndoBatch()){
    beginUndoBatch();
    startedHere = true;
  }

  try {
    // 対象範囲の既存レコードはいったん全クリア（念のため）
    for (let i = firstIdx; i <= lastIdx; i++){
      const k = list[i].dataset.key;
      delete st[k];
    }

    // head をセット
    st[headKey] = {
      head: true,
      span: span,
      duration: durationMinutes
    };

    // tail をセット
    for (let i = firstIdx + 1; i <= lastIdx; i++){
      const k = list[i].dataset.key;
      st[k] = { tail: true, head: headKey };
    }

    // この day/section のアンカーを一括再構築
    rebuildDurationAnchorsForDaySection(day, section, st);

    // 保存
    saveWeek(currentMonday, st);

    // 描画・フォーカス復帰：head を基準に
    reRenderPreservingFocus(headKey);

    // 複数選択はクリアしておく
    clearMultiSelection();

    // head をアクティブ＆エディタ起動
    const headElAfter = document.querySelector(`.slot[data-key="${CSS.escape(headKey)}"]`);
    if (headElAfter) {
      setActiveSlot(headElAfter);
      if (typeof openEditor === 'function') {
        openEditor([headKey]);
      }
    }

    // ここで開いたバッチは「エディタの保存まで」まとめて閉じたいのでフラグを立てる
    if (startedHere){
      mergeEditBatchOpen = true;
    }

  } finally {
    // 万一何かの理由でフラグが立たなかった場合の保険（通常はここは通らない想定）
    if (startedHere && !mergeEditBatchOpen){
      try { endUndoBatch(); } catch(_){}
    }
  }
}


// ==== 複数選択 → 論理ブロック化（単枠 / 結合枠） ====
function buildMultiClipboardFromSelection(store){
  if (!multiSelected || multiSelected.size <= 1) return null;

  // .slot.multiSelected を拾う（同一セクション前提）
  const selectedEls = Array.from(document.querySelectorAll('.slot.multiSelected'));
  if (selectedEls.length <= 1) return null;

  const container = selectedEls[0].closest('.slots');
  if (!container) return null;
  // 念のため：同じ .slots 以外が混じっていたら中止
  if (selectedEls.some(el => el.closest('.slots') !== container)) {
    alert('複数セクションをまたぐ範囲コピーはできません。');
    return null;
  }

  const list = Array.from(container.querySelectorAll('.slot'));
  const selectedKeySet = new Set(selectedEls.map(el => el.dataset.key));

  // 連続範囲の first / last index を決める
  let firstIdx = -1, lastIdx = -1;
  for (let i = 0; i < list.length; i++) {
    const k = list[i].dataset.key;
    if (selectedKeySet.has(k)) {
      if (firstIdx === -1) firstIdx = i;
      lastIdx = i;
    }
  }
  if (firstIdx === -1) return null;

  const blocks = [];
  const usedKeys = new Set();

  for (let i = firstIdx; i <= lastIdx;) {
    const el = list[i];
    const key = el.dataset.key;
    const rec = store[key];

    // 範囲内に「非選択スロット」が混じっていたら中止（穴あきはまだ非対応）
    if (!selectedKeySet.has(key)) {
      alert('途中に非選択スロットが含まれる複数コピーはまだ対応していません。連続した範囲だけを選択してください。');
      return null;
    }

    if (!rec) {
      alert('空の枠を含む複数コピーにはまだ対応していません。');
      return null;
    }

    // tail だけから始まる → 結合枠の途中選択なので中止
    if (rec.tail) {
      if (!rec.head || !usedKeys.has(rec.head)) {
        alert('結合枠の途中だけが選択されています。結合枠は全体を含めて選択してください。');
        return null;
      }
      i++;
      continue;
    }

    // head かつ span>1 → 結合枠ブロック
    if (rec.head && Number(rec.span || 1) > 1) {
      const span = Number(rec.span || 1);

      // ★ span 分だけ下に tail が存在するか（セクション内に収まるか）だけを確認
      if (i + span - 1 >= list.length) {
        alert('結合枠の構造が不正です（範囲外に伸びています）。');
        return null;
      }

      const keys = [];
      for (let j = 0; j < span; j++) {
        const el2 = list[i + j];
        if (!el2) return null;
        const k2 = el2.dataset.key;
        const rec2 = store[k2];

        if (!rec2) {
          alert('結合枠の構造が不正です（途中に空枠があります）。');
          return null;
        }

        if (j === 0) {
          // 先頭行：選択されている & head であることをチェック
          if (!selectedKeySet.has(k2) || !rec2.head) {
            alert('結合枠の先頭が選択されていません。結合枠は先頭行から選択してください。');
            return null;
          }
        } else {
          // tail 行：tail であり、同じ head を指していることだけ確認
          // （tail 自体が multiSelected である必要はない）
          if (!rec2.tail || rec2.head !== key) {
            alert('結合枠の途中だけが選択されています。');
            return null;
          }
        }

        keys.push(k2);
        usedKeys.add(k2);
      }

      blocks.push({
        kind: 'merge',
        span,
        data: deepClone(rec),
        keys
      });
      i += span;
      continue;
    }


    // 通常の単枠
    blocks.push({
      kind: 'single',
      span: 1,
      data: deepClone(rec),
      keys: [key]
    });
    usedKeys.add(key);
    i++;
  }

  if (blocks.length === 0) return null;

  const { d, day, section } = parseKey(list[firstIdx].dataset.key);
  return { day, section, blocks };
}

function updateMultiRangeOutline(){
  // 既存の枠を全て削除
  document.querySelectorAll('.multiRangeOutline').forEach(el => el.remove());

  if (!multiSelected || multiSelected.size === 0) return;

  // 現在 multiSelected が付いているスロットを取得
  const all = Array.from(document.querySelectorAll('.slot.multiSelected'));
  if (all.length === 0) return;

  // ★ 基準にするセクション（.slots）を決める
  const container = all[0].closest('.slots');
  if (!container) return;

  // ★ 同じセクション内 ＋ hiddenRow 以外だけを対象にする
  const targets = all.filter(el =>
    el.closest('.slots') === container &&
    !el.classList.contains('hiddenRow')
  );
 // 単枠 or 0枠なら外周枠は不要（青枠は .slot.focused に任せる）
 if (targets.length <= 1) return;

  const crect = container.getBoundingClientRect();
  let top = Infinity;
  let bottom = -Infinity;

  // 選択スロット群の最上部と最下部（head だけ）を計算
  for (const s of targets){
    const r = s.getBoundingClientRect();
    const t = r.top    - crect.top;
    const b = r.bottom - crect.top;
    if (t < top)   top    = t;
    if (b > bottom) bottom = b;
  }

  if (!Number.isFinite(top) || !Number.isFinite(bottom) || bottom <= top) return;

  const outline = document.createElement('div');
  outline.className = 'multiRangeOutline';
  outline.style.top = `${top}px`;
  outline.style.height = `${bottom - top}px`;

  container.appendChild(outline);
}


// === スロット共通クリックハンドラ（単体／Shiftで連続範囲） ===
document.addEventListener('click', (e) => {
  // 入力中（エディタ内など）は無視
  if (typeof isTypingContext === 'function' && isTypingContext(e)) return;

  const slot = e.target.closest('.slot');
  if (!slot) return;

  // schedule 外の .slot は無視（念のため）
  const sched = document.getElementById('schedule');
  if (!sched || !sched.contains(slot)) return;

  if (typeof isSlotLockedForEdit === 'function' && isSlotLockedForEdit(slot)) return;

  const cur = (typeof getActiveSlot === 'function') ? getActiveSlot() : null;

  if (e.shiftKey && cur) {
    // Shift + クリック：同じ日の中で「前回青枠〜今回クリック」までを選択
    clearMultiSelection();
    findRangeSameDay(cur, slot).forEach(addMultiSelect);
  } else {
    // 通常クリック：RLセットがあれば
    //   1回目クリック → セット外周ハイライト
    //   2回目クリック → 単枠モードに移行（このRLセットをロック）
    let handledRL = false;

    // Ctrl+クリック時は既存のマルチ選択ロジックに譲る
    const st = (typeof loadWeek === 'function') ? loadWeek(currentMonday) : null;

    // ★ クリックしたスロットが属する RLセットID を先に特定
    let clickedRlId = null;
    if (st && typeof findRLSetRangeForSlot === 'function') {
      const info0 = findRLSetRangeForSlot(slot, st);
      if (info0 && info0.keys && info0.keys.length > 1) {
        const base0 = st[info0.baseKey];
        clickedRlId = base0?.meta?.rlSetId || null;
      }
    }

    // ★ 別の場所（別RLセット or 非RL枠）をクリックしたらロック解除
    if (window.rlSetSingleLocked && clickedRlId !== window.rlSetSingleLocked) {
      window.rlSetSingleLocked = null;
    }

    if (!e.ctrlKey && st && typeof findRLSetRangeForSlot === 'function') {
      const info = findRLSetRangeForSlot(slot, st);
      if (info && info.keys && info.keys.length > 1) {
        const baseRec = st[info.baseKey];
        const rlId = baseRec?.meta?.rlSetId;
        if (rlId) {
          if (window.rlSetSingleLocked === rlId) {
            // ★ このRLセットは単枠ロック中 → 外周には戻さない（通常クリック扱い）
            // handledRL = false のまま fallback へ
          } else if (window.currentRLSetId === rlId) {
            // ★ 2回目クリック：単枠モードに移行し、このRLセットをロック
            clearMultiSelection();
            window.currentRLSetId = null;
            window.rlSetSingleLocked = rlId;
            handledRL = true;
          } else {
            // ★ 1回目クリック：RLセット全体を multiSelected にして外周枠表示
            clearMultiSelection();
            info.keys.forEach(k => {
              const el2 = document.querySelector(`.slot[data-key="${CSS.escape(k)}"]`);
              if (el2) addMultiSelect(el2);
            });
            window.currentRLSetId = rlId;
            window.rlSetSingleLocked = null; // セットモード中はロックOFF
            handledRL = true;
          }
        }
      }
    }

    if (!handledRL) {
      // RLセット扱いにならない場合は従来通り：マルチ選択はリセットのみ
      clearMultiSelection();
      window.currentRLSetId = null;
      // rlSetSingleLocked は、clickedRlId 判定で必要に応じて解除済み
    }
  }


  // アクティブ枠（青枠）の更新
  if (typeof setActiveSlot === 'function') {
    setActiveSlot(slot);

    // ★ 週表示のときは、クリック選択でも横方向を中央寄せして外枠が見切れないようにする
    if (!document.body.classList.contains('dayFocus')) {
      slot.scrollIntoView({
        block:  'nearest',  // 縦方向は既存のスクロール感をあまり崩さない
        inline: 'center',   // ★ 横方向は中央寄せ（ここがポイント）
        behavior: 'auto'    // アニメーションなしで一発スナップ
      });
    }
  }

  // 連続選択の外周枠を更新
  updateMultiRangeOutline(); 
  // ブラウザのテキスト選択（(空) が青く反転するやつ）を消す
  try {
    const sel = window.getSelection && window.getSelection();
    if (sel && sel.removeAllRanges) sel.removeAllRanges();
  } catch (_){}  
}, true); // ← capture フェーズで動かす

/* ---------- 結合表示（head/tail/span） ---------- */
function applyMerges(container, store){
  const children = Array.from(container.children);
  for(let i=0;i<children.length;i++){
    const el = children[i];
    const data = store[el.dataset.key];

    // まず初期化
    el.style.gridRowEnd = '';
    el.classList.remove('mergeHead','hiddenRow');

    // ★時刻セル内の古いバッジは掃除（F5直後や再描画の取りこぼし防止）
    const timeEl = el.querySelector('.time');
if (timeEl){
      timeEl.querySelectorAll('.merge-badge').forEach(n => n.remove());
      timeEl.querySelectorAll('.ga-badge').forEach(n => n.remove()); // ← 追加
    }
    // tail は見た目を隠すだけ
    if (data && data.tail){
      el.classList.add('hiddenRow');
      continue;
    }

    // head かつ span>1 のとき：縦方向へ結合＋バッジを時刻の下に置く
    if (data && data.head && Number(data.span) > 1){
      const span = Number(data.span);
      el.style.gridRowEnd = `span ${span}`;
      el.classList.add('mergeHead');

      // ★ここを「leftEl に付ける」のではなく timeEl に付ける
      if (timeEl){
        const b = document.createElement('span');
        b.className = 'merge-badge';
        // 所要時間優先（未入力なら span×20 分）
        const dur = Number(data.duration || 0);
        const minutes = (Number.isFinite(dur) && dur > 0) ? dur : (span * 20);
        const label = formatMinutesColon(minutes);
        b.textContent = label;
        b.setAttribute('aria-label', label);
        b.title = label;
        timeEl.appendChild(b);

// ② 全麻 / 局麻バッジ（span>=3 の head スロットに 1 個だけ）
(() => {
  // 既存のバッジを一旦クリア（再描画時の重複防止）
  el.querySelectorAll('.ga-badge, .local-badge').forEach(b => b.remove());

  const spanNum = Number(data.span || 1);
  // head が付いている結合枠（3枠以上）の先頭だけを対象にする
  const isHead = data.head !== false && data.head != null; // head が true のもの
  const isMergedHead3Plus = spanNum >= 3 && isHead;

  if (!isMergedHead3Plus) return;

  if (data.ga) {
    const g = document.createElement('span');
    g.className = 'ga-badge';
    g.textContent = '全麻';
    timeEl.appendChild(g);  // margin-top:auto で最下段に来る
  } else if (data.local) {
    const l = document.createElement('span');
    l.className = 'local-badge';
    l.textContent = '局麻';
    timeEl.appendChild(l);  // 全麻と同じ位置
  }
})();
	
      }

      // 後続の “見た目” 行は隠す
      for (let k=1; k<span; k++){
        const t = children[i+k];
        if (t) t.classList.add('hiddenRow');
      }
    }
  }
}


window.addEventListener('load', () => {
  try {
    paintSlotsFromStore();
  } catch (e) {
    console && console.warn && console.warn('paintSlotsFromStore error on load', e);
  }
});

/* ---------- schedule レンダリングを createSlot にブリッジ ---------- */
const __createSlot = createSlot; // 既存生成を流用
createSlot = function(meta, time){
  const el = __createSlot(meta, time);
  const key = el.dataset.key;


  // ダブルクリックで編集（時間セルは既存 dblclick で占有済みなので除外）
  el.addEventListener('dblclick',(e)=>{
    if(e.target.closest('.time')) return;
  const slotEl = e.currentTarget.closest('.slot');
  if (isSlotLockedForEdit(slotEl)) return;
    openEditor([key]);
  });

  // 祝日・休止でも右クリックは通る（新コードCSSが許可済み）

  // ここで schedule を埋め込む
  const store = loadWeek(currentMonday);
  const d = store[key];
  const leftEl = el.querySelector('.content-left');
  const surgEl = el.querySelector('.surgeon-tag');
  if (d && !d.tail){
    leftEl.innerHTML = fmtContent(d);
    surgEl.textContent = d.surgeon ? String(d.surgeon) : '';
    el.classList.remove('empty');
    if(d.head) el.classList.add('mergeHead');
  }else{
    leftEl.textContent = '（空）';
    surgEl.textContent = '';
    el.classList.add('empty');
  }
  if (d && d.ga) {
    el.classList.add('ga-slot');
  }

  return el;
};

/* ---------- render をフック：結合スパン反映 ---------- */
const __render = render;
render = function(){
  __render();
  const store = loadWeek(currentMonday);
  // 各セクション .slots に対して結合表示を適用
  document.querySelectorAll('.slots').forEach(sl => applyMerges(sl, store));
};

// ひらがな→カタカナ、半角→全角（長音・濁点はそのまま）
function toKatakana(input){
  if (!input) return "";
  // 半角カナ等を正規化してから
  let s = input.normalize('NFKC');
  // ひらがな(U+3041〜3096)をカタカナ(U+30A1〜30F6)へ
  s = s.replace(/[\u3041-\u3096]/g, ch =>
    String.fromCharCode(ch.charCodeAt(0) + 0x60)
  );
  return s;
}

const editor = document.getElementById('editor');
const toggleIolUseBtn = document.getElementById('toggleIolUseRow');

if (editor && toggleIolUseBtn) {
  toggleIolUseBtn.addEventListener('click', () => {
    const on = editor.classList.toggle('showIolDetail');
    toggleIolUseBtn.textContent = on ? 'IOL②・③を隠す' : 'IOL②・③を表示';
  });
}

/* ---------- エディタ ---------- */
function openEditor(keys){
  const editor = document.getElementById('editor');

  // 毎回「IOL①のみ・用途なし」の状態からスタート
  editor.classList.remove('showIolDetail');
  const toggleIolUseBtn = document.getElementById('toggleIolUseRow');
  if (toggleIolUseBtn) {
    toggleIolUseBtn.textContent = 'IOL②・③を表示';
  }
  
  const f = document.getElementById('editorForm');
  const st = loadWeek(currentMonday);

  const clearBtn   = f.querySelector('button[value="clear"]');
  const cancelBtn  = f.querySelector('button[value="cancel"]');
  const saveBtn    = f.querySelector('button[value="save"]');
 // ▼ RLセットチェックボックス制御（眼が R のときだけ有効）
 const rlSetCheckbox = f.querySelector('input[name="rlSet"]');
 const eyeSelect     = f.eye;

  // ▼ 既存RLセット編集時：RLセットチェックを強制OFF＆無効化
  (()=>{
    try {
      const firstKey = keys && keys[0];
      if (!firstKey || !rlSetCheckbox) return;

      // この週のデータから RLセット範囲をキーで検索
      const info =
        (typeof findRLSetRangeForKey === 'function')
          ? findRLSetRangeForKey(firstKey, st)
          : null;

      const isExistingRL =
        info &&
        info.keys &&
        info.keys.length === 2 &&
        (st[info.baseKey]?.meta?.rlSetId);

      if (isExistingRL) {
        // 既存のRLペアの片割れを編集中 → 新規RL作成はさせない
        rlSetCheckbox.checked  = false;
        rlSetCheckbox.disabled = true;
      } else {
        // 既存RLでなければ、（元々のロジックどおり）後続で eye に応じて有効化
        // ここでは disable=false にせず、何もしないか、必要なら初期状態だけ整える
        rlSetCheckbox.disabled = false;
      }
    } catch(e){
      console.warn('RL checkbox guard failed:', e);
    }
  })();

 function guardRLSetCheckbox(showAlert){
   if (!rlSetCheckbox || !eyeSelect) return;
   const eyeVal = (eyeSelect.value || '').trim();

   // 眼が R 以外なのにチェックされていたら強制OFF
   if (rlSetCheckbox.checked && eyeVal !== 'R') {
     if (showAlert) {
       alert('対眼の連続作成は「眼：R」のときにのみ利用できます。\n先に「眼」を R にしてからチェックしてください。');
     }
     rlSetCheckbox.checked = false;
   }
 }

 if (rlSetCheckbox && eyeSelect) {
   // チェックボックスを操作したとき：R 以外ならアラートを出してOFFに戻す
   rlSetCheckbox.addEventListener('change', () => {
     guardRLSetCheckbox(true);
   });

   // 眼の選択を変えたとき：R 以外になったら静かにOFFにする（アラートなし）
   eyeSelect.addEventListener('change', () => {
     guardRLSetCheckbox(false);
   });

   // エディタ初期表示時にも一度判定（前回状態が残っている場合に備えて）
   guardRLSetCheckbox(false);
 }  
 
 try {
    f.iolType?.setAttribute('list', 'iolTypes');
    f.proc1?.setAttribute('list', 'procList');
    f.proc2?.setAttribute('list', 'procList2');
    f.surgeon?.setAttribute('list', 'surgeonsList');
   applyDatalists();
  } catch (_) {}
  // tail を開いたら head に寄せる
  let firstKey = keys[0];
  const d0 = st[firstKey];
  if(d0 && d0.tail && d0.head){ firstKey = d0.head; }
  const first = st[firstKey] || {};
  const isHead = !!first.head;

  document.getElementById('editorTitle').textContent =
    keys.length>1 ? `選択枠の一括編集（${keys.length}件）` :
    (isHead ? `結合枠の編集（${first.span||1}枠）` : '枠の編集');

  // 既存値を反映
  f.name.value = first.name || '';
  f.pid.value  = first.pid  || '';
  f.age.value  = first.age  || '';
  f.eye.value  = first.eye  || '';
  f.io.value   = first.io   || '';

  // IOL①〜③ をフォームに反映
  f.iolType.value  = first.iolType  || '';
  f.iolPower.value = first.iolPower || '';
  if (f.iolUse1)  f.iolUse1.value  = first.iolUse1  || '';

  if (f.iolType2)  f.iolType2.value  = first.iolType2  || '';
  if (f.iolPower2) f.iolPower2.value = first.iolPower2 || '';
  if (f.iolUse2)   f.iolUse2.value   = first.iolUse2   || '';

  if (f.iolType3)  f.iolType3.value  = first.iolType3  || '';
  if (f.iolPower3) f.iolPower3.value = first.iolPower3 || '';
  if (f.iolUse3)   f.iolUse3.value   = first.iolUse3   || '';

  f.proc1.value = first.proc1 || '';
  f.proc2.value = first.proc2 || '';

  // ★ IOL②・③に何か入っていたら自動で展開
  (function(){
    const btn = document.getElementById('toggleIolDetail');
    const hasDetail =
      (f.iolType2  && f.iolType2.value.trim())  ||
      (f.iolPower2 && f.iolPower2.value.trim()) ||
      (f.iolUse1   && f.iolUse1.value.trim())   ||
      (f.iolUse2   && f.iolUse2.value.trim())   ||
      (f.iolType3  && f.iolType3.value.trim())  ||
      (f.iolPower3 && f.iolPower3.value.trim()) ||
      (f.iolUse3   && f.iolUse3.value.trim());

    if (hasDetail) {
      editor.classList.add('showIolDetail');
      if (btn) btn.textContent = 'IOL②・③を隠す';
    } else {
      editor.classList.remove('showIolDetail');
      if (btn) btn.textContent = 'IOL②・③を表示';
    }
  })();

   // 術者：候補にあれば select、なければフリー欄へ
   (function(){
     const surgeonName = first.surgeon || '';
     const sel  = f.surgeon;
     const free = f.surgeonFree;
     if (!sel && !free) return;
     if (!surgeonName) {
       if (sel)  sel.value  = '';
       if (free) free.value = '';
       return;
     }
     let matched = false;
     if (sel) {
       for (let i = 0; i < sel.options.length; i++) {
         if (sel.options[i].value === surgeonName) {
           sel.value = surgeonName;
           matched = true;
           break;
         }
       }
     }
     if (matched) {
       if (free) free.value = '';
     } else {
       if (sel)  sel.value  = '';
       if (free) free.value = surgeonName;
     }
   })();
   f.note.value  = first.note || '';
   // 所要時間（保存値: 分）→ 時間/分の2入力に分配（全角数字はJS保存側で吸収）
   if (f.durationH && f.durationM) {
     const dmin = Number(first.duration || 0);
     const hh = Math.floor(dmin / 60);
     const mm = dmin % 60;
     f.durationH.value = dmin > 0 ? String(hh) : '';
     f.durationM.value = dmin > 0 ? String(mm) : '';
   }
   // ★ 結合枠数の初期値
   const initSpan =
     isHead
       ? (first.span || 1)   // 既存の結合枠 → 保存されている span
       : 1;                  // 通常は 1 枠スタート
 
   f.mergeSpan.value = initSpan;
   // チェックボックスは「表示上の状態」だけ合わせておく（実際の判定には使わない）
   if (f.mergeSlots) {
     f.mergeSlots.checked = initSpan > 1;
   }

   f.ga.checked = !!first.ga;
   if (f.local) {
     f.local.checked = !!first.local;   // ★ 局麻の初期値反映
   }

// 感染症フラグ（なし・あり・未選択）
// → first.infection が 'なし' か 'あり' ならその値
// → それ以外（空/undefined/null）は "未選択"（value=""）にする
(function(){
  const radios = f.querySelectorAll('input[name="infection"]');
  const inf = (first.infection === 'あり' || first.infection === 'なし')
                ? first.infection
                : '';   // ← 未選択扱い

  radios.forEach(r => {
    r.checked = (r.value === inf);
  });
})();
// ▼ 氏名入力欄にIMEカタカナモードを指示
(function(){
  const nameInput = f.name;
  if (nameInput) {
    nameInput.style.imeMode = 'active';
    nameInput.setAttribute('inputmode','katakana');
  }
})();

  editor.returnValue='';
// ▼ 氏名欄：IME確定後 or 非変換入力のときに即カタカナ化する
(function(){
  const nameInput = f.name;
  if (!nameInput) return;

  // 入力モードのヒント（効かない環境も多い）
  nameInput.style.imeMode = 'active';
  nameInput.setAttribute('inputmode', 'katakana');

  let composing = false;

  nameInput.addEventListener('compositionstart', () => { composing = true; });
  nameInput.addEventListener('compositionend', () => {
    composing = false;
    // IME確定直後に変換
    const pos = nameInput.selectionStart;
    nameInput.value = toKatakana(nameInput.value);
    // 位置は基本同長なので軽く復元
    try { nameInput.setSelectionRange(pos, pos); } catch(_) {}
  });

  nameInput.addEventListener('input', () => {
    if (composing) return; // 変換中は触らない
    const pos = nameInput.selectionStart;
    nameInput.value = toKatakana(nameInput.value);
    try { nameInput.setSelectionRange(pos, pos); } catch(_) {}
  });

  // 念のためフォーカス離脱時にも正規化
  nameInput.addEventListener('blur', () => {
    nameInput.value = toKatakana(nameInput.value);
  });
})();

  // クリアボタン：確認ダイアログ付きで clear 実行
  (function(){
    const clearBtn = f.querySelector('button[value="clear"]');
    if (clearBtn) {
      clearBtn.onclick = (e) => {
        e.preventDefault();  // フォームの既定動作は止める

        // ★ 確認ダイアログ
        const ok = window.confirm('この枠の内容をすべてクリアします。よろしいですか？');
        if (!ok) return;

        editor.returnValue = 'clear';
        editor.close();      // close ハンドラ側で clear ロジックが動く
      };
    }
  })();

   editor.showModal();
 
 
   // ===== Enterナビ & 1文字ショートカット =====
   // フォーカス移動の順序（あとで調整しやすいように決め打ち）
   const focusOrder = [
    // 基本情報
    f.name,
    f.pid,
    f.age,
	
	// 入/外/当日入院
    f.io,
	
    f.eye,

    // 術者（セレクト → フリー）
    f.surgeon,
   /* f.surgeonFree,*/

    // 術式1・2
    f.proc1,
    f.proc2,

    // 備考
    f.note,

    // IOL
    f.iolType,
    f.iolPower,

    // 所要時間
    f.durationH,
    f.durationM
    // f.mergeSpan は Enterナビから除外
   ].filter(Boolean);
 
   function moveFocusNext(fromEl){
     const idx = focusOrder.indexOf(fromEl);
     if (idx < 0) return;
     const next = focusOrder[idx + 1];
     if (!next) return;
     next.focus();
     // テキスト系は全選択しておくと上書きしやすい
     if (next.select && next.tagName === 'INPUT') {
       try { next.select(); } catch(_) {}
     }
   }
 
  // ===== 結合先の衝突 事前チェック =====
  function precheckMergeConflict(){
    // 所要時間（H/M）→ 分に変換（save ロジックと同じ仕様）
    const hRaw = (f.durationH?.value ?? '').trim();
    const mRaw = (f.durationM?.value ?? '').trim();
    const h = hRaw ? parseInt(toHalfWidthNum(hRaw), 10) : 0;
    const m = mRaw ? parseInt(toHalfWidthNum(mRaw), 10) : 0;
    const okH = Number.isFinite(h) && h >= 0;
    const okM = Number.isFinite(m) && m >= 0;
    const total = (okH ? h : 0) * 60 + (okM ? m : 0);
    const durationMin = total > 0 ? total : '';

    const durNum = Number(durationMin || 0);
    const spanFromDuration =
      (Number.isFinite(durNum) && durNum > 0)
        ? Math.ceil(durNum / 20)
        : 0;

    let span = spanFromDuration > 0
      ? spanFromDuration
      : Math.max(1, parseInt(f.mergeSpan?.value || '1', 10));

    const merge = span > 1;
    if (!merge) return false; // 1枠なら衝突チェック不要

    // この firstKey / keys は openEditor の外側で既に定義済み
    const data = loadWeek(currentMonday);

    // save ロジック内と同じ seqKeys をここにも定義
    function seqKeysLocal(headKey, n){
      const {d,day,section,idx} = parseKey(headKey);
      const keysArr = [headKey];
      for(let i=1;i<n;i++){
        keysArr.push(`${d}|${day}|${section}|${idx+i}`);
      }
      return keysArr;
    }

    const keysToUse =
      keys.length>1
        ? keys.slice().sort((a,b)=> a.localeCompare(b))
        : seqKeysLocal(firstKey, span);

    for(let i=1;i<keysToUse.length;i++){
      const d = data[keysToUse[i]];
      if (d && !d.tail) {
        alert('結合先に既存データがあります。\n時間を短くするか、結合先の枠をクリアしてから保存してください。');
        return true;  // 衝突あり
      }
    }
    return false; // 衝突なし
  }
 
   function saveFromKeyboard(){
     // ★ まず衝突チェック
     if (precheckMergeConflict()) {
       // 衝突あり → ダイアログは閉じない
       return;
     }

     try { document.activeElement?.blur(); } catch(_) {}
     editor.returnValue = 'save';
     editor.close(); // close ハンドラ側で save ロジック実行
   }

  // 保存ボタンのクリックも saveFromKeyboard() に統一
  (function(){
    if (saveBtn) {
      saveBtn.onclick = (e) => {
        e.preventDefault();   // 既定の「即 close」を止める
        saveFromKeyboard();  // 事前チェック付き保存
      };
    }
  })();

 
  // 既存ハンドラ多重登録防止
  if (editor.__editorKeyHandler) {
    editor.removeEventListener('keydown', editor.__editorKeyHandler, true);
  }

  editor.__editorKeyHandler = function(e){
    if (e.isComposing) return;

    const target = e.target;
    const tag = (target.tagName || '').toLowerCase();

    // --- Tab / Shift+Tab：フォーカスを editor 内に閉じ込める ---
    if (e.key === 'Tab') {
      const focusables = Array.from(
        editor.querySelectorAll(
          'button, input, select, textarea, [tabindex]:not([tabindex="-1"])'
        )
      ).filter(el => !el.disabled && el.offsetParent !== null);

      if (!focusables.length) return;

      const idx = focusables.indexOf(target);
      let nextIdx = idx;

      if (e.shiftKey) {
        // Shift+Tab：先頭なら末尾へ
        nextIdx = idx <= 0 ? focusables.length - 1 : idx - 1;
      } else {
        // Tab：末尾なら先頭へ
        nextIdx = idx === focusables.length - 1 ? 0 : idx + 1;
      }

      e.preventDefault();
      focusables[nextIdx].focus();
      return;
    }

    // --- 眼：R/L/B 1文字ショートカット ---
    if (target === f.eye &&
        !e.ctrlKey && !e.metaKey && !e.altKey &&
        e.key.length === 1) {
      const ch = e.key.toLowerCase();
      const map = { r: 'R', l: 'L', b: 'B' };
      const v = map[ch];
      if (v) {
        e.preventDefault();
        f.eye.value = v;
        moveFocusNext(f.eye);
        return;
      }
    }

    // --- 入/外/当：io セレクト 1文字ショートカット ---
    if (target === f.io &&
        !e.ctrlKey && !e.metaKey && !e.altKey &&
        e.key.length === 1) {
      const ch = e.key.toLowerCase();
      const map = { n: '入', g: '外', t: '当' };
      const v = map[ch];
      if (v) {
        e.preventDefault();
        f.io.value = v;
        moveFocusNext(f.io);
        return;
      }
    }

    // --- 術者セレクト：ショートカット（設定から変更可能） ---
    if (target === f.surgeon &&
        !e.ctrlKey && !e.metaKey && !e.altKey &&
        e.key.length === 1) {

      const ch = e.key.toLowerCase();
      if (!/[a-z]/.test(ch)) {
        // a〜z以外は無視
        return;
      }

      // 1〜2文字バッファでコード判定
      window.__surKeyBuf = (window.__surKeyBuf || '') + ch;
      if (window.__surKeyBuf.length > 2) {
        window.__surKeyBuf = window.__surKeyBuf.slice(-2);
      }

      const map = window.__surgeonShortcutMap || {};
      let matchedName = null;

      // まず 2文字コード（mi / mo / など）を優先
      const buf = window.__surKeyBuf;
      if (buf.length >= 2 && map[buf.slice(-2)]) {
        matchedName = map[buf.slice(-2)];
      } else if (map[buf.slice(-1)]) {
        // 次に1文字コード（k / o / s など）
        matchedName = map[buf.slice(-1)];
      }

      if (matchedName) {
        e.preventDefault();
        f.surgeon.value = matchedName;
        window.__surKeyBuf = ''; // 使い切ったのでクリア
        moveFocusNext(f.surgeon);
      } else {
        // どのコードにも当たらなければ、最後の1文字だけ残して様子を見る
        if (window.__surKeyBuf.length > 1) {
          window.__surKeyBuf = window.__surKeyBuf.slice(-1);
        }
      }
      return;
    }

    // --- Enterキーの挙動（ボタン対応版） ---
    if (e.key === 'Enter') {

      // ① メニューボタン上の Enter はボタン動作にする
      if (clearBtn && target === clearBtn) {
        e.preventDefault();
        // 既に上の IIFE で onclick 定義済みなので click() で同じ動き
        clearBtn.click();
        return;
      }
      if (cancelBtn && target === cancelBtn) {
        e.preventDefault();
        editor.returnValue = 'cancel';
        editor.close();
        return;
      }
      if (saveBtn && target === saveBtn) {
        e.preventDefault();
        // クリックと同じ経路で処理
        saveFromKeyboard();
        return;
      }

      // ② Ctrl+Enter / Cmd+Enter → 保存
      if ((e.ctrlKey || e.metaKey) && !e.shiftKey && !e.altKey) {
        e.preventDefault();
        if (typeof saveFromKeyboard === 'function') {
          saveFromKeyboard();
        }
        return;
      }

      // ③ textarea + Shift+Enter → 改行（メモなど）
      if (tag === 'textarea' && e.shiftKey) return;

      // ④ それ以外の Enter は「次の項目へ移動」、フォーム送信はさせない
      e.preventDefault();
      moveFocusNext(target);
      return;
    }

  };

  editor.addEventListener('keydown', editor.__editorKeyHandler, true);

editor.addEventListener('close', function handler(){
  editor.removeEventListener('close', handler);

  // 結合→即編集のバッチが開いていたかどうか
  const hadMergeBatch = !!mergeEditBatchOpen;

  if (editor.returnValue === 'save') {

    // 結合から続いているバッチがあればそれを再利用、なければ新規に開始
    const reuseBatch = hadMergeBatch;
    if (!reuseBatch) {
      beginUndoBatch();
    }

    try {
      // ★★★ save ロジック（RLセット連続作成対応版）★★★

      // 保存直後は render が複数回走ることがあるため、中央寄せを「2回分」抑止
      window.__suppressCenterN = (window.__suppressCenterN || 0) + 2;	

      // フォーム内容 → レコード nd
      let nd = {
        name: toHalfWidthKana(f.name.value.trim()),
        pid:  f.pid.value.trim(),
        age:  f.age.value.trim(),
        eye:  f.eye.value,
        io:   f.io.value,

        // IOL①〜③
        iolType:  f.iolType.value.trim(),
        iolPower: normalizeDiopter(f.iolPower.value.trim()),
        iolUse1:  (f.iolUse1  ? f.iolUse1.value.trim()  : ''),

        iolType2:  (f.iolType2  ? f.iolType2.value.trim()  : ''),
        iolPower2: (f.iolPower2 ? normalizeDiopter(f.iolPower2.value.trim()) : ''),
        iolUse2:   (f.iolUse2   ? f.iolUse2.value.trim()   : ''),

        iolType3:  (f.iolType3  ? f.iolType3.value.trim()  : ''),
        iolPower3: (f.iolPower3 ? normalizeDiopter(f.iolPower3.value.trim()) : ''),
        iolUse3:   (f.iolUse3   ? f.iolUse3.value.trim()   : ''),

        proc1: f.proc1.value.trim(),
        proc2: f.proc2.value.trim(),
        surgeon: (() => {
          const sel  = f.surgeon;
          const free = f.surgeonFree;
          const freeVal = free ? free.value.trim() : '';
          if (freeVal) return freeVal;   // フリー入力があればそれを優先
          const selVal  = sel ? sel.value.trim() : '';
          return selVal;                 // なければセレクトの値
        })(),
        note:  f.note.value.trim(),
        ga: !!f.ga.checked,
        local: !!(f.local && f.local.checked),  // 局麻フラグ
        // 所要時間（H/M）：全角OK → 半角数値化 → 分へ合算
        duration: (() => {
          const hRaw = (f.durationH?.value ?? '').trim();
          const mRaw = (f.durationM?.value ?? '').trim();
          const h = hRaw ? parseInt(toHalfWidthNum(hRaw), 10) : 0;
          const m = mRaw ? parseInt(toHalfWidthNum(mRaw), 10) : 0;
          const okH = Number.isFinite(h) && h >= 0;
          const okM = Number.isFinite(m) && m >= 0;
          const total = (okH ? h : 0) * 60 + (okM ? m : 0);
          return total > 0 ? total : '';
        })(),
        infection: (() => {
          const checked = f.querySelector('input[name="infection"]:checked');
          return checked ? checked.value : '';
        })()
      };
      nd = normalizePatientFields(nd);

      // 所要時間 → span 自動決定
      const durNum = Number(nd.duration || 0);
      let spanFromDuration = (Number.isFinite(durNum) && durNum > 0)
        ? Math.ceil(durNum / 20)
        : 0;

      // 「入力された所要時間が優先」。なければ mergeSpan を使う
      let span = spanFromDuration > 0
        ? spanFromDuration
        : Math.max(1, parseInt(f.mergeSpan?.value || '1', 10));
      const merge = span > 1;

      // ▼ 単枠/2枠：備考内の「感染」メモを削除（バッジに一本化）
      if (span <= 2) {
        const note0 = (nd.note || '').trim();
        const cleaned = note0
          .replace(/^(?:※\s*)?(?:（\s*感染\s*）|\(\s*感染\s*\)|感染)\s*/u, '')
          .replace(/(?:^|\s)(?:※\s*)?感染(?!\S)/u, (m) => (m.startsWith(' ') ? ' ' : ''))
          .replace(/\s+/g, ' ')
          .trim();
        nd.note = cleaned;
      }

      const data = loadWeek(currentMonday);

      // ★ 既存レコードの meta を退避（RLセットの rlSetId などを保持したい）
      const prevRec  = data[firstKey];
      const prevMeta = (prevRec && prevRec.meta)
        ? JSON.parse(JSON.stringify(prevRec.meta))
        : null;
		
      // ==== RLセット：事前判定（R かつ チェックON か）=================
      const makeRL = !!(f.rlSet && f.rlSet.checked);
      const eyeVal = (f.eye.value || '').trim();
      let rlEnabled = makeRL && eyeVal === 'R';
      let rlSetId = null;
      let rlLKeys = [];

      if (rlEnabled) {
        // 複数枠編集はサポート外にしておく
        if (keys.length > 1) {
          alert('複数枠編集中は RLセットの連続作成はできません。1枠のみ選択してからお試しください。');
          rlEnabled = false;
        } else {
          const parsed = parseKey(firstKey);
          if (!parsed) {
            rlEnabled = false;
          } else {
            const { d, day, section, idx } = parsed;
            const spanInt = Math.max(1, Number(span || 1));

            // L 側に使う枠（Rの結合枠の直後 span 個）
            for (let i = 0; i < spanInt; i++) {
              rlLKeys.push(`${d}|${day}|${section}|${idx + spanInt + i}`);
            }

            // その枠が埋まっていないかチェック
            let conflictKey = null;
            if (typeof isOccupiedRecord === 'function') {
              for (const k of rlLKeys) {
                const rec = data[k];
                if (rec && isOccupiedRecord(rec)) {
                  conflictKey = k;
                  break;
                }
              }
            }

            if (conflictKey) {
              alert('RLセットの対眼（L）を配置する枠に既存のデータがあります。\n先にその枠をクリアしてからやり直してください。');
              rlEnabled = false;
              rlLKeys = [];
            } else {
              rlSetId = 'rl_' + Date.now() + '_' + Math.random().toString(36).slice(2, 7);
            }
          }
        }
      }

      // headKey から span 個ぶんのキー列を作るヘルパ
      function seqKeys(headKey, n){
        const {d,day,section,idx} = parseKey(headKey);
        const keys2=[headKey];
        for(let i=1;i<n;i++){ keys2.push(`${d}|${day}|${section}|${idx+i}`); }
        return keys2;
      }

      // 既存 head 編集は一旦解除
      if(first.head){
        const oldKeys = seqKeys(firstKey, first.span||1);
        for(const k of oldKeys){ if(data[k]) delete data[k]; }
      }

      if(merge && span>1){
        const keysToUse = keys.length>1 ? keys.slice().sort((a,b)=> a.localeCompare(b)) : seqKeys(firstKey, span);
        for(let i=1;i<keysToUse.length;i++){
          const d2 = data[keysToUse[i]];
          if(d2 && !d2.tail){
            alert('結合先に既存データがあります。先にクリアしてください。');
            return;
          }
        }

        const headKey = keysToUse[0];
        const base = { ...nd, head:true, span: keysToUse.length };

        // ★ 既存 meta があれば引き継ぐ（rlSetId を含む）
        if (prevMeta && (!base.meta || !base.meta.rlSetId)) {
          base.meta = { ...prevMeta };
        }

        data[headKey] = base;

        for (let i=1; i<keysToUse.length; i++){
          data[keysToUse[i]] = { tail:true, head: headKey };
        }
      }else{
        if (Object.values(nd).every(v => !v)) {
          delete data[firstKey];
        } else {
          const base = { ...nd };

          // ★ 既存 meta があれば引き継ぐ
          if (prevMeta && (!base.meta || !base.meta.rlSetId)) {
            base.meta = { ...prevMeta };
          }

          data[firstKey] = base;
        }

        if (keys.length > 1) {
          for (let i = 1; i < keys.length; i++) {
            if (Object.values(nd).every(v => !v)) delete data[keys[i]];
            else data[keys[i]] = nd;
          }
        }
      }


      // ==== RLセット：R結合枠の直後に L 結合枠を作成 =================
      if (rlEnabled && rlLKeys.length > 0) {
        const rHead = data[firstKey];   // Rヘッド（今書き込んだもの）
        if (rHead) {
          const spanInt = Math.max(1, Number(span || 1));

          // Rヘッドに rlSetId 付与
          if (!rHead.meta) rHead.meta = {};
          rHead.meta.rlSetId = rlSetId;
          data[firstKey] = rHead;

          // Lヘッドキー＆レコード
          const lHeadKey = rlLKeys[0];
          const lHead = JSON.parse(JSON.stringify(rHead));
          lHead.eye = 'L';
          lHead.head = true;
          lHead.span = spanInt;
          if (!lHead.meta) lHead.meta = {};
          lHead.meta.rlSetId = rlSetId;
          data[lHeadKey] = lHead;

          // Lの tail を作る
          for (let i = 1; i < spanInt; i++) {
            const k = rlLKeys[i];
            data[k] = { tail: true, head: lHeadKey };
          }
        }
      }
	  
      // ==== RLセット：相方フィールド連動（双方向：編集側 → 相方） ====
      try {
        const store = data;

        // 今回編集した枠のキー（tail なら head に寄せる）
        let key0 = firstKey;
        const rec0 = store[key0];
        if (!rec0) {
          // 対象レコードがなければ何もしない
        } else {
          if (rec0.tail && rec0.head && typeof rec0.head === 'string' && store[rec0.head]) {
            key0 = rec0.head;   // 結合枠の tail から開いていたら head に正規化
          }

          // キー＋store から RLセット範囲を判定
          const info =
            (typeof findRLSetRangeForKey === 'function')
              ? findRLSetRangeForKey(key0, store)
              : null;

          if (info && info.keys && info.keys.length === 2) {
            const rKey = info.keys.find(k => ((store[k]?.eye || '').trim() === 'R'));
            const lKey = info.keys.find(k => ((store[k]?.eye || '').trim() === 'L'));
            const rRec = rKey ? store[rKey] : null;
            const lRec = lKey ? store[lKey] : null;

            if (rRec && lRec) {
              // R/L それぞれの“ヘッド”キー（結合枠を考慮）
              let rHeadKey = rKey;
              if (rRec.tail && typeof rRec.head === 'string' && store[rRec.head]) {
                rHeadKey = rRec.head;
              }
              let lHeadKey = lKey;
              if (lRec.tail && typeof lRec.head === 'string' && store[lRec.head]) {
                lHeadKey = lRec.head;
              }

              // 編集側がどちらか判定
              let srcKey = null;
              let dstKey = null;
              if (key0 === rHeadKey) {
                // R側を編集 → Rの値をLへ
                srcKey = rHeadKey;
                dstKey = lHeadKey;
              } else if (key0 === lHeadKey) {
                // L側を編集 → Lの値をRへ
                srcKey = lHeadKey;
                dstKey = rHeadKey;
              }

              if (srcKey && dstKey) {
                const srcRec = store[srcKey];
                const dstRec = store[dstKey];
                if (srcRec && dstRec) {
                  // ★ 両目で常に同じであるべきフィールド
                  const linkedFields = ['io', 'name', 'pid', 'age', 'infection', 'ga', 'local'];
                  for (const fName of linkedFields) {
                    dstRec[fName] = srcRec[fName];
                  }
                  store[dstKey] = dstRec;
                }
              }
            }
          }
        }
      } catch (e) {
        console.warn('RL pair sync (both ways) failed:', e);
      }



      // ====== 後続枠の時刻再計算（押し出し） ======
      try {
        const { day, section } = parseKey(firstKey);
        if (day && section != null) {
          rebuildDurationAnchorsForDaySection(day, section, data);
        }
      } catch (e) {
        console.warn('time override adjust skipped:', e);
      }
      if (typeof debugTimeOverrides === 'function') {
        debugTimeOverrides('after SAVE duration');
      }

      // --- フォーカス維持のための退避 ---
      const wasFocus = document.body.classList.contains('dayFocus');
      const focusedDayEl = document.querySelector('.day[data-focus="true"]');
      const focusedDayKey =
        focusedDayEl?.dataset?.day ??
        focusedDayEl?.querySelector('.day-header-date')?.textContent?.trim() ??
        null;
      const lastKeyBefore = window.lastSelectedKey || null;

      saveWeek(currentMonday, data);
      if (wasFocus) exitDayFocus();
      render();
      if (wasFocus && focusedDayKey){
        let dayEl =
          document.querySelector(`.day[data-day="${CSS.escape(focusedDayKey)}"]`) ||
          Array.from(document.querySelectorAll('.day'))
            .find(d => d.querySelector('.day-header-date')?.textContent?.trim() === focusedDayKey);
        if (dayEl) {
          enterDayFocus(dayEl);
          if (lastKeyBefore){
            const sameSlot = dayEl.querySelector(`.slot[data-key="${CSS.escape(lastKeyBefore)}"]`);
            if (sameSlot) setActiveSlot(sameSlot);
            else ensureInitialSelectionForDay(dayEl);
          } else {
            ensureInitialSelectionForDay(dayEl);
          }
        }
      }
      const currentFocused = document.querySelector('.slot.focused');
      if (!currentFocused) {
        const fallbackDay = document.querySelector('.day[data-focus="true"]') || document.querySelector('.day');
        if (fallbackDay) {
          const firstSlot = findFirstSelectableInDay(fallbackDay);
          if (firstSlot) setActiveSlot(firstSlot);
        }
      }

      // ★★★ save ロジック（RLセット対応）ここまで ★★★

    } finally {
      // バッチの閉じ方を分岐
      try {
        endUndoBatch();
      } catch(_){}

      if (reuseBatch) {
        // 結合→即編集のバッチはここでクローズ完了
        mergeEditBatchOpen = false;
      }
    }

  } else {
    // save 以外（キャンセル / clear 含む）で、結合由来のバッチが開いていたらここで閉じておく
    if (hadMergeBatch) {
      try { endUndoBatch(); } catch(_){}
      mergeEditBatchOpen = false;
    }

    if (editor.returnValue === 'clear') {
      // ★ CLEAR も 1 アクションとしてまとめて Undo できるようにバッチ化
      beginUndoBatch();
      try {
        const data   = loadWeek(currentMonday);
        const dHead  = data[firstKey];
        const parsed = parseKey(firstKey); // { d, day, section, idx }
        const { d, day, section, idx } = parsed || {};

        // ★ 削除前の情報を使って、所要時間アンカーを片付ける
        cleanupTimeOverrideOnDelete(firstKey, data);

        // --- 実データの削除（head なら span 分まとめて、単枠なら 1 つ） ---
        if (dHead && dHead.head) {
          const span = Number(dHead.span || 1);
          for (let i = 0; i < span; i++) {
            const k = `${d}|${day}|${section}|${idx + i}`;
            delete data[k];
          }
        } else {
          delete data[firstKey];
        }

        // ★ 結合枠クリア後：この day/section のアンカーをまとめて再構築
        try {
          if (day != null && section != null) {
            rebuildDurationAnchorsForDaySection(day, section, data);
          }
        } catch (e) {
          console.warn('rebuild-after-clear failed:', e);
        }

        debugTimeOverrides('before CLEAR saveWeek');

        // --- ここから先はフォーカス維持ロジック（元のまま） ---
        const wasFocus = document.body.classList.contains('dayFocus');
        const focusedDayEl = document.querySelector('.day[data-focus="true"]');
        const focusedDayKey =
          focusedDayEl?.dataset?.day ??
          focusedDayEl?.querySelector('.day-header-date')?.textContent?.trim() ??
          null;
        const lastKeyBefore = window.lastSelectedKey || null;

        saveWeek(currentMonday, data);
        if (wasFocus) exitDayFocus();
        render();

        if (wasFocus && focusedDayKey) {
          let dayEl =
            document.querySelector(`.day[data-day="${CSS.escape(focusedDayKey)}"]`) ||
            Array.from(document.querySelectorAll('.day'))
              .find(d => d.querySelector('.day-header-date')?.textContent?.trim() === focusedDayKey);
          if (dayEl) {
            enterDayFocus(dayEl);
            if (lastKeyBefore) {
              const sameSlot = dayEl.querySelector(`.slot[data-key="${CSS.escape(lastKeyBefore)}"]`);
              if (sameSlot) setActiveSlot(sameSlot);
              else ensureInitialSelectionForDay(dayEl);
            } else {
              ensureInitialSelectionForDay(dayEl);
            }
          }
        }

        const currentFocused2 = document.querySelector('.slot.focused');
        if (!currentFocused2) {
          const fallbackDay =
            document.querySelector('.day[data-focus="true"]') ||
            document.querySelector('.day');
          if (fallbackDay) {
            const firstSlot = findFirstSelectableInDay(fallbackDay);
            if (firstSlot) setActiveSlot(firstSlot);
          }
        }
      } finally {
        // ★ CLEAR ルート全体を 1 ステップの Undo に確定
        endUndoBatch();
      }
    }
  }
}, {once:true});
}

// 全麻と局麻は相反させる
document.getElementById("ga").addEventListener("change", () => {
  if (ga.checked) {
    local.checked = false;
  }
});

document.getElementById("local").addEventListener("change", () => {
  if (local.checked) {
    ga.checked = false;
  }
});

// 所要時間（duration）を優先して、次スロットの開始時刻アンカーを打つ
function applyDurationAnchorForHead(headKey, store){
  try {
    // headKey = "2025-11-12|Tue|1|7" など
    const { d, day, section, idx } = parseKey(headKey);
    const head = store[headKey];
    if (!head || head.tail) return;

    const span = Math.max(1, Number(head.span || 1));
    const dur  = Number(head.duration || 0);
    const effMinutes = (Number.isFinite(dur) && dur > 0) ? dur : (span * 20);

    // 先頭実開始
    const baseStart = (CONFIG?.[day]?.[section]?.start) || '09:30';
    const headHHMM  = getSlotTimeHHMMEx(baseStart, currentMonday, day, section, idx);

    // 次の枠インデックス（結合時は head の次の枠）
    const nextIdx = idx + span;

    // 既存アンカーの後続分をクリアして、次枠に「開始+所要時間」でアンカー
    clearTimeOverrideFrom(currentMonday, day, section, idx + 1);
    setTimeOverride(currentMonday, day, section, nextIdx, addMinutes(headHHMM, effMinutes));
  } catch(e){
    console.warn('applyDurationAnchorForHead skipped:', e);
  }
}
// === その日・そのセクションの duration アンカーを一括で組み直す ===
function rebuildDurationAnchorsForDaySection(dayKey, section, storeOpt, opts){
  try{
    const store   = storeOpt || loadWeek(currentMonday);
    const options = opts || {};
    const keep    = options.keepAnchor || null;   // { idx, hhmm } など

    // 1) この day|section の time override をリセット
    const tovr = loadTimeOverrides(currentMonday);
    const tKey = `${dayKey}|${section}`;

    if (keep && typeof keep.idx === 'number' && keep.hhmm){
      // 指定されたアンカーだけを残す形でリセット
      tovr[tKey] = { [keep.idx]: keep.hhmm };
    } else {
      // 従来どおり：全部消す
      if (tovr[tKey]) {
        delete tovr[tKey];
      }
    }
    saveTimeOverrides(currentMonday, tovr);

    // 2) head になるレコードを idx 昇順に集める
    const heads = [];
    for (const key of Object.keys(store)){
      const rec = store[key];
      if (!rec || rec.tail) continue;

      const p = parseKey(key);  // { d, day, section, idx }
      if (p.day !== dayKey || p.section !== section) continue;

      const span = Math.max(1, Number(rec.span || 1));
      const dur  = Number(rec.duration || 0);

      // 「結合枠 or durationあり」だけを対象
      if (span > 1 || (Number.isFinite(dur) && dur > 0)){
        heads.push({ key, idx: p.idx });
      }
    }

    heads.sort((a,b)=> a.idx - b.idx);

    // 3) 先頭から順に applyDurationAnchorForHead でアンカー設定
    for (const h of heads){
      applyDurationAnchorForHead(h.key, store);
    }
  }catch(e){
    console.warn('rebuildDurationAnchorsForDaySection skipped:', e);
  }
}


  // ==== RLセット検出ヘルパ ====
  // slotEl から「この枠が RL セットに属しているか」を調べ、
  // 見つかった場合は { keys:[...], baseKey:"..." } を返す。
  // まだ rlSetId を付けていない既存データにも対応できるよう、
  // 1) rlSetId があればそれでグループ化
  // 2) なければ「同じ日・同じセクション・同じ患者（name/pid）で R/L ペア」を近傍から推定
  function findRLSetRangeForSlot(slotEl, storeOpt){
    if (!slotEl) return null;
    const key = slotEl.dataset?.key;
    if (!key) return null;

    const store = storeOpt || loadWeek(currentMonday);
    let rec = store[key];
    if (!rec) return null;

    // tail 行（結合枠の2マス目以降）だった場合は head 側に寄せて判定
    if (rec.tail && rec.head && typeof rec.head === 'string' && store[rec.head]) {
      return findRLSetRangeForKey(rec.head, store);
    }
    return findRLSetRangeForKey(key, store);
  }

  // 内部用：キーとストアから RL セット範囲を判定
  function findRLSetRangeForKey(key, store){
    const base = store[key];
    if (!base) return null;

    const eye = (base.eye || '').trim();
    if (eye !== 'R' && eye !== 'L') return null;

    // --- 1) rlSetId があれば、それでグルーピング ---
    const setId = base.meta && base.meta.rlSetId;
    if (setId) {
      const keys = Object.keys(store)
        .filter(k => {
          const r = store[k];
          if (!r || r.tail) return false;
          return r.meta && r.meta.rlSetId === setId;
        })
        .sort();

      if (keys.length >= 2) {
        return { keys, baseKey: key };
      }
    }

    // --- 2) Fallback：同じ日・セクションで name/pid が同じ R/L ペアを近傍から探す ---
    const p = parseKey(key); // { d, day, section, idx }
    if (!p || p.day == null || p.section == null) return null;

    const baseName = (base.name || '').trim();
    const basePid  = (base.pid  || '').trim();
    if (!baseName && !basePid) return null; // 患者情報が無ければ判定不能

    const partnerEye = (eye === 'R') ? 'L' : 'R';
    const candidates = [];
    const maxOffset = 3; // 同じセクション内で ±3 枠ぶんだけを見る

    for (let off = -maxOffset; off <= maxOffset; off++) {
      if (off === 0) continue;
      const k = `${p.d}|${p.day}|${p.section}|${p.idx + off}`;
      const r = store[k];
      if (!r || r.tail) continue;

      const eye2 = (r.eye || '').trim();
      if (eye2 !== partnerEye) continue;

      const name2 = (r.name || '').trim();
      const pid2  = (r.pid  || '').trim();

      // PID が入っていれば PID 優先、無い場合は氏名で判定
      if (basePid) {
        if (pid2 === basePid) candidates.push(k);
      } else if (baseName) {
        if (name2 === baseName) candidates.push(k);
      }
    }

    if (!candidates.length) return null;

    // 一応ソートして、代表的な 2 件を RL セットとみなす
    candidates.sort();
    const all = [key, ...candidates].sort();
    const keys2 = all.slice(0, 2);

    if (keys2.length < 2) return null;
    return { keys: keys2, baseKey: key };
  }


function formatMinutesColon(min){
  const m = Number(min)||0;
  if (m <= 0) return '';
  const h = Math.floor(m/60), r = m%60;
  if (h && r) return `${h}:${r.toString().padStart(2,'0')}`;
  if (h) return `${h}:00`;
  return `${r}`;
}


/* ---------- コピー / 貼り付け / 切り取り（単枠＆結合対応の最小核） ---------- */
const appClipboard = { type:null, data:null };
let lastCopySourceKey = null;

function isOccupiedRecord(rec){
  if (!rec) return false;
  const f = ['head','tail','name','pid','age','eye','iolType','iolPower','proc1','proc2','surgeon','note','io','linkWith'];
  return f.some(k => !!rec[k]);
}

function copySlotOrMerge(){
  const st = loadWeek(currentMonday);

  // 0) RLセット選択中なら、RLセット単位でコピー
  const activeEl = getActiveSlot?.();
  if (window.currentRLSetId && activeEl && typeof findRLSetRangeForSlot === 'function') {
    const info    = findRLSetRangeForSlot(activeEl, st);
    const baseRec = info && st[info.baseKey];
    const rlId    = baseRec?.meta?.rlSetId;

    if (info && rlId && rlId === window.currentRLSetId && info.keys && info.keys.length > 1) {
      const blocks = [];
      for (const headKey of info.keys) {
        const rec = st[headKey];
        if (!rec) continue;

        const span = rec.head ? Math.max(1, Number(rec.span || 1)) : 1;
        const kind = (rec.head && span > 1) ? 'merge' : 'single';

        blocks.push({
          kind,
          span,
          data: deepClone(rec),
          keys: [headKey]
        });
      }

      if (blocks.length) {
        const p = parseKey(info.keys[0]);
        const clipMulti = {
          day:     p.day,
          section: p.section,
          blocks
        };

        appClipboard.type = 'multi';
        appClipboard.data = clipMulti;

        // 視覚フィードバック：外周選択中の枠を軽くアニメーション
        document.querySelectorAll('.slot.multiSelected').forEach(el => {
          el.animate([{opacity:1},{opacity:0.4},{opacity:1}], {duration:160});
        });
        return;
      }
    }
  }

  // 1) まず複数選択を試す
  if (multiSelected && multiSelected.size > 1) {
    const clipMulti = buildMultiClipboardFromSelection(st);
    if (clipMulti) {
      appClipboard.type = 'multi';
      appClipboard.data = clipMulti;

      // 視覚フィードバック：選択範囲をふわっとアニメーション
      document.querySelectorAll('.slot.multiSelected').forEach(el => {
        el.animate([{opacity:1},{opacity:0.4},{opacity:1}], {duration:160});
      });
      return;
    }
    // ここに来るのは「範囲がおかしくて alert 済み」のパターンなので、
    // そのまま単枠コピーにフォールバックしてもよいし、return でもよい。
    // ひとまずフォールバックしておく。
  }

  // 2) 通常の単枠／結合枠コピー（従来どおり）
  const el = getActiveSlot?.();
  if(!el){ alert('スロットを選択してください'); return; }
  const key = el.dataset.key;
  const d   = st[key];
  if(!d){ alert('コピー対象がありません'); return; }

  if (d.head && Number(d.span||1)>1){
    appClipboard.type = 'merge';
    appClipboard.data = { headKey:key, span:Number(d.span), headData:deepClone(d) };
  }else{
    appClipboard.type = 'single';
    appClipboard.data = { key, data:deepClone(d) };
    lastCopySourceKey = key;
  }
  el.animate([{opacity:1},{opacity:.5},{opacity:1}], {duration:160});
}


function pasteToActive({flip=false}={}){
  const clip = appClipboard;
  if(!clip?.type){ alert('コピーされていません'); return; }
  const tEl = getActiveSlot?.(); if(!tEl){ alert('貼り付け先を選択してください'); return; }
  const tKey = tEl.dataset.key;
  const st = loadWeek(currentMonday);

  // ====== ★ 複数枠貼り付け（multi） ======
if (clip.type === 'multi') {
  const blocks = clip.data?.blocks;
  if (!blocks || !blocks.length) {
    alert('複数コピー内容が不正です'); return;
  }

  const container = tEl.closest('.slots');
  if (!container) { alert('貼り付け先が不正です'); return; }

  const list = Array.from(container.querySelectorAll('.slot'));
  let base = list.indexOf(tEl);
  if (base < 0) { alert('貼り付け先が不正です'); return; }

  // 1) 事前チェック：はみ出し・上書き確認
  let probe = base;
  for (const b of blocks) {
    const span = Number(b.span || 1);
    if (probe + span - 1 >= list.length) {
      alert('貼り付け範囲がセクションの外にはみ出します'); return;
    }
    for (let j = 0; j < span; j++) {
      const k = list[probe + j].dataset.key;
      if (isOccupiedRecord(st[k])) {
        alert('貼り付け先に既存データがあります'); return;
      }
    }
    probe += span;
  }

  // 2) 実際の書き込み＋保存を1バッチにまとめる
  beginUndoBatch();
  try {
    let idx = base;

    // ★ RLセットIDの振り直し用マップ
    const rlIdMap = {};
    function remapRLId(obj){
      if (!obj) return;
      const meta = obj.meta;
      const oldId = meta && meta.rlSetId;
      if (!oldId) return;
      if (!rlIdMap[oldId]) {
        rlIdMap[oldId] = `rl_${Date.now()}_${Math.random().toString(16).slice(2)}`;
      }
      meta.rlSetId = rlIdMap[oldId];
    }

    for (const b of blocks) {
      if (b.kind === 'single') {
        const destKey = list[idx].dataset.key;
        const data = deepClone(b.data);
        if (flip && data.eye) data.eye = flipEye(data.eye);
        // ★ RLセットIDを貼り付け用に振り直し
        remapRLId(data);
        delete data.linkWith;

        st[destKey] = data;
        if (st[destKey] && !st[destKey].tail && !('span' in st[destKey])) {
          st[destKey].span = 1;   // duration 用の span=1 付与だけ
        }
        idx += 1;

      } else if (b.kind === 'merge') {
        const span = Number(b.span || 1);
        const headData = deepClone(b.data);
        delete headData.head;
        delete headData.tail;
        delete headData.span;
        delete headData.linkWith;
        if (flip && headData.eye) headData.eye = flipEye(headData.eye);
        // ★ 結合枠ヘッドにも新しい rlSetId を付与
        remapRLId(headData);

        const destKeys = [];
        for (let j = 0; j < span; j++) {
          destKeys.push(list[idx + j].dataset.key);
        }
        const headKey = destKeys[0];
        st[headKey] = { ...headData, head: true, span };
        for (let j = 1; j < span; j++) {
          st[destKeys[j]] = { tail: true, head: headKey };
        }
        idx += span;
      }
    }

    // ★ 貼り付け後：このセクションの所要時間アンカーを一括で組み直す
    const { day, section } = parseKey(tKey);
    rebuildDurationAnchorsForDaySection(day, section, st);

    saveWeek(currentMonday, st);
  } finally {
    endUndoBatch();
  }

  reRenderPreservingFocus(tKey); // 貼り付け先を基準に復帰
  return;
}


  // ====== ここから下は従来どおり single / merge 貼り付け ======
if (clip.type === 'single') {
  if (isOccupiedRecord(st[tKey])) {
    alert('既にデータがあります'); 
    return;
  }

  beginUndoBatch();            // ★ 1ステップにまとめる
  try {
    const data = deepClone(clip.data.data);
    if (flip && data.eye) data.eye = flipEye(data.eye);
    delete data.linkWith;

    // 貼り付け先に書き込み
    st[tKey] = data;

    // duration 用に span=1 を付けておく（tail でないときだけ）
    if (st[tKey] && !st[tKey].tail && !('span' in st[tKey])) {
      st[tKey].span = 1;
    }

    // ★ このセクション全体のアンカーを組み直す
    const { day, section } = parseKey(tKey);
    rebuildDurationAnchorsForDaySection(day, section, st);

    saveWeek(currentMonday, st);
  } finally {
    endUndoBatch();            // ★ バッチ終了
  }

  // 描画はバッチ外でOK
  reRenderPreservingFocus(tKey);
  return;
}



if (clip.type === 'merge') {
  const span = Number(clip.data.span || 1);
  if (span <= 1) {
    alert('結合情報が不正です');
    return;
  }

  const day = tEl.closest('.day');
  if (!day) {
    alert('貼り付け先が不正です');
    return;
  }

  const list = Array.from(day.querySelectorAll('.slot'));
  const base = list.indexOf(tEl);
  if (base < 0 || base + span - 1 >= list.length) {
    alert('貼り付け範囲が日はみ出します');
    return;
  }

  // はみ出し・上書きチェック
  const destKeys = [];
  for (let i = 0; i < span; i++) {
    const k = list[base + i].dataset.key;
    destKeys.push(k);
    if (isOccupiedRecord(st[k])) {
      alert('貼り付け先に既存データがあります');
      return;
    }
  }

  // ★ ここからまとめて 1 つの undo にする
  beginUndoBatch();
  try {
    // head データ
    const headData = deepClone(clip.data.headData || {});
    delete headData.head;
    delete headData.tail;
    delete headData.span;
    delete headData.linkWith;
    if (flip && headData.eye) headData.eye = flipEye(headData.eye);

    const headKey = destKeys[0];
    st[headKey] = { ...headData, head: true, span };

    // tail を書き込み
    for (let i = 1; i < span; i++) {
      st[destKeys[i]] = { tail: true, head: headKey };
    }

    // ★ このセクション全体のアンカーを組み直す
    const { day: dayKey, section } = parseKey(headKey);
    rebuildDurationAnchorsForDaySection(dayKey, section, st);

    // 保存してフォーカス復帰
    saveWeek(currentMonday, st);
  } finally {
    endUndoBatch();  // ★ まとめて1アクションに確定
  }

  reRenderPreservingFocus(tKey);
  return;
}
}


function cutActive(){
  const storeNow = loadWeek(currentMonday);

  // --- どの枠を削除するか、削除プランを作る ---
  const deletePlan = [];
  let clipboardData = null;

  // 1) RLセット選択中なら、RLセット単位で cut
  let handledRL = false;
  const activeEl = getActiveSlot?.();
  if (window.currentRLSetId && activeEl && typeof findRLSetRangeForSlot === 'function') {
    const info    = findRLSetRangeForSlot(activeEl, storeNow);
    const baseRec = info && storeNow[info.baseKey];
    const rlId    = baseRec?.meta?.rlSetId;

    if (info && rlId && rlId === window.currentRLSetId && info.keys && info.keys.length > 1) {
      const blocks = [];

      for (const headKey of info.keys) {
        const rec = storeNow[headKey];
        if (!rec) continue;

        const span = rec.head ? Math.max(1, Number(rec.span || 1)) : 1;
        const kind = (rec.head && span > 1) ? 'merge' : 'single';

        blocks.push({
          kind,
          span,
          data: deepClone(rec),
          keys: [headKey]
        });

        if (kind === 'merge') {
          deletePlan.push({ type:'merge', headKey });
        } else {
          deletePlan.push({ type:'single', key: headKey });
        }
      }

      if (blocks.length) {
        const p = parseKey(info.keys[0]);
        clipboardData = {
          day:     p.day,
          section: p.section,
          blocks
        };
        appClipboard.type = 'multi';
        appClipboard.data = clipboardData;
        handledRL = true;
      }
    }
  }

  // 2) 複数選択あり → multi cut
  if (!handledRL && multiSelected && multiSelected.size > 1) {
    const clipMulti = buildMultiClipboardFromSelection(storeNow);
    if (!clipMulti) return;  // 途中に穴・不正があれば中止（buildMulti内でalert済）

    // クリップボードへ multi を格納
    appClipboard.type = 'multi';
    appClipboard.data = clipMulti;
    clipboardData = clipMulti;

    // blocks から削除プランを作成
    for (const b of clipMulti.blocks) {
      if (b.kind === 'merge') {
        // 結合枠：先頭キーだけを head として扱う
        const headKey = b.keys[0];
        deletePlan.push({ type: 'merge', headKey });
      } else if (b.kind === 'single') {
        const key = b.keys[0];
        deletePlan.push({ type: 'single', key });
      }
    }
  } else {
    // 2) 通常の単枠 / 結合枠 1つだけの cut
    const el = getActiveSlot?.(); 
    if (!el) return;

    const key = el.dataset.key;
    const rec = storeNow[key];
    if (!rec) return;

    // まず単枠/結合枠としてクリップボードにコピー
    copySlotOrMerge();   // ここで appClipboard.type = 'single' or 'merge'

    if (rec.head && Number(rec.span || 1) > 1) {
      // 結合枠 head
      deletePlan.push({ type: 'merge', headKey: key });
    } else {
      // 単枠
      deletePlan.push({ type: 'single', key });
    }
  }

  if (deletePlan.length === 0) return;

  // --- ここから先を 1 アクションとして Undo できるようにまとめる ---
  beginUndoBatch();
  try {
    const st = loadWeek(currentMonday);

    // フォーカス維持用の情報を先に記録
    const wasFocus = document.body.classList.contains('dayFocus');
    const focusedDayEl = document.querySelector('.day[data-focus="true"]');
    const focusedDayKey =
      focusedDayEl?.dataset?.day ??
      focusedDayEl?.querySelector('.day-header-date')?.textContent?.trim() ?? null;
    const lastKeyBefore = window.lastSelectedKey || null;

    // --- 実際の削除処理 ---
    for (const item of deletePlan) {
      if (item.type === 'merge') {
        const headKey = item.headKey;
        const rec = st[headKey];
        if (!rec) continue;

        // 所要時間アンカーを先に片付ける
        cleanupTimeOverrideOnDelete(headKey, st);

        const span = Math.max(1, Number(rec.span || 1));
        const { d, day, section, idx } = parseKey(headKey);
        for (let i = 0; i < span; i++) {
          const k = `${d}|${day}|${section}|${idx + i}`;
          delete st[k];
        }
      } else if (item.type === 'single') {
        const key = item.key;
        const rec = st[key];
        if (!rec) continue;

        cleanupTimeOverrideOnDelete(key, st);
        delete st[key];
      }
    }
    // ★ 削除後：このセクションのアンカーを一括で組み直す
    if (deletePlan.length > 0) {
      const firstKey =
        deletePlan[0].type === 'merge'
          ? deletePlan[0].headKey
          : deletePlan[0].key;
      const { day, section } = parseKey(firstKey);
      rebuildDurationAnchorsForDaySection(day, section, st);
    }
    // 複数選択のハイライトをクリア
    clearMultiSelection();

    // 保存 → 再描画（フォーカス維持パターンは従来どおり）
    saveWeek(currentMonday, st);
    if (wasFocus) exitDayFocus();
    render();
    if (wasFocus && focusedDayKey){
      let dayEl =
        document.querySelector(`.day[data-day="${CSS.escape(focusedDayKey)}"]`) ||
        Array.from(document.querySelectorAll('.day'))
          .find(d => d.querySelector('.day-header-date')?.textContent?.trim() === focusedDayKey);
      if (dayEl) {
        enterDayFocus(dayEl);
        // 可能なら同じキーへ再選択、無ければ当日先頭
        if (lastKeyBefore){
          const same = dayEl.querySelector(`.slot[data-key="${CSS.escape(lastKeyBefore)}"]`);
          if (same) setActiveSlot(same);
          else ensureInitialSelectionForDay(dayEl);
        } else {
          ensureInitialSelectionForDay(dayEl);
        }
      }
    }
  } finally {
    endUndoBatch();
  }
}



/* ---------- ショートカット（Ctrl/Cmd + C/V/X, Delete, Enter） ---------- */
document.addEventListener('keydown',(e)=>{
  if(isTypingContext(e)) return;
  
  // ★ 追加：エディタ or 設定ダイアログが開いている間は
  //    グローバルショートカット（Undo/Redo/Enter編集）を無効化
  {
    const ed = document.getElementById('editor');
    const st = document.getElementById('settings');
    const dialogOpen =
      (ed && (ed.open || ed.classList?.contains('is-open'))) ||
      (st && (st.open || st.classList?.contains('is-open')));
    if (dialogOpen) return;
  }
  
  const k = e.key.toLowerCase();

  if((e.ctrlKey||e.metaKey) && k==='c'){ e.preventDefault(); copySlotOrMerge(); }
  if((e.ctrlKey||e.metaKey) && k==='v'){ e.preventDefault(); pasteToActive({flip:e.shiftKey}); }
  if((e.ctrlKey||e.metaKey) && k==='x'){ e.preventDefault(); cutActive(); }

  if(k==='delete' || k==='backspace'){
    e.preventDefault();
    const el = getActiveSlot?.(); if(!el) return;

  // ============================================
  // 🔵 複数選択されている場合：まとめて削除
  // ============================================
  if (multiSelected && multiSelected.size >= 2) {
    const keysToDelete = Array.from(multiSelected);
    if (!window.confirm(`選択された ${keysToDelete.length} 枠をまとめて削除します。よろしいですか？`)) {
      return;
    }

    beginUndoBatch();
    try {
      const st = loadWeek(currentMonday) || {};
      let anyHeadKey = null;

      for (const k of keysToDelete) {
        const rec = st[k];
        if (!rec) continue;

        // head を特定する（結合枠前提）
        const { d, day, section, idx } = parseKey(k);
        const baseEl = document.querySelector(`.slot[data-key="${k}"]`);
        const headEl = (function resolveHead(n){
          let p = n;
          while (p && p.classList && p.classList.contains('slot')) {
            if (p.classList.contains('mergeHead')) return p;
            if (!p.classList.contains('hiddenRow')) return p;
            p = p.previousElementSibling;
          }
          return n;
        })(baseEl);

        const headKey = headEl?.dataset?.key;
        if (!headKey) continue;
        if (!anyHeadKey) anyHeadKey = headKey;

        // span を取得
        function getSpan(h){
          const s = h && h.style ? h.style.gridRowEnd : '';
          const m = s && s.match(/span\s+(\d+)/i);
          if (m){ const n = parseInt(m[1],10); if (Number.isFinite(n) && n>0) return n; }
          const d = h && h.dataset ? h.dataset : {};
          const raw = d.span || d.mergeSpan;
          const n2 = parseInt(raw,10);
          return (Number.isFinite(n2) && n2>0) ? n2 : 1;
        }

        const span = getSpan(headEl);

        // head + tail を削除
        for (let i = 0; i < span; i++) {
          const key2 = `${d}|${day}|${section}|${idx + i}`;
          delete st[key2];
        }
      }

      // time override をまとめて再構築（代表 headKey を使用）
      if (anyHeadKey && typeof autoRebuildTimeOverridesForSectionAfterDelete === 'function') {
        autoRebuildTimeOverridesForSectionAfterDelete(anyHeadKey, st);
      }

      saveWeek(currentMonday, st);
      preserveScrollWhile(()=> render());
      clearMultiSelection();

    } finally {
      endUndoBatch();
    }

    return; // ← 一括削除はここで処理終了
  }
    // ============================
    // 🔵 RLセット選択中ならセット削除
    // ============================
    const storeForDel = loadWeek(currentMonday);
    if (window.currentRLSetId && typeof findRLSetRangeForSlot === 'function') {
      const info    = findRLSetRangeForSlot(el, storeForDel);
      const baseRec = info && storeForDel[info.baseKey];
      const rlId    = baseRec?.meta?.rlSetId;

      // 現在の RL セレクションと一致していて、R/L 2ヘッド以上あるときだけ発動
      if (info && rlId && rlId === window.currentRLSetId && info.keys && info.keys.length > 1) {
        if (!window.confirm('このRLセットをまとめて削除します。よろしいですか？')) {
          return;
        }

        beginUndoBatch();
        try {
          for (const headKey of info.keys) {
            const rec = storeForDel[headKey];
            if (!rec) continue;

            const span = rec.head ? Math.max(1, Number(rec.span || 1)) : 1;

            // 所要時間アンカーの片付け
            if (typeof cleanupTimeOverrideOnDelete === 'function') {
              cleanupTimeOverrideOnDelete(headKey, storeForDel);
            }

            const { d, day, section, idx } = parseKey(headKey);
            for (let i = 0; i < span; i++) {
              const k2 = `${d}|${day}|${section}|${idx + i}`;
              delete storeForDel[k2];
            }
          }

          // time override の再構築
          if (typeof autoRebuildTimeOverridesForSectionAfterDelete === 'function') {
            autoRebuildTimeOverridesForSectionAfterDelete(info.keys[0], storeForDel);
          }

          saveWeek(currentMonday, storeForDel);
          preserveScrollWhile(() => render());

          // RLセット選択状態をクリア
          if (typeof clearMultiSelection === 'function') {
            clearMultiSelection();
          }
          window.currentRLSetId = null;

        } finally {
          endUndoBatch();
        }
        return; // RLセット削除はここで終了
      }
    }

    // ★ ここで確認ダイアログをはさむ
    if (!window.confirm('この枠の内容をクリアします。よろしいですか？')) {
      return; // キャンセルなら何もしない
    }
	
    // ★ この削除操作全体を「Undo 1ステップ」にまとめる
    beginUndoBatch();
    try { 
 
     // 1) head を特定（tail を選んでいても巻き戻す）
     const head = (function resolveHead(n){
       let p = n;
       while (p && p.classList && p.classList.contains('slot')){
         if (p.classList.contains('mergeHead')) return p; // 明示 head
         if (!p.classList.contains('hiddenRow')) return p; // 単独＝head扱い
         p = p.previousElementSibling;
       }
       return n;
     })(el);
 
     // 2) span を取得（style > dataset > 既定1）
     function getSpan(h){
       const s = h && h.style ? h.style.gridRowEnd : '';
       const m = s && s.match(/span\s+(\d+)/i);
       if (m){ const n = parseInt(m[1],10); if (Number.isFinite(n) && n>0) return n; }
       const d = h && h.dataset ? h.dataset : {};
       const raw = d.span || d.mergeSpan;
       const n2 = parseInt(raw,10);
       return (Number.isFinite(n2) && n2>0) ? n2 : 1;
     }
     const span = getSpan(head);
 
     // 3) 週データを読み、head と tail 全部のキーを削除
     const st = loadWeek(currentMonday);
     const headKey = head?.dataset?.key || null;
     // ※ この時点では time override はまだ触らない（autoRebuild に一任）
 	 
     if (head.dataset && head.dataset.key) delete st[head.dataset.key];
     let p = head.nextElementSibling;
     for (let i=1; i<span && p; i++){
       if (!(p.classList && p.classList.contains('slot'))) break;
       // tail 側の state も消す（←これが肝）
       if (p.dataset && p.dataset.key) delete st[p.dataset.key];
       // 4) DOM 上も hiddenRow を先に外しておく（掃除で消されるのを防止）
       p.classList.remove('hiddenRow');
       p = p.nextElementSibling;
     }
     // head の結合表示も外す（任意：見た目のチラつき抑止）
     head.classList.remove('mergeHead');
     if (head.style) head.style.gridRowEnd = '';
     if (head.dataset){ delete head.dataset.span; delete head.dataset.mergeSpan; }
 
      // ★ 4. 同じ日・同じセクションの time override をここで丸ごと組み直す
      if (headKey){
        autoRebuildTimeOverridesForSectionAfterDelete(headKey, st);
      }
 
      // 5) 保存→再描画（applyMerges はもう tail を隠せない）
      saveWeek(currentMonday, st);
      preserveScrollWhile(()=> render());
    } finally {
      endUndoBatch();
    }	  
  }

if(k==='enter'){
  e.preventDefault();
  // ★ RLセット外周選択中は Enter 編集を無効化
  //   → どちらかの枠をクリックして単枠青枠にしてから Enter してもらう
  if (window.currentRLSetId && document.querySelector('.slot.multiSelected')) {
    return;
  }

  const el = getActiveSlot?.() || document.querySelector('.slot');
  if(!el) return;

  // ★ 祝日/休止ガードを追加
  if (isSlotLockedForEdit(el)) {
    // 必要なら案内を出す
    // alert('この枠は祝日/休止のため編集できません');
    return;
  }

  openEditor([el.dataset.key]);
}
}, true);

 <!-- Ctrl+←／→ 統合ハンドラ：週＝前週/次週、フォーカス＝前日/翌日 -->
 (()=> {
   if (window.__bindCtrlArrowsUnified) return; window.__bindCtrlArrowsUnified = true;
 
   const isEditable = (t)=>{ const tag=t?.tagName?.toLowerCase(); return tag==='input'||tag==='textarea'||t?.isContentEditable; };
   const isDialogOpen = ()=> {
     const ed=document.getElementById('editor'), st=document.getElementById('settings');
     return !!((ed&&(ed.open||ed.classList?.contains('is-open'))) || (st&&(st.open||st.classList?.contains('is-open'))));
   };
   const z = n => String(n).padStart(2,'0');
   const ymd = d => `${d.getFullYear()}-${z(d.getMonth()+1)}-${z(d.getDate())}`;
 
   document.addEventListener('keydown', (e)=>{
     if (!e.ctrlKey) return;
     const isLeft  = (e.key === 'ArrowLeft');
     const isRight = (e.key === 'ArrowRight');
     if (!(isLeft || isRight)) return;
     if (isEditable(e.target) || isDialogOpen()) return;
 
     const dir = isRight ? +1 : -1; // 週：±7日 / フォーカス：±1日
 
     // フォーカスモード：前日/翌日
     if (document.body.classList.contains('dayFocus')) {
       const hasJump = (typeof window.jumpFocusTo === 'function');
       const getFd   = (typeof window.getFocusDate === 'function') ? window.getFocusDate : null;
       let d = getFd ? getFd() : null;
       if (!(d instanceof Date) || isNaN(+d)) {
         const wp=document.getElementById('weekPicker');
         if (wp?.value){ const [y,m,dd]=wp.value.split('-').map(Number); d=new Date(y,m-1,dd); }
         else d = new Date();
       }
       d.setDate(d.getDate() + dir);
       if (typeof window.snapWeekendDir === 'function') d = window.snapWeekendDir(d, dir);
       e.preventDefault(); e.stopImmediatePropagation();
       if (hasJump){
         window.jumpFocusTo(d, dir);
       } else {
         // フォールバック：フォーカス時は週ボタンが「前日/翌日」に置換されている
         const btn = document.getElementById(dir > 0 ? 'nextWeek' : 'prevWeek');
         btn?.click();
       }
       return;
     }
 
     // 週モード：前週/次週
     const wp = document.getElementById('weekPicker'); if (!wp) return;
     const base = (window.currentMonday instanceof Date)
       ? new Date(window.currentMonday)
       : (wp.value ? new Date(wp.value) : new Date());
     base.setDate(base.getDate() + (dir * 7));
     e.preventDefault(); e.stopImmediatePropagation();
     // ← 基準週を即時更新して“現在の週”を正しく追従させる
     window.currentMonday = new Date(base.getFullYear(), base.getMonth(), base.getDate());	 
     wp.value = ymd(base);
    // ★ 週移動直後の中央寄せ抑止（連続render保険として+2）
    window.__suppressCenterN = (window.__suppressCenterN|0) + 2;
    window.__snapTopOnNextRender = true;
    window.__snapTopTargetISO   = ymd(base); // base は月曜（currentMonday基準＋7/−7）	
    wp.dispatchEvent(new Event('change', { bubbles:true }));
    window.__postWeekMoveCenter?.();	 
   }, { capture:true });
 })();

 <!-- Ctrl＋.：週表示→フォーカス表示で今日にジャンプ -->
 (() => {
   if (window.__bindCtrlDotFocus) return; window.__bindCtrlDotFocus = true;
 
   const isEditable = t => { const tag = t?.tagName?.toLowerCase(); return tag==='input'||tag==='textarea'||t?.isContentEditable; };
   const isDialogOpen = () => {
     const ed = document.getElementById('editor'), st = document.getElementById('settings');
     return !!((ed&&(ed.open||ed.classList?.contains('is-open'))) || (st&&(st.open||st.classList?.contains('is-open'))));
   };
 
   document.addEventListener('keydown', e => {
     if (!(e.ctrlKey && e.key === '.')) return;
     if (isEditable(e.target) || isDialogOpen()) return;
 
     e.preventDefault(); e.stopImmediatePropagation();
 
     // フォーカス表示へ確実に切替して「今日」に合わせる
     (async ()=>{
       const today = new Date();
       if (typeof window.jumpFocusTo === 'function') {
         window.jumpFocusTo(today, 0);
         return;
       }
       // ▼ jumpFocusTo がグローバルで使えない場合のフォールバック
       const z = n => String(n).padStart(2,'0');
       const ymd = d => `${d.getFullYear()}-${z(d.getMonth()+1)}-${z(d.getDate())}`;
       // 月曜始まりの当週（月曜=0..日曜=6）
       const mon0 = (d)=> (d.getDay()+6)%7;
       const mondayOf = (d)=>{ const t=new Date(d.getFullYear(),d.getMonth(),d.getDate()); t.setDate(t.getDate()-mon0(t)); return t; };
 
       // 1) 当週へ合わせて再描画
       const needWeek = !(window.currentMonday instanceof Date) ||
                        window.currentMonday.getTime() !== mondayOf(today).getTime();
       if (needWeek){
         window.currentMonday = mondayOf(today);
         if (typeof window.render === 'function') window.render();
         // DOM確定を2フレーム待つ
         await new Promise(r => requestAnimationFrame(()=>requestAnimationFrame(r)));
       }
       // 2) 今日の列を特定してフォーカスへ
       const days = document.querySelectorAll('.day');
       const idx  = Math.min(mon0(today), Math.max(0, days.length-1));
       const hit  = days[idx];
       if (hit && typeof window.enterDayFocus === 'function') {
         window.enterDayFocus(hit);
       }
       document.body.classList.add('dayFocus'); // 念のため
       // 3) ピッカー/曜日バッジを同期
       const picker = document.getElementById('weekPicker');
       if (picker){ picker.value = ymd(today); picker.dispatchEvent(new Event('change',{bubbles:true})); }
       window.__setWeekdayFromISO?.(ymd(today));
	   window.__postWeekMoveCenter?.();   
     })();
   }, { capture:true });
 })();

 <!-- Ctrl＋,：今週へ（フォーカス中は週表示に戻す） -->
 (()=> {
   if (window.__bindCtrlCommaWeek) return; window.__bindCtrlCommaWeek = true;
   const isEditable = t => { const tag=t?.tagName?.toLowerCase(); return tag==='input'||tag==='textarea'||t?.isContentEditable; };
   const isDialogOpen = () => {
     const ed=document.getElementById('editor'), st=document.getElementById('settings');
     return !!((ed&&(ed.open||ed.classList?.contains('is-open'))) || (st&&(st.open||st.classList?.contains('is-open'))));
   };
   const z = n => String(n).padStart(2,'0');
   const ymd = d => `${d.getFullYear()}-${z(d.getMonth()+1)}-${z(d.getDate())}`;
   const mondayOf = (d)=>{ const t=new Date(d.getFullYear(),d.getMonth(),d.getDate()); t.setDate(t.getDate()-((t.getDay()+6)%7)); return t; };
 
   document.addEventListener('keydown', (e)=>{
     if (!(e.ctrlKey && e.key === ',')) return;
     if (isEditable(e.target) || isDialogOpen()) return;
     const picker = document.getElementById('weekPicker'); if (!picker) return;
 
     e.preventDefault(); e.stopImmediatePropagation();
     // 今日（必要なら週末スナップ）
     let today = new Date();
     if (typeof window.snapWeekendDir === 'function') today = window.snapWeekendDir(today, 0);
     // ▼ 今週の「月曜」を厳密に算出
     const mon = mondayOf(today);
 
    // フォーカス中なら週表示へ戻す（上寄せ＋先頭選択を予約／復元スキップ）
     if (document.body.classList.contains('dayFocus')) {
      // ★ 週移動直後の中央寄せ抑止＆“最上部スナップ”を予約
      window.__suppressCenterN = (window.__suppressCenterN|0) + 2;
      window.__snapTopOnNextRender = true;
      window.__snapTopTargetISO   = ymd(mon);
      // ★ 今週の先頭“選択可能”枠の選択も予約
      window.__selectFirstOnNextRender = true;	  
      // ★ フォーカス復元ロジックは走らせない（上寄せに委ねる）
      window.__skipRestoreOnExit = true;
      if (typeof window.exitDayFocus === 'function') window.exitDayFocus();
      else document.body.classList.remove('dayFocus');
     }
     // 今週へ：ピッカーも currentMonday も“月曜”で統一してから change 発火
     window.currentMonday = mon;
     picker.value = ymd(mon);                  // ← 本日の曜日ではなく“今週の月曜”をセット
    // ★ 週表示時も同様に「最上部スナップ＋先頭選択」を予約
    window.__suppressCenterN      = (window.__suppressCenterN|0) + 2;
    window.__snapTopOnNextRender  = true;
    window.__snapTopTargetISO     = ymd(mon);
    window.__selectFirstOnNextRender = true;
    // ★ 古い選択の復元を抑止（同週リレンダ時の再適用を防ぐ）
    window.lastSelectedKey = null;
    if (window.__slotCursor) window.__slotCursor.activeSlotEl = null;
    document.querySelector('.slot.focused')?.classList?.remove('focused');
     picker.dispatchEvent(new Event('change', { bubbles:true }));
     // 曜日バッジ等は「今日」を示したい場合のみ任意で同期
     window.__setWeekdayFromISO?.(ymd(today));	 
   }, { capture:true });
 })();

 (function bindArrowNavOnce(){
   if (window.__slotNavBound) return; window.__slotNavBound = true;

  // --- 初期自動選択：.focused が無ければ、左上から最初の選択可能スロットを青枠にする ---
  function ensureInitialSelectionGlobal(){
    if (document.querySelector('.slot.focused')) return; // 既に青枠があれば何もしない
    const days = Array.from(document.querySelectorAll('.day'));
    for (const d of days){
      const first = window.findFirstSelectableInDay?.(d);
      if (first) { window.setActiveSlot(first, {scroll:false}); return; }
    }
  }
  // ページ読み込み時
  if (document.readyState !== 'loading') { ensureInitialSelectionGlobal(); }
  document.addEventListener('DOMContentLoaded', ensureInitialSelectionGlobal, {once:true});
  window.addEventListener('load', ensureInitialSelectionGlobal, {once:true});
  // 週変更後（render 等の直後になるよう、ゼロ遅延でキューイング）
  (function(){
    const wp = document.getElementById('weekPicker');
    if (!wp) return;
    wp.addEventListener('change', ()=> setTimeout(ensureInitialSelectionGlobal, 0));
  })();  
   document.addEventListener('keydown', (e)=>{
    if (e.defaultPrevented) return;
    if (e.key !== 'ArrowUp' && e.key !== 'ArrowDown') return;
    // Ctrl押下時・入力中・ダイアログ開中は無効化（ショートカット／編集優先）
    if (e.ctrlKey) return;
    const t = e.target, tag = t?.tagName?.toLowerCase();
    if (tag==='input' || tag==='textarea' || t?.isContentEditable) return;
    const ed=document.getElementById('editor'), st=document.getElementById('settings');
    if ((ed&&(ed.open||ed.classList?.contains('is-open'))) ||
        (st&&(st.open||st.classList?.contains('is-open')))) return;
 
     const inFocus = document.body.classList.contains('dayFocus');
     let cur = getActiveSlot?.();
 
     // 未選択のとき：表示モードに応じて当日先頭/週の既定日先頭を選ぶ
     if (!cur) {
       if (inFocus) {
         const dayEl = document.querySelector('.day[data-focus="true"]');
         if (dayEl) ensureInitialSelectionForDay(dayEl);
         cur = getActiveSlot?.();
       } else {
        // 週表示：青枠が無ければ全体の左上から初期自動選択
        ensureInitialSelectionGlobal();
        cur = getActiveSlot?.();
       }
       if (!cur) return; // まだなければ何もしない
     }
 
     // 上下移動：週モードでは日またぎあり、フォーカスでは同日で止まる
     e.preventDefault();
     const delta = (e.key === 'ArrowDown' ? +1 : -1);
     moveVertWithCrossDay(cur, delta);
   });
 })();
  </script>
  <script>
(function(){
  const JP = ['日','月','火','水','木','金','土'];

  function ensureBadge(){
    const picker = document.getElementById('weekPicker');
    if (!picker) return null;
    let badge = document.getElementById('weekPickerWeekday');
    if (!badge) {
      badge = document.createElement('span');
      badge.id = 'weekPickerWeekday';
      picker.insertAdjacentElement('afterend', badge);
    }
    return badge;
  }

function setWeekdayFromISO(iso){
  const badge = ensureBadge();
  if (!badge || !iso) return;
  const [y,m,d] = iso.split('-').map(Number);
  const dt = new Date(Number(y), Number(m) - 1, Number(d), 12, 0, 0, 0);
  dt.setHours(12,0,0,0); // ← この行を追加（正午固定）
  if (!isNaN(dt)) badge.textContent = `（${JP[dt.getDay()]}）`;
}



  // ピッカー操作でも更新
  const picker = document.getElementById('weekPicker');
  if (picker) {
  picker.addEventListener('input',  () => {
    if (window.__suppressWeekChange) return;
    window.__setWeekdayFromISO?.(document.getElementById('weekPicker')?.value);
  });
  picker.addEventListener('change', () => {
    if (window.__suppressWeekChange) return;
    window.__setWeekdayFromISO?.(document.getElementById('weekPicker')?.value);
  });
    // 初期表示
    setWeekdayFromISO(picker.value);
  }

  // 他スクリプトから使えるように公開（1行呼ぶだけ）
  window.__setWeekdayFromISO = setWeekdayFromISO;
})();

 // ===== フォーカスモード中に「週ボタン/ピッカー」を日移動に切り替える拡張 =====
(()=> {
  // ---- ボタン／ピッカー ----
  const $prev   = document.getElementById('prevWeek');
  const $next   = document.getElementById('nextWeek');
  const $today  = document.getElementById('todayBtn');
  const $picker = document.getElementById('weekPicker');
  if (!$prev || !$next || !$today || !$picker) return;

  // ---- 状態判定（当初うまくいっていた軽量版）----
  const inDayFocus = () =>
    document.body.classList.contains('dayFocus');

  // ---- ユーティリティ ----
  const pad = n => String(n).padStart(2,'0');
  const ymd = d => `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
  const mon0 = d => (d.getDay() + 6) % 7;     // Mon=0..Sun=6（あなたのルール）
  const mondayOf = dt => startOfWeek(dt);     // 既存の startOfWeek を利用
   // 方向付き 週末スキップ
   // dir: -1=前日方向 / +1=翌日方向 / 0=今日（週末は月曜へ寄せる）
   const snapWeekendDir = (date, dir=0) => {
     const d = new Date(date.getFullYear(), date.getMonth(), date.getDate());
     const wd = d.getDay(); // 0:Sun ... 6:Sat
     if (dir > 0) {               // 翌日方向：Fri(+1)=>Sat→Mon / Sat→Mon / Sun→Mon
       if (wd === 6) d.setDate(d.getDate()+2); // Sat -> Mon
       else if (wd === 0) d.setDate(d.getDate()+1); // Sun -> Mon
     } else if (dir < 0) {        // 前日方向：Mon(-1)=>Sun→Fri / Sun→Fri / Sat→Fri
       if (wd === 0) d.setDate(d.getDate()-2); // Sun -> Fri
       else if (wd === 6) d.setDate(d.getDate()-1); // Sat -> Fri
     } else {                     // 今日ボタンなど：週末は営業日に寄せる（Sun->Mon / Sat->Fri）
       if (wd === 0) d.setDate(d.getDate()+1); // Sun -> Mon
       if (wd === 6) d.setDate(d.getDate()-1); // Sat -> Fri
     }
     return d;
   };
  const sameWeek = (a,b) => mondayOf(a).getTime() === mondayOf(b).getTime();

  // ---- フォーカス日ストア ----
  function getFocusDate(){
    if (window.currentFocusDate instanceof Date) return new Date(window.currentFocusDate);
    if ($picker.value){ const [y,m,d]= $picker.value.split('-').map(Number); return new Date(y,m-1,d); }
    return new Date();
  }
  function setFocusDateStore(d){
    window.currentFocusDate = new Date(d.getFullYear(), d.getMonth(), d.getDate());
  }

  // ---- 既存フォーカス印を必ずクリア（多重フォーカス防止）----
  function clearFocusedDays(){
    document.querySelectorAll('.day[data-focus="true"]').forEach(el => el.removeAttribute('data-focus'));
  }

  // ---- ラベル切替（当初の方式）----
  function updateLabels(){
    const prev  = document.getElementById('prevWeek');
    const next  = document.getElementById('nextWeek');
    const today = document.getElementById('todayBtn');
    if (!prev || !next || !today) return;
    if (inDayFocus()){
      prev.textContent  = '« 前日';
      next.textContent  = '翌日 »';
      today.textContent = '今日';
    } else {
      prev.textContent  = '« 前週';
      next.textContent  = '次週 »';
      today.textContent = '今週';
    }
  }
  new MutationObserver(updateLabels).observe(document.body, {attributes:true, attributeFilter:['class']});
  updateLabels();

  // ---- 日付ヘッダー dblclick でフォーカスに入った瞬間、当日を保存＆ピッカー同期 ----
  document.addEventListener('dblclick', (e)=>{
    const hdr = e.target.closest('.day-header-date, .day-header, .date, .date-cell, .day-title, .hdr');
    if (!hdr) return;
    const m = (hdr.textContent||'').match(/(\d{4})\/(\d{2})\/(\d{2})/);
    if (m){
      const d = new Date(+m[1], +m[2]-1, +m[3]);
      setFocusDateStore(d);
      if (inDayFocus()) $picker.value = ymd(d);
      requestAnimationFrame(updateLabels);
    }
  }, true);

  // ---- コア：日ジャンプ（週跨ぎOK・週末スキップ・常に日フォーカス維持）----
   async function jumpFocusTo(targetDate, dir=0){
    let target = new Date(targetDate.getFullYear(), targetDate.getMonth(), targetDate.getDate());
     target = snapWeekendDir(target, dir);         // 方向付きで週末補正
    setFocusDateStore(target);

    // 1) 週が変わるなら currentMonday を更新して既存の render() 実行
    if (!sameWeek(target, currentMonday)) {
      currentMonday = mondayOf(target);
	  currentMonday = mondayOf(target);
      render();
      // DOM確定待ち（2フレーム）
      await new Promise(r => requestAnimationFrame(()=> requestAnimationFrame(r)));
    }

    // 2) 対象列を index で取得（Mon=0.. → days.length にクリップ）
    clearFocusedDays();
    const days = document.querySelectorAll('.day');
    let idx = mon0(target);
    idx = Math.min(Math.max(0, idx), Math.max(0, days.length-1));
    const hit = days[idx];
    if (!hit){ exitDayFocus(); return; }

    // 3) フォーカス表示にする
    enterDayFocus(hit);                            // 既存の関数をそのまま使う
    document.body.classList.add('dayFocus'); // 念のため

    // 4) 実際に表示されている“その列の日付”を厳密に反映（ピッカー/ストアを揃える）
    const shown = new Date(currentMonday.getFullYear(), currentMonday.getMonth(), currentMonday.getDate());
    shown.setDate(shown.getDate() + idx);
    setFocusDateStore(shown);
    $picker.value = ymd(shown);

    updateLabels();
	window.__setWeekdayFromISO?.(ymd(shown));
  }

  // ---- フォーカス中のみ、週ボタンを「前日/翌日/今日」に差し替え（当初のキャプチャ方式）----
  function captureWhenFocus(fn){
    return function(e){
      if (inDayFocus()){
        e.preventDefault();
        e.stopImmediatePropagation();
        fn();
      }
    };
  }
   $prev .addEventListener('click', captureWhenFocus(()=>{ const d=getFocusDate(); d.setDate(d.getDate()-1); jumpFocusTo(d, -1); }), true);
   $next .addEventListener('click', captureWhenFocus(()=>{ const d=getFocusDate(); d.setDate(d.getDate()+1); jumpFocusTo(d, +1); }), true);
   $today.addEventListener('click', captureWhenFocus(()=>{ jumpFocusTo(new Date(), 0); }), true);

  // ---- フォーカス中のピッカー：その日に直接ジャンプ（週ロジックは通さない）----
   $picker.addEventListener('change', (e)=>{
    if (!inDayFocus()) return;     // 週モード時は既存の週ロジックに任せる
    e.preventDefault();
    e.stopImmediatePropagation();
    const v = $picker.value; if (!v) return;
    const [y,m,d] = v.split('-').map(Number);
     jumpFocusTo(new Date(y, m-1, d), 0);  // ピッカーは「その日」基準。週末は営業日に寄せる
  }, true);
})();

// ウィンドウサイズ変更時にもスロット表示を再計算する
(function(){
  let resizeTimer = null;
  window.addEventListener('resize', () => {
    if (resizeTimer) clearTimeout(resizeTimer);
    resizeTimer = setTimeout(() => {
      try {
        paintSlotsFromStore();
      } catch (e) {
        // 失敗してもアプリ全体が死なないようにしておく
        console && console.warn && console.warn('paintSlotsFromStore error on resize', e);
      }
    }, 200); // 連続resizeを少し待ってから実行
  });
})();

// ================================
// ★ JSON 保存／読み込みユーティリティ
//   - 単一 JSON ファイルで localStorage の中身を保存・復元
//   - メタ情報（保存日時・PC名）を記録
//   - 現在のアプリのデータ構造には手を触れない
// ================================

// このPCの名前（例：外来PC1、自宅PC など）を保存・取得
function getPcName() {
  let name = localStorage.getItem('__pcName');
  if (!name) {
    name = window.prompt('このPCの名前を入力してください（例：自宅PC, 外来PC1 など）', '');
    if (name) {
      localStorage.setItem('__pcName', name);
    } else {
      name = '';
    }
  }
  return name;
}

// 画面右上の「最終保存：…」表示を更新
function updateSaveInfo(meta) {
  const el = document.getElementById('saveInfo');
  if (!el) return;

  if (!meta) {
    // 保存メタ情報を localStorage から復元を試みる
    try {
      const s = localStorage.getItem('__lastMeta');
      if (s) meta = JSON.parse(s);
    } catch (e) {
      // 無視
    }
  }

  if (!meta) {
    el.textContent = '最終保存：未保存';
    return;
  }

  const when = meta.savedAtLocal || meta.savedAt || '';
  const who  = meta.savedBy || '';
  el.textContent = `最終保存：${when}${who ? ' by ' + who : ''}`;
}

// localStorage の中身を全部まとめて取得（このHTMLアプリ専用のオリジンなので基本安全）
function collectStorageForExport() {
  const data = {};
  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    // このユーティリティ用の内部キーは除外
    if (key === '__backup_last' || key === '__backup_beforeImport' || key === '__lastMeta' || key === '__pcName') continue;
    data[key] = localStorage.getItem(key);
  }
  return data;
}

// 現在の状態を JSON にしてダウンロードさせる
function exportScheduleToJson() {
  const now = new Date();
  const meta = {
    savedAt: now.toISOString(),
    savedAtLocal: now.toLocaleString(),
    savedBy: getPcName()
  };

  const storage = collectStorageForExport();
  const payload = { meta, storage };

  const json = JSON.stringify(payload, null, 2);

  // ローカルバックアップとしても保持（緊急用）
  try {
    localStorage.setItem('__backup_last', json);
    localStorage.setItem('__lastMeta', JSON.stringify(meta));
  } catch (e) {
    console.warn('ローカルバックアップ保存に失敗しました:', e);
  }

  // 画面の表示更新
  updateSaveInfo(meta);

  // ファイルとしてダウンロード（ファイル名は固定：schedule_data.json）
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'schedule_data.json';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// JSONファイルから localStorage を復元
function importScheduleFromJson(file) {
  const reader = new FileReader();
  reader.onload = function (e) {
    try {
      const text = e.target.result;
      const obj = JSON.parse(text);
      if (!obj || typeof obj !== 'object' || !obj.storage) {
        throw new Error('不正なデータ形式です（storage が見つかりません）。');
      }

      // いまの状態をバックアップとして保持しておく（万一の巻き戻し用）
      try {
        const backup = {};
        for (let i = 0; i < localStorage.length; i++) {
          const k = localStorage.key(i);
          backup[k] = localStorage.getItem(k);
        }
        localStorage.setItem('__backup_beforeImport', JSON.stringify(backup));
      } catch (e2) {
        console.warn('インポート前バックアップに失敗:', e2);
      }

      // いったんクリアしてから復元
      localStorage.clear();
      if (obj.storage && typeof obj.storage === 'object') {
        for (const [k, v] of Object.entries(obj.storage)) {
          localStorage.setItem(k, v);
        }
      }
      if (obj.meta) {
        localStorage.setItem('__lastMeta', JSON.stringify(obj.meta));
      }

      // アプリ全体を再描画（既存の render() を信頼）
      if (typeof render === 'function') {
        render();
      }

      updateSaveInfo(obj.meta || null);
      window.alert('JSONからの読み込みが完了しました。');
    } catch (err) {
      console.error(err);
      window.alert('JSONの読み込みに失敗しました：' + err.message);
    }
  };
  reader.readAsText(file, 'utf-8');
}

// 読込／保存ボタンと input にイベントをつなぐ
 document.addEventListener('DOMContentLoaded', () => {
   // === ヘルプボタンの左に「読込」「保存」「最終保存：…」を自動挿入 ===
   const helpBtn = document.getElementById('helpBtn');
   if (helpBtn && !document.getElementById('saveJsonBtn')) {
     const parent =
       helpBtn.parentElement ||
       helpBtn.closest('div,header,form') ||
       document.body;

   // グループ用コンテナ
   const group = document.createElement('span');
   group.id = 'jsonControls';
   group.className = 'json-controls';

     const loadBtn = document.createElement('button');
     loadBtn.id = 'loadJsonBtn';
     loadBtn.type = 'button';
     loadBtn.textContent = '読込';

     const saveBtn = document.createElement('button');
     saveBtn.id = 'saveJsonBtn';
     saveBtn.type = 'button';
     saveBtn.textContent = '保存';

     const infoSpan = document.createElement('span');
     infoSpan.id = 'saveInfo';
     infoSpan.className = 'save-info';
     infoSpan.textContent = '最終保存：未保存';

   // グループの中にまとめて入れてから、helpBtn の直前に差し込む
   group.appendChild(loadBtn);
   group.appendChild(saveBtn);
   group.appendChild(infoSpan);
   parent.insertBefore(group, helpBtn);
   }

   // 非表示の <input type="file"> を必要なら作成
   let fileInput = document.getElementById('jsonFileInput');
   if (!fileInput) {
     fileInput = document.createElement('input');
     fileInput.id = 'jsonFileInput';
     fileInput.type = 'file';
     fileInput.accept = 'application/json';
     fileInput.style.display = 'none';
     document.body.appendChild(fileInput);
   }

   // 初期表示時に保存情報を更新
   updateSaveInfo();

   const saveBtn = document.getElementById('saveJsonBtn');
   const loadBtn = document.getElementById('loadJsonBtn');

   if (saveBtn) {
     saveBtn.addEventListener('click', () => {
       exportScheduleToJson();
     });
   }

   if (loadBtn && fileInput) {
     loadBtn.addEventListener('click', () => {
       fileInput.click();
     });

     fileInput.addEventListener('change', (e) => {
       const file = e.target.files[0];
       if (file) {
         importScheduleFromJson(file);
       }
       // 同じファイルを続けて選べるように value をリセット
       e.target.value = '';
     });
   }
 });

</script>

  <button id="helpBtn" aria-haspopup="dialog" aria-controls="helpDialog">❔</button>
 
  <script>
  (function(){
    const btn = document.getElementById('helpBtn');
    if(!btn) return;
    // 候補となるツールバー要素（存在するものに挿入）
    const selectors = [
      '#topbar','.topbar','#toolbar','.toolbar',
      '.header-actions','#header .actions',
      '#controls','.controls','#rightButtons'
    ];
    const host = selectors.map(s=>document.querySelector(s)).find(el=>el);
    if(host){
      btn.classList.add('docked');
      host.appendChild(btn);
    }
  })();
  </script>
  <dialog id="helpDialog">
    <div style="min-width:420px;max-width:640px;padding:20px;">
      <h2>操作ヘルプ</h2>
      <table class="help-table">
        <tr><th><kbd>↑</kbd> / <kbd>↓</kbd> / <kbd>←</kbd> / <kbd>→</kbd></th><td>スロットを上下左右に移動</td></tr>r>
        <tr><th><kbd>Enter</kbd></th><td>編集開始（編集ウィンドウを開く）</td></tr>
        <tr><th><kbd>ESC</kbd></th><td>編集終了／週表示に戻る</td></tr>
        <tr><th>日付セルをダブルクリック</th><td>その日のフォーカス表示へ切替</td></tr>
        <tr><th>時刻セルをダブルクリック</th><td>開始時刻を編集（例：<code>1100</code> → <code>11:00</code>）</td></tr>
        <tr><th><kbd>Shift</kbd>＋ダブルクリック<br><small>（時刻セル）</small></th><td>その日の全スロットの「時刻」をデフォルトに一括リセット</td></tr>
        <tr><th><kbd>Alt</kbd>＋ダブルクリック<br><small>（時刻セル）</small></th><td>そのスロットのみ「時刻」をデフォルトにリセット</td></tr>
        <tr><th><kbd>Ctrl</kbd>＋<kbd>C</kbd> / <kbd>V</kbd> / <kbd>X</kbd></th><td>コピー／貼り付け／切り取り</td></tr>
        <tr><th><kbd>Ctrl</kbd>＋<kbd>Z</kbd> / <kbd>Y</kbd></th><td>元に戻す／やり直し</td></tr>
		<tr><th><kbd>Ctrl</kbd>＋<kbd>.</kbd> ／ <kbd>,</kbd></th><td><kbd>Ctrl</kbd>＋<kbd>.</kbd>：本日へ移動　／　<kbd>Ctrl</kbd>＋<kbd>,</kbd>：今週へ移動</td></tr>
		<tr><th><kbd>Ctrl</kbd>＋<kbd>←</kbd> ／ <kbd>→</kbd></th><td>週表示：前週／翌週　｜　フォーカス表示：前日／翌日</td></tr>
		<tr><th><kbd>Ctrl</kbd>＋<kbd>￥</kbd>or<kbd>＼</kbd></th><td>選択中のスロットをフォーカス表示　｜　週表示に戻る</td></tr>
		<tr><th><kbd>Ctrl</kbd>＋<kbd>2</kbd> / <kbd>4</kbd> / <kbd>5</kbd></th><td>レイアウト切替（2列／4列／5列表示）</td></tr>
      </table>
      <p style="margin-top:1rem;">その他の操作は順次ここに追記予定です。</p>
      <button id="helpCloseBtn">閉じる</button>
    </div>
  </dialog>  
  <script>
  (function(){
    const btn = document.getElementById('helpBtn');
    const dlg = document.getElementById('helpDialog');
    const closeBtn = document.getElementById('helpCloseBtn');
    if(!btn || !dlg) return;
 
    // 開く
    btn.addEventListener('click', ()=> {
      if (!dlg.open) dlg.showModal();
    });
 
    // 閉じる（ボタン）
    closeBtn?.addEventListener('click', ()=> dlg.close());
 
    // 背景クリックで閉じる
    dlg.addEventListener('click', (e)=>{
      if (e.target === dlg) dlg.close();
    });
  })();
  </script>
  <script>
  (function(){
    const dlg = document.getElementById('helpDialog');
    if(!dlg) return;
    // ダイアログ内のESCは外へ伝播させない（週表示への切替などを防止）
    dlg.addEventListener('keydown', (e)=>{
      if(e.key === 'Escape'){ e.stopPropagation(); }
    });
    // 開閉にあわせてフラグを付与（他のESC制御が参照できるように）
    dlg.addEventListener('close', ()=> { delete document.body.dataset.modalOpen; });
    dlg.addEventListener('cancel', (e)=>{ e.stopPropagation(); }); // 念のため
    const openObs = new MutationObserver(()=>{
      if(dlg.open) document.body.dataset.modalOpen = '1';
    });
    openObs.observe(dlg, { attributes:true, attributeFilter:['open'] });
  })();
  </script>
<!-- Ctrl+¥（Backslash）: 週表示で“アクティブ日のフォーカス”へ入る -->
<script>
(()=> {
  if (window.__bindCtrlBackslashFocus) return; window.__bindCtrlBackslashFocus = true;

  const isEditable = t => { const tag=t?.tagName?.toLowerCase(); return tag==='input'||tag==='textarea'||t?.isContentEditable; };
  const isDialogOpen = () => {
    const ed=document.getElementById('editor'), st=document.getElementById('settings');
    return !!((ed&&(ed.open||ed.classList?.contains('is-open'))) || (st&&(st.open||st.classList?.contains('is-open'))));
  };

  document.addEventListener('keydown', (e)=>{
    if (!e.ctrlKey) return;
    const isBackslash = (e.code==='Backslash'||e.code==='IntlYen'||['\\','¥','￥'].includes(e.key));
    if (!isBackslash) return;
    if (isEditable(e.target) || isDialogOpen()) return;

  // 🔁 フォーカス中は「週表示に戻る」
  if (document.body.classList.contains('dayFocus')) {
    e.preventDefault(); e.stopImmediatePropagation();

    // ★ いまフォーカスしているスロットを控えておく
    const cur =
      (typeof window.getActiveSlot === 'function' && window.getActiveSlot()) ||
      document.querySelector('.slot.focused');

    // 従来どおり「復元ロジックは exitDayFocus 内ではスキップ」
    window.__skipRestoreOnExit = true;
    if (typeof window.exitDayFocus === 'function') window.exitDayFocus();

    if (cur) {
      // ★ 週表示に戻った“あと”で元のスロットを再アクティブ化＆センタリング
      requestAnimationFrame(() => {
        // suppress が邪魔しないようにクリアしておく（念のため）
        window.__suppressCenterN = 0;

        if (typeof window.setActiveSlot === 'function') {
          // スクロールはここではさせず、あとで __centerActiveInWeekSoon に任せる
          window.setActiveSlot(cur, { scroll: false });
        } else {
          // 保険：setActiveSlot が無い場合
          document.querySelectorAll('.slot.focused')
            .forEach(el => el.classList.remove('focused'));
          cur.classList.add('focused');
        }

        // ★ いつもの「シンプル・確実センタリング」で中央付近へ
        window.__centerActiveInWeekSoon?.();
      });
    }
    return;
  }


    const slot = document.querySelector('.slot.focused');
    if (!slot) return; // アクティブなし
    const dayEl = slot.closest('.day');
    if (!dayEl) return;

    e.preventDefault(); e.stopImmediatePropagation();
    if (typeof window.enterDayFocus === 'function') {
      window.enterDayFocus(dayEl);
    }
  }, {capture:true});
})();

// --- 印刷時：4列/5列レイアウトを一時解除して2列相当で印刷する ---
(function(){
  let prevColsClass = null;

  function beforePrintCols(){
    const body = document.body;
    if (!body) return;
    // すでに処理済みなら何もしない
    if (prevColsClass !== null) return;

    if (body.classList.contains('fiveCols')) {
      prevColsClass = 'fiveCols';
    } else if (body.classList.contains('fourCols')) {
      prevColsClass = 'fourCols';
    } else {
      // 2列表示など、特に切り替え不要なとき
      prevColsClass = null;
      return;
    }
    // 印刷用に 4/5列クラスを一時的に外す → 2列相当レイアウトに戻る
    body.classList.remove('fourCols', 'fiveCols');
  }

  function afterPrintCols(){
    const body = document.body;
    if (!body) return;
    // 元のレイアウトに戻す
    if (prevColsClass) {
      body.classList.add(prevColsClass);
    }
    prevColsClass = null;
  }

  window.addEventListener('beforeprint', beforePrintCols);
  window.addEventListener('afterprint',  afterPrintCols);
})();
// --- 印刷時：ID・年齢などを含めた「フル表示モード」にして再描画 ---
(function(){
  function addPrintMode(){
    const body = document.body;
    if (!body) return;
    if (body.classList.contains('printMode')) return;

    body.classList.add('printMode');

    // ★ 印刷用レイアウト（2列 & printMode）で幅を計測し直して再描画
    if (typeof paintSlotsFromStore === 'function'){
      paintSlotsFromStore();
    }
  }

  function removePrintMode(){
    const body = document.body;
    if (!body) return;
    if (!body.classList.contains('printMode')) return;

    body.classList.remove('printMode');

    // ★ 通常表示用に戻した状態でもう一度再描画
    if (typeof paintSlotsFromStore === 'function'){
      paintSlotsFromStore();
    }
  }

  window.addEventListener('beforeprint', addPrintMode);
  window.addEventListener('afterprint',  removePrintMode);
})();

</script>  
 
 </body>
</html>
